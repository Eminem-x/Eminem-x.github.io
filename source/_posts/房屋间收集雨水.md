---
title: 房屋间收集雨水
categories:
- 算法
- 贪心
tags:
- 算法
mathjax: true
---

### 房屋间收集雨水（ 贪心 ）

<!--more-->

> 给你一个下标从 0 开始的字符串 street 。
>
> street 中每个字符要么是表示房屋的 'H' ，要么是表示空位的 '.' 。
>
> 你可以在 空位 放置水桶，从相邻的房屋收集雨水。
>
> 位置在 i - 1 或者 i + 1 的水桶可以收集位置为 i 处房屋的雨水。
>
> 一个水桶如果相邻两个位置都有房屋，那么它可以收集 两个 房屋的雨水。
>
> 在确保每个房屋旁边都至少有一个水桶的前提下，请你返回需要的 最少 水桶数。如果无解请返回 -1 。
>
> ```html
> 输入：street = "H..H"
> 输出：2
> ```
>
> 题目详情参考：[2086. 从房屋收集雨水需要的最少水桶数 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/minimum-number-of-buckets-required-to-collect-rainwater-from-houses/)

思路：**如果房屋周围可以收集雨水，那么先判断是否左边可以共享，不行的话尽可能使用右边空间。**

1. 创建变量 `index` 记录可以被共享的位置，遍历更新即可；
2. 先判断左边是否存在空位以及是否已被使用，如果可以，那么跳过；
3. 反之，判断右边是否存在空位，如果可以，记录位置并且更新结果；
4. 如果左右均没有空位，返回 `-1`;

代码如下：

```java
class Solution {
    public int minimumBuckets(String street) {
        int len = street.length();
        int ans = 0;
        // 记录可以被共享的位置
        int index = -1;
        for(int i = 0; i < len; i++) {
            if(street.charAt(i) == 'H') {
                // 先判断左边是否可以共享
                if(i - 1 >= 0 && street.charAt(i - 1) == '.') {
                    if(index != i - 1) {
                        // 如果左边没有被共享过 优先选择右边
                        if(i + 1 < len && street.charAt(i + 1) == '.') {
                            index = i + 1;
                        }
                        ans++;
                    }
                } else if(i + 1 < len && street.charAt(i + 1) == '.') {
                    index = i + 1;
                    ans++;
                } else {
                    return -1;
                }
            }
        }
        return ans;
    }
}
```

$$
\begin{align}
&时间复杂度:O(n)
&空间复杂度:O(1)
\end{align}
$$

