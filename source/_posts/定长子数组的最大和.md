---
title: 定长子数组的最大和
categories:
- 算法
- 滑动窗口
tags:
- 算法
mathjax: true
---

### 定长子数组的最大和（ 滑动窗口 ）
<!--more-->

>给你一个整数数组 nums 和一个整数 k ，找出三个长度为 k 、互不重叠、
>
>且 3 * k 项的和最大的子数组，并返回这三个子数组。
>
>以下标的数组形式返回结果，数组中的每一项分别指示每个子数组的起始位置（下标从 0 开始）。
>
>如果有多个结果，返回字典序最小的一个。
>
>```html
>输入：nums = [1,2,1,2,6,7,5,1], k = 2
>输出：[0,3,5]
>```
>题目详情参考：[689. 三个无重叠子数组的最大和 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/maximum-sum-of-3-non-overlapping-subarrays/)

### 解法一：滑动窗口

思路：三个长度为 k 且不互相重叠的子数组最大和，先考虑一个、两个的情况。

#### 模型一：单个长度为 k 的子数组最大和

思路：规定一个长度为 k 的窗口，向右滑动，寻找最大和。

1. 求和时不需要每次都重新求和，这样会增加时间复杂度；
2. 窗口向右滑动过程中，减去左值，加上新值，即为这一段数组和；

代码如下：

```java
class Solution {
    public int[] maxSumOfOneSubarray(int[] nums, int k) {
        int[] ans = new int[1];
        int sum1 = 0, maxSum1 = 0;
        for (int i = 0; i < nums.length; ++i) {
            sum1 += nums[i];
            if (i >= k - 1) {
                if (sum1 > maxSum1) {
                    maxSum1 = sum1;
                    ans[0] = i - k + 1;
                }
                sum1 -= nums[i - k + 1];
            }
        }
        return ans;
    }
}
```

$$
\begin{align}
&时间复杂度:O(n)
&空间复杂度:O(1)
\end{align}
$$

#### 模型二：两个长度为 k 的不重叠子数组最大和

思路：规定两个长度为 k 的不重叠窗口，第一个从 [0,k-1]开始，第二个从[k,2k - 1]开始；

1. 两个窗口同时向右滑动，滑动过程中，记录更新第一个窗口的最大和值 `maxSum1`；
2. 每次记录更新 `maxSum1` + `sum2` 的最大值，并存储下标信息即对应位置；

思路正确性的说明：

1. 对于窗口二而言，每次加上的一定是前面不与自己重叠的最大窗口值；
2. 而对于整体而言，两个窗口和的最大值也在不断随之更新。

代码如下：

```java
class Solution {
    public int[] maxSumOfTwoSubarrays(int[] nums, int k) {
        int[] ans = new int[2];
        int sum1 = 0, maxSum1 = 0, maxSum1Idx = 0;
        int sum2 = 0, maxSum12 = 0;
        for (int i = k; i < nums.length; ++i) {
            sum1 += nums[i - k];
            sum2 += nums[i];
            if (i >= k * 2 - 1) {
                if (sum1 > maxSum1) {
                    maxSum1 = sum1;
                    maxSum1Idx = i - k * 2 + 1;
                }
                if (maxSum1 + sum2 > maxSum12) {
                    maxSum12 = maxSum1 + sum2;
                    ans[0] = maxSum1Idx;
                    ans[1] = i - k + 1;
                }
                sum1 -= nums[i - k * 2 + 1];
                sum2 -= nums[i - k + 1];
            }
        }
        return ans;
    }
}
```
$$
\begin{align}
&时间复杂度:O(n)
&空间复杂度:O(1)
\end{align}
$$

#### 该题目的解析：

思路：规定两个长度为 k 的不重叠窗口，分别从[0,k-1]、[k,2k - 1]、[2k,3k-1]开始，；

1. 我们同时向右滑动这三个窗口，按照模型二的方法并维护 maxSum12 及其对应位置；
2. 每次滑动时，计算当前 maxSum12 与 sum3之和；
3. 统计这一过程中的 maxSum12 + sum3 的最大值及其对应位置；
4. 当且仅当最大和值大于记录时，才更新下标，保证字典序。

**细节：在更新 maxSum12 时也更新两个窗口的起始位置，因为第一个窗口最大时，不意味着和最大。**

代码如下：

```java
class Solution {
    public int[] maxSumOfThreeSubarrays(int[] nums, int k) {
        int[] ans = new int[3];
        int sum1 = 0, maxSum1 = 0, maxSum1Index = 0;
        int sum2 = 0, maxSum12 = 0, maxSum2Index1 = 0, maxSum2Index2 = 0;
        int sum3 = 0, maxTotal = 0;
        for (int i = 2 * k; i < nums.length; i++) {
            sum1 += nums[i - 2 * k];
            sum2 += nums[i - k];
            sum3 += nums[i];
            if (i >= 3 * k - 1) {
                if (sum1 > maxSum1) {
                    maxSum1 = sum1;
                    maxSum1Index = i - 3 * k + 1;
                }
                if (sum2 + maxSum1 > maxSum12) {
                    maxSum12 = sum2 + maxSum1;
                    maxSum2Index1 = maxSum1Index;
                    maxSum2Index2 = i - 2 * k + 1;
                }
                if (sum3 + maxSum12 > maxTotal) {
                    maxTotal = sum3 + maxSum12;
                    ans[0] = maxSum2Index1;
                    ans[1] = maxSum2Index2;
                    ans[2] = i - k + 1;
                }
                sum1 -= nums[i - k * 3 + 1];
                sum2 -= nums[i - k * 2 + 1];
                sum3 -= nums[i - k + 1];
            }
        }
        return ans;
    }
}
```
$$
\begin{align}
&时间复杂度:O(n)
&空间复杂度:O(1)
\end{align}
$$



