---
title: 状态压缩
categories:
- 算法
- 状态压缩
tags:
- 算法
mathjax: true
---

### 状态压缩

<!--more-->

#### **Preface**

在平常刷题的过程中，遇到过几次状态压缩的题目，很多次都因为畏难，没有深入地学习下去，

后来在竞赛中遇到了相同解法的题目，懊悔以前没有静下心来认真地去思考，

在学习过后，觉得算法思想其实并不复杂，或许复杂的是难以接受新的事物。

推荐一篇状态压缩的文章：<a href="https://leetcode-cn.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks/solution/zhuang-ya-dpshi-shi-hou-xue-xi-yi-xia-li-q4mk/">状态压缩学习文章</a>

以及几道常见的题目，均来源于 LeetCode：

* <a href="https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets/">统计按位或能得到最大值的子集数目</a>
* <a href="https://leetcode-cn.com/problems/maximum-number-of-achievable-transfer-requests/">[最多可达成的换楼请求数目](https://leetcode-cn.com/problems/maximum-number-of-achievable-transfer-requests/)</a>
* <a href="https://leetcode-cn.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/">[两个回文子序列长度的最大乘积](https://leetcode-cn.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/)</a>

接下来的篇幅以**两个回文子序列长度的最大乘积**为例子，去阐述状态压缩的思想

-----

### 思路

状态压缩其实本质就是一种穷举暴力，不过其好处在于，便于处理问题，

原本问题的解决需要对原模型求子集，但这是一个不容易处理和记录的方法，

而状态压缩相当于将每一个子集对应的状态，以二进制数字的方式存储，

因此状态压缩的基础时间复杂度就是 O(2<sup>n</sup>)，所以数据量一般不会超过 20。



以该题为例：

不妨先求出该字符串的所有子序列，然后再判断当前字符串是否为回文串，

然后与其后的子序列按照题意，进行计算求值，模拟遍历即可。

**其核心代码代码如下：**

```java
class Solution {
    public int maxProduct(String s) {
        int n = s.length(), m = 1 << n;
        List<int[]> list = new ArrayList<>();
        char[] str = s.toCharArray();
        for (int i = 0; i < m; i++) {
            if (isPalindromic(str, i)) {
                list.add(new int[]{i, Integer.bitCount(i)});
            }
        }
        // 模拟便利 返回结果即可
    }

    private boolean isPalindromic(char[] s, int state) {
        int left = 0;
        int right = s.length - 1;
        // 检查 state 对应的子序列是不是回文串
        while (left < right) {
            // 将 left 和 right 对应上 「状态所对应的字符」 位置
            while (left < right && (state >> left & 1) == 0) {
                left++;
            }
            while (left < right && (state >> right & 1) == 0) {
                right--;
            }
            if (s[left] != s[right]) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
}
```

**而其中最核心的代码，无疑就是如何进行状态压缩以及匹配的那一段，**

更加抽象的代码块如下：

```java
int len = nums.length;
int m = 1 << len;
for (int i = 1; i < m; i++) {
    // 检查当前状态对应的子序列
    List<Integer> list = new ArrayList<>();
    for (int j = 0; j < len; j++) {
        if((i >> j & 1) != 0) {
        list.add(j);
    }    
}
```

$$
\begin{align}
& 时间复杂度:O(2^n)
& 空间复杂度:O(2^n)
\end{align}
$$

