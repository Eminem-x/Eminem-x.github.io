---
title: 无限整数序列中定位数字
categories:
- 算法
- 数学
tags:
- 算法
mathjax: true
---

### 第 N 位数字（数学）

<!--more-->

> > 给你一个整数 `n` ，请你在无限的整数序列 `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...]` 中找出并返回第 `n` 位上的数字。
> >
> > ```java
> > 输入：n = 11
> > 输出：0
> > ```

### 解法一：模拟查找

思路：将所有数字用字符串拼接，然后直接定位 `n` 返回当前下标的数字即可。

错误：因为 `n` 的取值范围是 `1 <= n <= 2^31 - 1`，会超出时间限制，无法解答，

​			实际上经过测试，当数据规模超过 10<sup>6</sup> 的规模时，就会超出时间限制。

---

### 解法二：数学定位

思路：如果能够确定第 `n` 位上的数字，所在数字的位数，那么就可以进行定位求解。

1. `x` 位共计有 9 × 10<sup> x - 1</sup>个数字，共计有 `x` × 9 × 10<sup> x - 1</sup>位数字；

2. 使用 *d* 和 *count* 分别表示当前遍历到的位数和当前位数下的所有整数的位数之和；

3. 初始时 `d = 1`、`count = 9`，而后随之变化；

4. 每次将 <em>n</em> 减去 <em>d×count</em>，然后将 <em>d</em> 加 <em>1</em>，将 <em>count</em> 乘 <em>10</em>，直到 <em>n ≤ d×count</em> ;

5. 此时的 `d` 即为第 `n` 位上数字所在的数字位数，*n* 是所有 *d* 位数中从第一位到目标数字的位数；

6. 使用目标数字在所有 <em>d</em> 位数中的下标进行计算，下标从 <em>0</em> 开始计数，

   令  <em>index=n−1</em>，则 <em>index</em> 即为目标数字在所有 <em>d</em> 位数中的下标，<em>index</em> 的最小可能取值是 <em>0</em> ;

7. 第 <em>n</em> 位数字是第 <em>m</em> 个 <em>d</em> 位数的第  <em>index mod d</em> 位，**注意编号都从 <em>0</em> 开始**;

8. 由于最小的 <em>d</em> 位数是 <em>10<sup>d - 1</sup></em>，因此第 <em>n</em> 位数字所在的整数是 <em>10<sup>d - 1</sup> + m</em>，

   该整数的右边第 <em>d − ( index mod d ) − 1</em> 位（计数从 <em>0</em> 开始）即为无限整数序列中的第 <em>n</em> 位。
   $$
   m = [\frac{index}{d}]
   $$

代码如下：

```java
class Solution {
    public int findNthDigit(int n) {
        int d = 1, count = 9;
        while (n > (long) d * count) {
            n -= d * count;
            d++;
            count *= 10;
        }
        int index = n - 1;
        int start = (int) Math.pow(10, d - 1);
        int num = start + index / d;
        int digitIndex = index % d;
        int digit = (num / (int)(Math.pow(10, d - digitIndex - 1))) % 10;
        return digit;
    }
}
```

$$
\begin{align}
&时间复杂度:O(log_{10}n)
&空间复杂度:O(1)
\end{align}
$$

---

### 解法三：二分优化

思路：如果范围更广一些，可以对查找 `d` 的部分进行优化，采用二分查找。

结合解法二的从 `1` 开始遍历，当遍历到 `9` 时，即第九位个数时可知：
$$
9 × 9 × 10^8 = 8.1 × 10^9 ＞ 2^{31} - 1
$$
因此只需要在 `1 - 9` 之间进行二分查找即可。

代码如下：

```java
class Solution {
    public int findNthDigit(int n) {
        int low = 1, high = 9;
        while (low < high) {
            int mid = (high - low) / 2 + low;
            if (totalDigits(mid) < n) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        int d = low;
        int prevDigits = totalDigits(d - 1);
        int index = n - prevDigits - 1;
        int start = (int) Math.pow(10, d - 1);
        int num = start + index / d;
        int digitIndex = index % d;
        int digit = (num / (int) (Math.pow(10, d - digitIndex - 1))) % 10;
        return digit;
    }

    public int totalDigits(int length) {
        int digits = 0;
        int curLength = 1, curCount = 9;
        while (curLength <= length) {
            digits += curLength * curCount;
            curLength++;
            curCount *= 10;
        }
        return digits;
    }
}
```

$$
\begin{align}
&时间复杂度:O(log_{10}n×loglog_{10}n)
&空间复杂度:O(1)
\end{align}
$$

