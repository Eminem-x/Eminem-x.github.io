---
title: 祖玛游戏
categories:
- 算法
- 广度优先搜索
tags:
- 算法
mathjax: true
---

### 祖玛游戏（ 搜索剪枝 | 记忆化搜索）

<!--more-->

> >祖玛游戏的最小步数求解
> >
> >题目详情参见：<a>[488. 祖玛游戏 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/zuma-game/)</a>

### 题目分析：

1. 因为插入球的选择和颜色情况太多，并且所带来的影响可能是在多次操作后才能体现出来，

   因此倘若使用贪心算法，很难建立起全局最优的决策，故而不采用贪心；

2. 因此需要对状态空间进行枚举，通过穷尽所有的可能来找到最优解，

   并使用剪枝的方法来优化搜索过程；

3. 如果使用深度优先搜索，则需要使用记忆化搜索，以避免重复计算相同的状态；

4. 该题目只需要得到回合数最少的方案，因此广度优先搜索即可;

5. 设当前桌面上有 n 个球，手中持有 m 个球，
     $$
     则此时一共有C^m_{m+n} * m! = A^m_{m+n}种插入方法
     $$


### 解法一：BFS + 剪枝

思路：不妨规定，每一种不同的桌面上球的情况和手中球的情况的组合都是一种不同的状态，

​			然后对状态空间进行枚举，即可得解答；

**在搜索过程中，需要剪枝来简化算法的复杂性:**

* 手中颜色相同的球每次选择时只需要考虑其中一个即可；
* 只在连续相同颜色的球的开头位置或者结尾位置插入新的颜色相同的球；
* 只考虑放置新球后有可能得到更优解的位置，以下三种情况：
  1. 插入新球与插入位置右侧的球颜色相同
  2. 插入新球与插入位置两侧的球颜色均不相同，且插入位置两侧的球的颜色不同
  3. 插入新球与插入位置两侧的球颜色均不相同，且插入位置两侧的球的颜色相同
  4. 对于如果手中的球全部插入也无法满足新的消除，则直接进行中止

**当然还可以有更多的剪枝技巧。**

<p>具体实现的细节处理：</p>

1. 消除操作后，如果导致出现了新的连续三个以上颜色相同的球，

   则继续消除这些球，直到不再满足消除条件；

2. 消除时利用栈的特性，每次遇到连续可以消除的球时，将其从栈中弹出；

代码如下：

```java
class Solution {
    public int findMinStep(String board, String hand) {
        char[] arr = hand.toCharArray();
        Arrays.sort(arr);
        hand = new String(arr);

        // 初始化用队列维护的状态队列：其中的三个元素分别为桌面球状态、手中球状态和回合数
        Queue<State> queue = new ArrayDeque<State>();
        queue.offer(new State(board, hand, 0));

        // 初始化用哈希集合维护的已访问过的状态
        Set<String> visited = new HashSet<String>();
        visited.add(board + " " + hand);

        while (!queue.isEmpty()) {
            State state = queue.poll();
            String curBoard = state.board;
            String curHand = state.hand;
            int step = state.step;
            for (int i = 0; i <= curBoard.length(); ++i) {
                for (int j = 0; j < curHand.length(); ++j) {
                    // 第 1 个剪枝条件: 当前球的颜色和上一个球的颜色相同
                    if (j > 0 && curHand.charAt(j) == curHand.charAt(j - 1)) {
                        continue;
                    }

                    // 第 2 个剪枝条件: 只在连续相同颜色的球的开头位置插入新球
                    if (i > 0 && curBoard.charAt(i - 1) == curHand.charAt(j)) {
                        continue;
                    }

                    // 第 3 个剪枝条件: 只在以下两种情况放置新球
                    boolean choose = false;
                    //  - 第 1 种情况 : 当前球颜色与后面的球的颜色相同
                    if (i < curBoard.length() && curBoard.charAt(i) == curHand.charAt(j)) {
                        choose = true;
                    }
                    //  - 第 2 种情况 : 当前后颜色相同且与当前颜色不同时候放置球
                    if (i > 0 && i < curBoard.length() && 
                        curBoard.charAt(i - 1) == curBoard.charAt(i) && 
                        curBoard.charAt(i - 1) != curHand.charAt(j)) {
                        choose = true;
                    }

                    if (choose) {
                        String newBoard = clean(curBoard.substring(0, i) + 
                                                curHand.charAt(j) + curBoard.substring(i));
                        String newHand = curHand.substring(0, j) + curHand.substring(j + 1);
                        if (newBoard.length() == 0) {
                            return step + 1;
                        }
                        String str = newBoard + " " + newHand;
                        if (visited.add(str)) {
                            queue.offer(new State(newBoard, newHand, step + 1));
                        }
                    }
                }
            }
        }
        return -1;
    }

    public String clean(String s) {
        StringBuffer sb = new StringBuffer();
        Deque<Character> letterStack = new ArrayDeque<Character>();
        Deque<Integer> countStack = new ArrayDeque<Integer>();
        
        for (int i = 0; i < s.length(); ++i) {
            char c = s.charAt(i);
            while (!letterStack.isEmpty() && c != letterStack.peek() && countStack.peek() >= 3) {
                letterStack.pop();
                countStack.pop();
            }
            if (letterStack.isEmpty() || c != letterStack.peek()) {
                letterStack.push(c);
                countStack.push(1);
            } else {
                countStack.push(countStack.pop() + 1);
            }
        }
        if (!countStack.isEmpty() && countStack.peek() >= 3) {
            letterStack.pop();
            countStack.pop();
        }
        while (!letterStack.isEmpty()) {
            char letter = letterStack.pop();
            int count = countStack.pop();
            for (int i = 0; i < count; ++i) {
                sb.append(letter);
            }
        }
        sb.reverse();
        return sb.toString();
    }
}

class State {
    String board;
    String hand;
    int step;

    public State(String board, String hand, int step) {
        this.board = board;
        this.hand = hand;
        this.step = step;
    }
}
```

$$
\begin{align}
&时间复杂度:O(m×n×A^n_{m+n})\\
&空间复杂度:O((m+n)×A^m_{m+n})
\end{align}
$$

---

### 解法二：记忆化搜索（AStar算法）

代码如下：

```java
class Solution {
    Map<String, Integer> dp = new HashMap<String, Integer>();

    public int findMinStep(String board, String hand) {
        char[] arr = hand.toCharArray();
        Arrays.sort(arr);
        hand = new String(arr);
        int ans = dfs(board, hand);
        return ans <= 5 ? ans : -1;
    }

    public int dfs(String board, String hand) {
        if (board.length() == 0) {
            return 0;
        }
        String key = board + " " + hand;
        if (!dp.containsKey(key)) {
            int res = 6;
            for (int j = 0; j < hand.length(); ++j) {
                // 第 1 个剪枝条件: 当前球的颜色和上一个球的颜色相同
                if (j > 0 && hand.charAt(j) == hand.charAt(j - 1)) {
                    continue;
                }
                for (int i = 0; i <= board.length(); ++i) {
                    // 第 2 个剪枝条件: 只在连续相同颜色的球的开头位置插入新球
                    if (i > 0 && board.charAt(i - 1) == hand.charAt(j)) {
                        continue;
                    }

                    // 第 3 个剪枝条件: 只在以下两种情况放置新球
                    boolean choose = false;
                    //  - 第 1 种情况 : 当前球颜色与后面的球的颜色相同
                    if (i < board.length() && board.charAt(i) == hand.charAt(j)) {
                        choose = true;
                    }
                    //  - 第 2 种情况 : 当前后颜色相同且与当前颜色不同时候放置球
                    if (i > 0 && i < board.length() && 
                        board.charAt(i - 1) == board.charAt(i) && 
                        board.charAt(i - 1) != hand.charAt(j)) {
                        choose = true;
                    }

                    if (choose) {
                        String newBoard = clean(board.substring(0, i) + 
                                                hand.charAt(j) + board.substring(i));
                        String newHand = hand.substring(0, j) + hand.substring(j + 1);
                        res = Math.min(res, dfs(newBoard, newHand) + 1);
                    }
                }
            }
            dp.put(key, res);
        }
        return dp.get(key);
    }

    public String clean(String s) {
        StringBuffer sb = new StringBuffer();
        Deque<Character> letterStack = new ArrayDeque<Character>();
        Deque<Integer> countStack = new ArrayDeque<Integer>();
        
        for (int i = 0; i < s.length(); ++i) {
            char c = s.charAt(i);
            while (!letterStack.isEmpty() && c != letterStack.peek() && countStack.peek() >= 3) {
                letterStack.pop();
                countStack.pop();
            }
            if (letterStack.isEmpty() || c != letterStack.peek()) {
                letterStack.push(c);
                countStack.push(1);
            } else {
                countStack.push(countStack.pop() + 1);
            }
        }
        if (!countStack.isEmpty() && countStack.peek() >= 3) {
            letterStack.pop();
            countStack.pop();
        }
        while (!letterStack.isEmpty()) {
            char letter = letterStack.pop();
            int count = countStack.pop();
            for (int i = 0; i < count; ++i) {
                sb.append(letter);
            }
        }
        sb.reverse();
        return sb.toString();
    }
}

class State {
    String board;
    String hand;
    int step;

    public State(String board, String hand, int step) {
        this.board = board;
        this.hand = hand;
        this.step = step;
    }
}
```
$$
\begin{align}
&时间复杂度:O(m×n×A^n_{m+n})\\
&空间复杂度:O((m+n)×A^m_{m+n})
\end{align}
$$

