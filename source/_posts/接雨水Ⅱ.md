---
title: 二维 接雨水
categories:
- 算法
- 优先队列
mathjax: true
tags:
- 算法
---

### 二维 接雨水（ 最小堆 | 广度优先搜索 ）

<!--more-->

> > 给你一个 `m x n` 的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。
> >
> > ```
> > 输入: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]
> > 输出: 4
> > ```
> > 题目详情参见: <a>[407. 接雨水 II - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/trapping-rain-water-ii/)</a>

### 解法一：模拟遍历（参照接雨水Ⅰ）

思路：一维转化为二维，那么是否可以同样的思路去解答？

1. 对于每个点，寻找所在行左右最大值的最小值，寻找所在列上下最大值的最小值；
2. 然后取这两个值的最小值，减去当前位置的高度，即为此位置接雨水量。

代码如下：

```java
class Solution {
    public int trapRainWater(int[][] heightMap) {
        int row = heightMap.length;
        int col = heightMap[0].length;

        int ans = 0;

        for(int i = 1; i < row - 1; i++) {
            for(int j = 1; j < col - 1; j++) {
                int curr = heightMap[i][j];

                int minRow = getMinRow(heightMap,i,j,col);
                int minCol = getMinCol(heightMap,i,j,row);

                // 如果均大于当前位置，那么可以接雨水
                if(minCol > curr && minRow > curr) {
                    ans += Math.min(minRow,minCol);
                    ans -= heightMap[i][j];
                } 
            }
        }

        return ans;
    }

    // 寻找所在行的左右最大值的最小值
    private int getMinRow(int[][] heightMap,int x,int y,int col) {
        int leftMax = heightMap[x][0];
        int rightMax = heightMap[x][col - 1];
        for(int k = 0; k < y; k++) {
            leftMax = Math.max(leftMax,heightMap[x][k]);
        }
        for(int k = y; k < col; k++) {
            rightMax = Math.max(rightMax,heightMap[x][k]);
        }
        return Math.min(leftMax,rightMax);
    }

    // 寻找所在列的上下最大值的最小值
    private int getMinCol(int[][] heightMap,int x,int y,int row) {
        int upMax = heightMap[0][y];
        int downMax = heightMap[row - 1][y];
        for(int k = 0; k < x; k++) {
            upMax = Math.max(upMax,heightMap[k][y]);
        }
        for(int k = x; k < row; k++) {
             downMax = Math.max(downMax,heightMap[k][y]);
        }
        return Math.min(upMax,downMax);
    }
}
```

<p>但是这个思路解答是错误的，因为当前位置可能会溢出流向其他区域！</p>

比如：`[[12,13,1,12],[13,4,13,12],[13,8,10,12],[12,13,12,12],[13,13,13,13]]`

按照上述做法的答案`15`，正确答案`14`。

**因此该方块自身的高度比其上下左右四个相邻的方块接水后的高度都要低。**

----

### 解法二：最小堆

思路：反思解法一的过程，思考总结什么样的方块能接水?

```java
- 该方块不为最外层的方块；
- 该方块自身的高度比其上下左右四个相邻的方块接水后的高度都要低；
```

1. 假设方块的索引为 <em>(i,j)</em>，方块的高度为 <em>heightMap[i]\[j]</em>，方块接水后的高度为 <em>water[i]\[j]</em>；

2. 并且 <em>water[i]\[j] = max(heightMap[i]\[j], min(water[i−1]\[j], water[i+1]\[j], water[i]\[j−1], water[i]\[j+1]))</em>；

3. 因此方块 <em>(i,j)</em> 实际接水的容量计算公式为 <em>water[i]\[j] − heightMap[i]\[j]</em>;

4. 因为最外层的方块无法接水，因此最外层的方块 <em>water[i]\[j] = heightMap[i]\[j]</em>;

5. 根据木桶原理，接到的雨水的高度由这个容器周围最短的木板来确定的,

   <p>因此容器内水的高度取决于最外层高度最低的方块；</p>

6. 确定最小高度方块的相邻方块的接水高度，我们同时更新最外层的方块标记，

   在新的最外层的方块再次找到接水后的高度的最小值，同时确定与其相邻的方块的接水高度；

7. 依次迭代求出所有方块的接水，即可得解。

```java
class Solution {
    public int trapRainWater(int[][] heightMap) {
        // 方块数小于4，无法接水
        if (heightMap.length <= 2 || heightMap[0].length <= 2) {
            return 0;
        }
        int m = heightMap.length;
        int n = heightMap[0].length;
        // 访问过的结点
        boolean[][] visit = new boolean[m][n];
        PriorityQueue<int[]> pq = new PriorityQueue<>((o1, o2) -> o1[1] - o2[1]);

        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (i == 0 || i == m - 1 || j == 0 || j == n - 1) {
                    // i * n + j代表第几个
                    pq.offer(new int[]{i * n + j, heightMap[i][j]});
                    visit[i][j] = true;
                }
            }
        }
        int res = 0;
        int[] dirs = {-1, 0, 1, 0, -1};
        while (!pq.isEmpty()) {
            int[] curr = pq.poll();
            for (int k = 0; k < 4; ++k) {
                // 第几个取位置，/n是行数，%n是列数
                int nx = curr[0] / n + dirs[k];
                int ny = curr[0] % n + dirs[k + 1];
                // 不越界并且没有被访问过
                if (nx >= 0 && nx < m && ny >= 0 && ny < n && !visit[nx][ny]) {
                    if (curr[1] > heightMap[nx][ny]) {
                        res += curr[1] - heightMap[nx][ny];
                    }
                    // 更新边界
                    pq.offer(new int[]{nx * n + ny, Math.max(heightMap[nx][ny], curr[1])});
                    // 将访问过的位置设置为true
                    visit[nx][ny] = true;
                }
            }
        }
        return res;
    }
}
```

$$
\begin{align}
&时间复杂度:O(MNlog(M+N))\\
&空间复杂度:O(MN)
\end{align}
$$

-----

### 解法三：广度优先搜索

思路:	让区域都接满水，因此此时每一块的高度都是 `maxHeight`，为区域中最高值，

​			 然后让其顺着低处自然流出，因此需要广度优先搜索；

1. 假设初始时矩阵的每个格子都接满了水，且高度均为 *maxHeight*，区域中的最高值；

2. 同解法二：<em>water[i]\[j] = max(heightMap[i]\[j], min(water[i−1]\[j], water[i+1]\[j], water[i]\[j−1], water[i]\[j+1]))</em>；

3. 方块 <em>(i,j)</em> 实际接水的容量计算公式为 <em>water[i]\[j] − heightMap[i]\[j]</em>;

4. 每次发现当前方块 *(i,j)* 的接水高度 <em>water[i]\[j]</em> 小于与它相邻的 4 个模块的接水高度时，

   则我们将进行调整接水高度，将其相邻的四个方块的接水高度调整与 (*i*,*j*) 的高度保持一致；

5. 不断重复的进行调整，直到所有的方块的接水高度不再有调整时即为满足要求。

代码如下：

```java
class Solution {
    public int trapRainWater(int[][] heightMap) {
        int m = heightMap.length;
        int n = heightMap[0].length;
        int[] dirs = {-1, 0, 1, 0, -1};
        int maxHeight = 0;
        
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                maxHeight = Math.max(maxHeight, heightMap[i][j]);
            }
        }
        int[][] water = new int[m][n];
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j){
                water[i][j] = maxHeight;      
            }
        }  
        Queue<int[]> qu = new LinkedList<>();
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (i == 0 || i == m - 1 || j == 0 || j == n - 1) {
                    if (water[i][j] > heightMap[i][j]) {
                        water[i][j] = heightMap[i][j];
                        qu.offer(new int[]{i, j});
                    }
                }
            }
        } 
        while (!qu.isEmpty()) {
            int[] curr = qu.poll();
            int x = curr[0];
            int y = curr[1];
            for (int i = 0; i < 4; ++i) {
                int nx = x + dirs[i], ny = y + dirs[i + 1];
                if (nx < 0 || nx >= m || ny < 0 || ny >= n) {
                    continue;
                }
                if (water[x][y] < water[nx][ny] && water[nx][ny] > heightMap[nx][ny]) {
                    water[nx][ny] = Math.max(water[x][y], heightMap[nx][ny]);
                    qu.offer(new int[]{nx, ny});
                }
            }
        }

        int res = 0;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                res += water[i][j] - heightMap[i][j];
            }
        }
        return res;
    }
}
```

$$
\begin{align}
&时间复杂度:O(M^2N^2)\\
&空间复杂度:O(MN)
\end{align}
$$

---

### 广度优先搜索模板

````java
// 搜索过程中的累计最大值
private int maxValue = 0;
// 搜索过程中的标记值
private int value = 1;

public int maxAreaOfIsland(int[][] matrix) {
    Queue<int[]> queue = new LinkedList<>();
    for (int i = 0; i < matrix.length; i++) {
        for (int j = 0; j < matrix[0].length; j++) {
            // 如果满足 则入队 同时改值
            if (matrix[i][j] == value) {
                matrix[i][j] = -1;
                queue.offer(new int[]{i, j});
                bfs(queue, matrix);
            }
        }
    }
    return this.maxValue;
}

private void bfs(Queue<int[]> queue, int[][] matrix) {
    int count = 1;
    // 方向数组
    int[][] dirs = {{0, -1}, {0, 1}, {1, 0}, {-1, 0}};
    while (!queue.isEmpty()) {
        int[] index = queue.poll();
        for (int[] dir : dirs) {
            int x = index[0] + dir[0];
            int y = index[1] + dir[1];
            // 不超出边界
            if (x >= 0 && x < matrix.length && y >= 0 && y < matrix[0].length) {
                // 如果符合要求
                if (matrix[x][y] == value) {
                    count++;
                    matrix[x][y] = -1;
                    queue.offer(new int[]{x, y});
                }
            }
        }
    }
    this.maxValue = Math.max(count, this.maxValue);
}
````

