---
title: 一维 接雨水
categories:
- 算法
- 动态规划
mathjax: true
tags:
- 算法
---

### 一维 接雨水（ 模拟 | 动态规划 | 双指针 | 单调栈 ）

<!--more-->

> > 给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
> >
> > 示例：输入 `height = [0,1,0,2,1,0,1,3,2,1,2,1]` ，输出 `6`
> >
> > 题目详情参见 <a>[42. 接雨水 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/trapping-rain-water/)</a>

### 解法一：模拟遍历

思路：

1. 不妨设数组的长度为 `n` ，那么从下标 `1` 到 `n - 1` 进行遍历；
2. 对于每个下标 `i` ，分别向左向右搜索最大值，然后取二者的最小值；
3. 将此最小值减去 `height[i]`，即为此下标所能接的雨水数；
4. 遍历求和，即可得到正确的解答。

代码如下：

```java
public int trap(int[] height) {
    int ans = 0;
    int size = height.length;
    for (int i = 1; i < size - 1; i++) {
        int max_left = 0, max_right = 0;
        for (int j = i; j >= 0; j--) { // 寻找左部最大值
            max_left = Math.max(max_left, height[j]);
        }
        for (int j = i; j < size; j++) { // 寻找右部最大值
            max_right = Math.max(max_right, height[j]);
        }
        ans += Math.min(max_left, max_right) - height[i];
    }
    return ans;
}
```

$$
\begin{align}
&时间复杂度: O(n^2)\\
&空间复杂度: O(1)
\end{align}
$$

---

### 解法二：动态规划

思路：在解法一（模拟遍历）的时候，每次都需要向左向右进行搜寻，不妨简化这个搜寻过程，从而降低时间复杂度。

1. 开辟两个数组 *leftMax、rightMax*，分别记录左边的最大值和右边的最大值；
2. 因为两个数组记录的值意义不同，所以进行不同的遍历，得到两个数组的值；
3. **正向遍历得到 *leftMax*, 反向遍历得到 *rightMax* ;**
4. 然后从下标 `1` 到 `n - 1` 进行遍历求解。

代码如下：

```java
class Solution {
    public int trap(int[] height) {
        int n = height.length;
        if (n == 0) {
            return 0;
        }

        // 正向遍历得到左边最大值
        int[] leftMax = new int[n];
        leftMax[0] = height[0];
        for (int i = 1; i < n; ++i) {
            leftMax[i] = Math.max(leftMax[i - 1], height[i]);
        }

        // 反向遍历得到右边最大值
        int[] rightMax = new int[n];
        rightMax[n - 1] = height[n - 1];
        for (int i = n - 2; i >= 0; --i) {
            rightMax[i] = Math.max(rightMax[i + 1], height[i]);
        }

        // 求和得解
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            ans += Math.min(leftMax[i], rightMax[i]) - height[i];
        }
        return ans;
    }
}
```

$$
\begin{align}
&时间复杂度: O(n)\\
&空间复杂度: O(n)
\end{align}
$$

---

### 解法三：双指针

思路：解法二（动态规划）优化了模拟遍历，但是额外了开辟了空间，那么如何减少空间开辟？

1. **使用双指针和两个变量代替正反遍历得到的两个数组；**

2. 双指针 *left、right*, 两个变量 *leftMax，rightMax*;

3. 当两个指针在移动的过程中，进行以下操作：

   1. 使用 *height[left]，height[right]* 更新 *leftMax，rightMax* 的值；

   2. 如果 *height[left] < height[right]*, 那么一定有 *leftMax < rightMax*，

      下标 *left* 处的接水量就等于 <em>leftMax - height[left]</em>，然后 *left* 右移一位；

      [（原因解释）](#1)

   3. 如果 *height[left] ≥ height[right]*, 那么一定有 *leftMax ≥ rightMax*，

      下标 *right* 处的接水量就等于 <em>rightMax - height[right]</em>，然后 *right* 左移一位；

4. 当两个指针相遇时，即可得到接雨水的总量。

**<a id=1>为什么"一定有"的解释说明：</a>**

> 左指针右移的终止条件是找到比 <em>rightMax</em> 大的 <em>leftMax</em>，
>
> 也就是说一旦左指针终止左移，此时的<em>height[left]</em> 一定是 <em>leftMax</em>，且大于 <em>rightMax</em>。
>
> 同理，右指针左移的终止条件是找到比 <em>leftMax</em> 大的 <em>rightMax</em>，
>
> 而此时的 <em>height[right]</em> 就是 <em>rightMax</em>。
>
> 所以这里 <em>height[left] < height[right]</em> 中的 <em>height[right]</em> 就是当前的 <em>rightMax</em>，
>
> 而 <em>height[left] < height[right]</em> 意味着还没找到大于 <em>rightMax 的 leftMax</em>，
>
> 所以 <em>leftMax < rightMax</em>

<p>如果 <em>height[left] < height[right]</em>, 那么一定有 <em>leftMax < rightMax</em>，是一个充要条件,</p>

**因此将此判断条件改为：如果 *leftMax < rightMax*, 依然正确，**可看代码部分注释。

代码如下：

```java
class Solution {
    public int trap(int[] height) {
        int ans = 0;
        int left = 0, right = height.length - 1;
        int leftMax = 0, rightMax = 0;
        while (left < right) {
            leftMax = Math.max(leftMax, height[left]);
            rightMax = Math.max(rightMax, height[right]);
            // if(leftMax < rightMax) 依然正确
            if (height[left] < height[right]) {
                ans += leftMax - height[left];
                ++left;
            } else {
                ans += rightMax - height[right];
                --right;
            }
        }
        return ans;
    }
}
```

$$
\begin{align}
&时间复杂度: O(n)\\
&空间复杂度: O(1)
\end{align}
$$

---

### 解法四：单调栈

思路：上面几种做法都可以理解成**垂直处理**，单调栈的方式为**水平处理**。

1. 维护一个单调栈存储数组下标，满足从栈底到栈顶的下标对应的数组 *height* 中的元素**非严格递减**；
2. 从左到右遍历数组，遍历到下标 *i* 时，如果栈内至少有两个元素，记栈顶元素为 *top*，*top* 的下面一个元素是 *left*；
3. 则一定有 <em>height[left] ≥ height[top]</em>，如果 <em>height[i] > height[top]</em>，则得到一个接雨水的区域；
4. 该区域的宽度是 *i−left−1*，高度是 <em>min( height[left] , height[i] ) − height[top]</em>，根据宽度和高度即可计算得到该区域能接的雨水量；
5. 为了得到  *left*，需要将 *top* 出栈。在对 *top* 计算能接的雨水量之后，*left* 变成新的 *top*；
6. 重复上述操作，直到栈变为空，或者栈顶下标对应的 *height* 中的元素大于或等于 <em>height[i]</em>；
7. 遍历结束之后即可得到能接的雨水总量。

代码如下：

```java
class Solution {
    public int trap(int[] height) {
        int ans = 0;
        Deque<Integer> stack = new LinkedList<Integer>();
        int n = height.length;
        for (int i = 0; i < n; ++i) {
            while (!stack.isEmpty() && height[i] > height[stack.peek()]) {
                int top = stack.pop();
                if (stack.isEmpty()) {
                    break;
                }
                int left = stack.peek();
                int currWidth = i - left - 1;
                int currHeight = Math.min(height[left], height[i]) - height[top];
                ans += currWidth * currHeight;
            }
            stack.push(i);
        }
        return ans;
    }
}
```

$$
\begin{align}
&时间复杂度: O(n)\\
&空间复杂度: O(n)
\end{align}
$$

------

### **补充说明：为什么使用 Deque 而不是 Stack ？**

1. `Deque` 是 `double ended queue` 的简称，习惯上称之为**双端队列**

2. 由于`Vector`因效率问题已经被弃用，因此继承`Vector`的`Stack`也存在效率问题，故不推荐。

详情可参考文章：

<a>深入理解Java集合之---Deque - 简书 (jianshu.com)](https://www.jianshu.com/p/d78a7c982edb)</a>

<a>[为什么使用Deque而不使用Stack构造栈 - codeduck - 博客园 (cnblogs.com)](https://www.cnblogs.com/code-duck/p/13569388.html)</a>

