---
title: 吃苹果的最大数目
categories:
- 算法
- 贪心
tags:
- 算法
mathjax: true
---

### 吃苹果的最大数目（ 贪心 | 优先队列 ）

<!--more-->

> 题目详情参考：[1705. 吃苹果的最大数目 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/maximum-number-of-eaten-apples/)

思路：每天只能吃一个苹果，最大数量一定是每次吃最先腐烂的，因此贪心算法，

除此之外，如何保证苹果顺序，采用优先队列结构，解决问题。

1. **使用贪心策略，在尚未腐烂的苹果中优先选择腐烂日期最早的苹果；**

2. 计算吃苹果的最大数目分成两个阶段：

   第一阶段是第 0 天到第 n−1 天，即天数在数组下标范围内，

   第二阶段是第 n 天及以后，即天数在数组下标范围外；

3. 每天取出一个，直到数目为 0 或者已经腐烂；

**需要注意的地方：**

1. **特殊的例子：**

   ```html
   输入：apples = [1,0,0,0,0], days = [0,0,0,0,0]
   输入：apples = [1,0,0,0,0], days = [1,0,0,0,0]
   输出：apples = [2,0,0,0,0], days = [1,0,0,0,0]
   ```

   即当天如果有苹果，但是当天就会腐烂，那么会优先吃掉。

2. **两个阶段既可以分开考虑，也可以合并考虑：**

   分开考虑：第二阶段不需要累加，而是叠加，降低时间复杂度；

   合并考虑：第二阶段思路不变，但是会增加时间复杂度；

3. **优先队列添加和取元素操作的时间复杂度是O( logn )；**

4. **在处理队首元素时，由于数组是引用型，所以原地修改 peek 元素即可；**

### 分阶段考虑：

代码如下：

```java
class Solution {
    public int eatenApples(int[] apples, int[] days) {
        int ans = 0;
        int currDay = 0;
        PriorityQueue<int[]> pq = new PriorityQueue<>((o1, o2) -> o1[1] - o2[1]);
        while (currDay < days.length) {
            while (!pq.isEmpty() && pq.peek()[1] <= currDay) {
                pq.poll();
            }
            int count = apples[currDay];
            int rottenDay = days[currDay] + currDay;
            if (count > 0) {
                pq.offer(new int[]{count, rottenDay});
            }
            if (!pq.isEmpty()) {
                int[] arr = pq.peek();
                arr[0]--;
                if (arr[0] == 0) {
                    pq.poll();
                }
                ans++;
            }
            currDay++;
        }
        while (!pq.isEmpty()) {
            while (!pq.isEmpty() && pq.peek()[1] <= currDay) {
                pq.poll();
            }
            if (pq.isEmpty()) {
                break;
            }
            int[] arr = pq.poll();
            int curr = Math.min(arr[1] - currDay, arr[0]);
            ans += curr;
            currDay += curr;
        }
        return ans;
    }
}
```

### 合并处理

代码如下：

```java
class Solution {
    public int eatenApples(int[] apples, int[] days) {
        int ans = 0;
        int currDay = 0;
        PriorityQueue<int[]> pq = new PriorityQueue<>((o1, o2) -> o1[1] - o2[1]);
        while (currDay < days.length || !pq.isEmpty()) {
            while (!pq.isEmpty() && pq.peek()[1] <= currDay) {
                pq.poll();
            }
            if(currDay < days.length) {
                int count = apples[currDay];
                int rottenDay = days[currDay] + currDay;
                if (count > 0) {
                    pq.offer(new int[]{count, rottenDay});
                }
            }
            if (!pq.isEmpty()) {
                int[] arr = pq.peek();
                arr[0]--;
                if (arr[0] == 0) {
                    pq.poll();
                }
                ans++;
            }
            currDay++;
        }
        return ans;
    }
}
```

$$
\begin{align}
&时间复杂度:O(nlogn)
&空间复杂度:O(n)
\end{align}
$$

