---
title: 访问完所有房间的第一天
categories:
- 算法
- 动态规划
tags:
- 算法
mathjax: true
---

### 访问完所有房间的第一天（动态规划）

<!--more-->

> >题目详情参考：[1997. 访问完所有房间的第一天 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/first-day-where-you-have-been-in-all-the-rooms/)

**在解题前，需要确定两个非常重要的信息条件：**

1. 第一个位置的元素必须是 `0`
2. 任意位置的元素不可以大于当前位置，即：`0 ≤ nextVisit[i] ≤ i`

那么可以从题意得到一个非常重要的信息：

**如果第一次到达位置 `x` ,那么在其之前的所有位置，访问次数必定是偶数**

成立的前提如下分析：

1. 因为第二个条件可以得出，不可能跳转位置，即必须累加
2. 那么想要到达 `x`，必须从 `x-1` 位置前进一位到达
3. 以此类推，前面的所有位置都必须为偶数

那么由上述条件，又可以得知一个重要推论：

**从某一位置到达 `x` 所需要的天数，即为二者之差**

不妨设数组 `dp`，`dp[i]` 表示第一次到达当前位置所需的天数

**那么从 `y` 到 `x` 所需天数即为：`dp[x] - dp[y]`**

进一步地，可以得到动态规划转移方程：
$$
\begin{align}
&dp[i]=(dp[i-1] + 1) + (dp[i-1] - dp[nextVisit[i-1]] + 1) \\\\
&dp[i]=2×dp[i-1]-dp[nextVisit[i-1]] + 2
\end{align}
$$
上述动态方程的证明如下：

1. 从 `i-1` 的位置到 `i` 需要加一天
2. 但是第一次到达 `i-1` 的位置时，还会跳转到其所存储的位置
3. 因此需要额外加上跳转位置重新到达 `i-1` 所需天数
4. **额外加上的天数，实际上就是从跳转位置到 `i-1` 的路径重走一遍**

代码如下：

````java
class Solution {
    public int firstDayBeenInAllRooms(int[] nextVisit) {
        int MOD = 1000000007;
        long[] dp = new long[nextVisit.length];
        for(int i = 1; i < nextVisit.length; i++) {
            dp[i] = (2 * dp[i - 1] - dp[nextVisit[i - 1]] + 2) % MOD;
        }
        return (int)((dp[dp.length - 1] + MOD) % MOD);
    }
}
````

**除此之外，需要注意：为什么最后需要 + MOD ？**

并不是仅仅因为溢出的问题，因为已经将数组声明为 `long`，

实际上是因为在减法过程中，由于不断地 mod 导致后面的值不一定大于前面的值，

造成会出现负数的情况，所以需要 + MOD 重新取余的额外步骤
