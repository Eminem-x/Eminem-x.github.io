---
title: 字符串的加乘
categories:
- 算法
- 数学
tags:
- 算法
mathjax: true
---

### 字符串的加乘

<!--more-->

### 加一

>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。
>
>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
>
>你可以假设除了整数 0 之外，这个整数不会以零开头。
>
>```html
>输入：digits = [4,3,2,1]
>输出：[4,3,2,2]
>```
>
>题目详情参考：[66. 加一 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/plus-one/)

1. 从末尾开始加一即可，如果不产生进位，返回结果，否则向前加一；
2. 如果直到最高位仍未结束，那么说明该数为 `9...9` ，所以单独处理。

代码如下：

````java
class Solution {
    public int[] plusOne(int[] digits) {
        for (int i = digits.length - 1; i >= 0; i--) {
            digits[i]++;
            if (digits[i] == 10) {
                digits[i] = 0;
            } else {
                return digits;
            }
        }
        int[] ans = new int[digits.length + 1];
        ans[0] = 1;
        return ans;
    }
}
````

$$
\begin{align}
&时间复杂度:O(n)
&空间复杂度:O(1)
\end{align}
$$

-----

### 字符串的相加

> >给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。
> >
> >你不能使用任何內建的用于处理大整数的库（比如 BigInteger），
> >
> >也不能直接将输入的字符串转换为整数形式。
> >
> >```html
> >输入：num1 = "456", num2 = "77"
> >输出："533"
> >```
> >
> >题目详情参考：[415. 字符串相加 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/add-strings/)

1. 模拟**竖式相加**的过程即可，需要注意位数不同和进位的情况；
2. 等价于**对位数较短的数字进行了补零操作**。

代码如下：

```java
class Solution {
    public String addStrings(String num1, String num2) {
        int i = num1.length() - 1, j = num2.length() - 1, add = 0;
        StringBuffer ans = new StringBuffer();
        while (i >= 0 || j >= 0 || add != 0) {
            int x = i >= 0 ? num1.charAt(i) - '0' : 0;
            int y = j >= 0 ? num2.charAt(j) - '0' : 0;
            int result = x + y + add;
            ans.append(result % 10);
            add = result / 10;
            i--;
            j--;
        }
        // 计算完以后的答案需要翻转过来
        ans.reverse();
        return ans.toString();
    }
}
```

$$
\begin{align}
&时间复杂度:O(n)
&空间复杂度:O(1)
\end{align}
$$

----

### 字符串的相乘

> > 给定两个以字符串形式表示的非负整数 `num1` 和 `num2`，
> >
> > 返回 `num1` 和 `num2` 的乘积，它们的乘积也表示为字符串形式。
> >
> > ```html
> > 输入: num1 = "123", num2 = "456"
> > 输出: "56088"
> > ```
> >
> > 题目详情参考：[43. 字符串相乘 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/multiply-strings/)

#### 解法一：做加法

1. `num2` 从最低位依次去相乘 `num1` ，而后将每次的结果累加；
2. **用位相乘时，需要注意补 0**，可以参考日常的乘法竖式计算；
3. 结果的累加，参考**字符串的相加**。

代码如下：

```java
class Solution {
    public String multiply(String num1, String num2) {
        if (num1.equals("0") || num2.equals("0")) {
            return "0";
        }
        String ans = "0";
        int m = num1.length(), n = num2.length();
        for (int i = n - 1; i >= 0; i--) {
            // num2某一位与num1相乘
            StringBuffer curr = new StringBuffer();
            int add = 0;
            // 列式乘法时 末尾补0
            for (int j = n - 1; j > i; j--) {
                curr.append(0);
            }
            // 模拟乘法过程
            int y = num2.charAt(i) - '0';
            for (int j = m - 1; j >= 0; j--) {
                int x = num1.charAt(j) - '0';
                int product = x * y + add;
                curr.append(product % 10);
                add = product / 10;
            }
            if (add != 0) {
                curr.append(add % 10);
            }
            // 累加
            ans = addStrings(ans, curr.reverse().toString());
        }
        return ans;
    }

    public String addStrings(String num1, String num2) {
        int i = num1.length() - 1, j = num2.length() - 1, add = 0;
        StringBuffer ans = new StringBuffer();
        while (i >= 0 || j >= 0 || add != 0) {
            int x = i >= 0 ? num1.charAt(i) - '0' : 0;
            int y = j >= 0 ? num2.charAt(j) - '0' : 0;
            int result = x + y + add;
            ans.append(result % 10);
            add = result / 10;
            i--;
            j--;
        }
        ans.reverse();
        return ans.toString();
    }
}
```

$$
\begin{align}
&时间复杂度:O((m + n)×n)
&空间复杂度:O(m + n)
\end{align}
$$

---

#### 解法二：做乘法

1. 方法一的做法是从右往左遍历乘数，将乘数的每一位与被乘数相乘得到对应的结果，
2. 再将每次得到的结果累加，整个过程中涉及到较多字符串相加的操作。
3. 如果使用数组代替字符串存储结果，则可以减少对字符串的操作。
4. `num1` 和 `num2` 的乘积的最大长度为 `m+n`，故创建长度为 `m+n` 的数组 `ansArr` 用于存储乘积；
5. 具体计算过程中，先算每一位的累计值，最后在数组上进行进位化简操作。

代码如下：

```java
class Solution {
    public String multiply(String num1, String num2) {
        if (num1.equals("0") || num2.equals("0")) {
            return "0";
        }
        int m = num1.length(), n = num2.length();
        int[] ansArr = new int[m + n];
        for (int i = m - 1; i >= 0; i--) {
            int x = num1.charAt(i) - '0';
            for (int j = n - 1; j >= 0; j--) {
                int y = num2.charAt(j) - '0';
                ansArr[i + j + 1] += x * y;
            }
        }
        for (int i = m + n - 1; i > 0; i--) {
            ansArr[i - 1] += ansArr[i] / 10;
            ansArr[i] %= 10;
        }
        int index = ansArr[0] == 0 ? 1 : 0;
        StringBuffer ans = new StringBuffer();
        while (index < m + n) {
            ans.append(ansArr[index]);
            index++;
        }
        return ans.toString();
    }
}
```
$$
\begin{align}
&时间复杂度:O(mn)
&空间复杂度:O(m + n)
\end{align}
$$

-----

### 一个区间内所有数乘积的缩写

> 题目详情参考：[2117. 一个区间内所有数乘积的缩写 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/abbreviating-the-product-of-a-range/)

**说明：题目在最开始周赛测试时存在标程问题，但是后来官方降低了数的长度。**

1. 不能使用字符串相乘的方法去处理，会超出时间复杂度；

代码如下：

```java
/**
* 代码来自68场双周赛第一名
*/
class Solution {
	public String abbreviateProduct(int left, int right) {
		long two = 0, five = 0, min = 0, flag = 0, last = 1;
		for (int i = left, j; (j = i) <= right; i++) {
			for (; j % 2 == 0; j /= 2, two++) {}
			for (; j % 5 == 0; j /= 5, five++) {}
		}
		two = five = min = Math.min(two, five);
		double first = 1;
		for (int i = left; i <= right; i++) {
			for (last *= i; last % 2 == 0 && two-- > 0; last /= 2) {}
			for (; last % 5 == 0 && five-- > 0; last /= 5) {}
			if (last > 10000000000L) {
				flag = 1;
				last %= 10000000000L;
			}
			for (first *= i; first > 100000; first /= 10) {}
		}
		return (flag == 0 ? last : (int) first + "..." + String.format("%05d", last % 100000)) + "e" + min;
	}
}
```

