---
title: 移动零
categories:
- 算法
- 双指针
tags:
- 算法
mathjax: true
---

### 移动零（ 双指针 ）

<!--more-->

> > 给定数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。
> >
> > ```html
> > 输入: [0,1,0,3,12]
> > 输出: [1,3,12,0,0]
> > ```

### 解法一：模拟遍历

思路：遍历数组，每次遇到 `0` ，将此位置后的所有元素前移，然后数组末尾补 `0` ；

细节：特殊情况 `0 0 1 0 3 2` → `0 1 0 3 2 0`，此时下标已经向前移动了，会越过 `0` 。

1. 每次移动数组后，向后遍历，如果全为 `0` 则退出；
2. 如果不全为 `0`，并且此时 `i` 下标的元素为 `0`，那么回退一步；
3. 上面都不满足，继续遍历，不需要更改循环。

代码如下:

```java
class Solution {
    public void moveZeroes(int[] nums) {
        for(int i = 0; i < nums.length; i++) {
            // 遇到 0,位置后的所有元素前移，末尾补 0 
            if(nums[i] == 0) {
                for(int j = i; j < nums.length - 1; j++) {
                    nums[j] = nums[j + 1];
                }
                nums[nums.length - 1] = 0;
            }
            // 防止出现移动后,少处理0的情况
            for(int j = i + 1; j < nums.length; j++) {
                if(nums[j] != 0) {
                    if(nums[i] == 0) {
                        i--;
                    }
                    break;
                }
                // 如果全是0,则结束
                if(j == nums.length - 1) {
                    return;
                }
            }
        }
    }
}
```

$$
\begin{align}
&时间复杂度:O(n^2)
&空间复杂度:O(n)
\end{align}
$$

-----

### 解法二：双指针

思路：使用双指针，**左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。**

1. 右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。

2. 注意到以下性质：

   1. 左指针左边均为非零数；

   2. 右指针左边直到左指针处均为零。

3. 因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。

**难点说明：**

1. 如果当前左右指针相等，那么二者同时移动，即均加一；
2. 当遇到 `0` 时，快指针继续向前寻找非零元素，慢指针则停留在 `0` 处等待； 

代码如下：

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int slow = 0;
        int fast = 0;
        while(fast < nums.length) {
            if(nums[fast] != 0) {
                int temp = nums[slow];
                nums[slow++] = nums[fast];
                nums[fast++] = temp;
            } else {
                fast++;
            }
        }
    }
}
```

$$
\begin{align}
&时间复杂度:O(n)
&空间复杂度:O(1)
\end{align}
$$



