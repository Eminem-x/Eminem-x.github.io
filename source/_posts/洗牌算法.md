---
title: 洗牌算法
categories: 
- 算法
- 数学
mathjax: true
tags:
- 算法
---
### 洗牌算法( 模拟洗牌 | Fisher-Yates算法 )

<!--more-->

> > 设计算法打乱一个没有重复元素的给定整数数组 nums
### 解法一：模拟洗牌
思路：首先不妨设数组 *nums* 的长度为 *n*，
1. 不妨用数据结构 *waiting* 来存放 *nums* 中的所有元素，并初始化打乱后的数组 *shuffled*
2. 从数组 *shuttle* 的 *0* 下标开始，每次从 *waiting* 中随机选取一个数据放置到 *shuffled*，并且从 *waiting* 中移除该数据

*（整体来说：模拟洗牌，每次的选择概率均相等，可以理解成抽签模拟）*

代码如下：

```java
public int[] shuffle() {
	int[] shuffled = new int[nums.length];
    List<Integer> list = new ArrayList<Integer>();
    for (int i = 0; i < nums.length; ++i) {
        list.add(nums[i]);
    }
    Random random = new Random();
    for (int i = 0; i < nums.length; ++i) {
        int j = random.nextInt(list.size());
        shuffled[i] = list.remove(j);
    }
    System.arraycopy(shuffled, 0, nums, 0, nums.length);
    return nums;
}
```

$$
\begin{align}
&时间复杂度：O(n^2)
&空间复杂度：O(n)
\end{align}
$$
---

### 解法二：Fisher-Yates洗牌算法

首先需要理解为什么上面介绍的模拟洗牌算法的时间复杂度为 O(n<sup>2</sup>)，

`list.remove(int index)的时间复杂度是O(n - index)`, 因此改进算法：

1. 如果每次的 *index* 是最后一位，那么时间复杂度就降为 O(1)；
2. 那么在放入 *shuffled* 之前, 先将 当前的 index 和 最后一位进行交换；
3. 将最后一位移除的同时放入 *shuffled* 的指定位置即可。



那么在此基础上，我们可以再进行改进，实现**数组的原地乱序**

1. 不再使用数据结构 *waiting*，仅在原数组上操作；
2. **不再从数组中移除元素，每次将第 *k* 个元素与第 *1* 个元素交换** 

代码如下：

```java
public int[] shuffle() {
	Random random = new Random();
    for (int i = 0; i < nums.length; ++i) {
        int j = i + random.nextInt(nums.length - i);
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
    return nums;
}
```

$$
\begin{align}
&时间复杂度：O(n)
&空间复杂度：O(n)
\end{align}
$$



