---
title: 回溯经典题目
categories:
- 算法
- 回溯
tags:
- 算法
mathjax: true
---

### 回溯

<!--more-->

#### Preface

回溯解法很好理解，我个人觉得是对解空间的一种遍历，但是会进行一些判断，

当不满足相应条件时，返回上一状态，向其他状态重复上述状态，直至得解，

但是回溯和 BFS 其实并不一样，起初我对二者有些混淆，

后来经过练习和理解，也逐渐了解二者的区别，这篇文章主要列出以下问题，

* <a href="https://leetcode-cn.com/problems/subsets/">子集Ⅰ</a>
* <a href="https://leetcode-cn.com/problems/subsets-ii/">子集Ⅱ</a>
* <a href="https://leetcode-cn.com/problems/combinations/">组合</a>
* <a href="https://leetcode-cn.com/problems/permutations/">全排列</a>

以上问题均来源于 LeetCode

----

### 思路

上面四个问题都可以用回溯去解决，不同的地方在于回溯的终止条件，

以组合为例，只需要当前存储数值达到要求即可返回，

而对于排列，不需要判断当前包含的数目，只需要判断是否达到末尾即可。

当然，还有一些细节，代码如下：

**全排列**

```java
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();

        List<Integer> output = new ArrayList<Integer>();
        for (int num : nums) {
            output.add(num);
        }

        int n = nums.length;
        backtrack(n, output, res, 0);
        return res;
    }

    public void backtrack(int n, List<Integer> output, List<List<Integer>> res, int first) {
        // 所有数都填完了
        if (first == n) {
            res.add(new ArrayList<Integer>(output));
        }
        for (int i = first; i < n; i++) {
            // 动态维护数组
            Collections.swap(output, first, i);
            // 继续递归填下一个数
            backtrack(n, output, res, first + 1);
            // 撤销操作
            Collections.swap(output, first, i);
        }
    }
}
```

**组合**

```java
class Solution {
    private List<List<Integer>> ans = new ArrayList<>();
    private List<Integer> temp = new ArrayList<>();

    public List<List<Integer>> combine(int n, int k) {
        dfs(1, n, k);
        return ans;
    }

    private void dfs(int curr, int n, int k) {
        // short
        if (temp.size() + n - curr + 1 < k) {
            return;
        }

        if (temp.size() == k) {
            ans.add(new ArrayList<>(temp));
            return;
        }
        // select curr
        temp.add(curr);
        dfs(curr + 1, n, k);
        // unselect curr
        temp.remove(temp.size() - 1);
        dfs(curr + 1, n, k);
    }
}
```

**时间复杂度的分析比较复杂，详情可以参考原题官方的推论**

