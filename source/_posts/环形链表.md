---
title: 环形链表
categories:
- 算法
- 双指针
tags:
- 算法
mathjax: true
---

### 环形链表（ 双指针 ）

<!--more-->

> > 给你一个链表的头节点 `head` ，判断链表中是否有环。
> >
> > 题目详情参考：[141. 环形链表 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/linked-list-cycle/)

### 解法一：数学

思路：因为该题目的链表长度有上限，所以遍历链表，记录节点数，如果大于上限，那么一定存在环。

代码如下:

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        int count = 0;
        while(head != null) {
            head = head.next;
            count++;
            if(count > 100001) {
                return true;
            }
        }
        return false;
    }
}
```

$$
\begin{align}
&时间复杂度:O(n)
&空间复杂度:O(1)
\end{align}
$$

---

### 解法二：哈希表

思路：遍历过程中哈希表记录即可，出现重复即存在环。

代码如下：

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        Set<ListNode> set = new HashSet<>();
        while(head != null) {
            if(set.contains(head)) {
                return true;
            }
            set.add(head);
            head = head.next;
        }
        return false;
    }
}
```
$$
\begin{align}
&时间复杂度:O(n)
&空间复杂度:O(n)
\end{align}
$$

---

### 解法三：双指针

思路：基于**Floyd判圈算法（龟兔赛跑算法）**

1. 定义两个指针：快指针、慢指针，并且快指针移动比慢指针快；
2. 快指针每次移动两个结点，慢指针每次移动一个结点；
3. 如果快指针和慢指针对应的结点相同，那么说明存在环。

代码如下：

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head == null) {
            return false;
        }
        ListNode slow = head;
        ListNode fast = head.next;
        while(slow != fast) {
            if(fast == null || fast.next == null) {
                return false;
            }
            fast = fast.next.next;
            slow = slow.next;
        }
        return true;
    }
}
```
$$
\begin{align}
&时间复杂度:O(n)
&空间复杂度:O(1)
\end{align}
$$

