---
title: 栈模拟
categories:
- 算法
- 模拟
tags:
- 算法
mathjax: true
---

### 栈模拟

<!--more-->

#### Preface

再学习栈模拟之前，遇到模拟问题，都只会简单的模拟，时间复杂度会很高，

并且代码量也大，遇到再难一些的特征模拟问题，会束手无策，借着机会，

引用下面两个题，来整理一下栈模拟的代码：

* [735. 行星碰撞 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/asteroid-collision/)

* [6028. 统计道路上的碰撞次数 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/count-collisions-on-a-road/)

----

### Solution

#### 行星碰撞

遍历数组，不妨规定正方向为向右，在题目中即正数，用栈存储，

如果遇到负数，那么即判断与栈顶元素的碰撞结果，依据题意出栈入栈。

```java
class Solution {
    public int[] asteroidCollision(int[] asteroids) {
        Deque<Integer> stack = new LinkedList<>();
        for (int i = 0; i < asteroids.length; i++) {
            if (asteroids[i] < 0 && stack.size() > 0) {
                boolean flag = true;
                while (stack.size() > 0 && stack.peek() > 0) {
                    if (stack.peek() > Math.abs(asteroids[i])) {
                        flag = false;
                        break;
                    } else if (stack.peek() == Math.abs(asteroids[i])) {
                        flag = false;
                        stack.pop();
                        break;
                    } else {
                        stack.pop();
                    }
                }
                if (flag) {
                    stack.push(asteroids[i]);
                }
            } else {
                stack.push(asteroids[i]);
            }
        }
        int[] ans = new int[stack.size()];
        for (int i = ans.length - 1; i >= 0; i--) {
            ans[i] = stack.pop();
        }
        return ans;
    }
}
```

$$
\begin{align}
&时间复杂度:O(N)
&空间复杂度:O(N)
\end{align}
$$

-----

#### 统计道路上的碰撞次数

栈模拟思路与上述相似

```java
class Solution {
    public int countCollisions(String directions) {
        Deque<Character> stack = new LinkedList<>();
        int ans = 0;
        for (int i = 0; i < directions.length(); i++) {
            char c = directions.charAt(i);
            if (c == 'L') {
                if (stack.size() > 0) {
                    while (stack.size() > 0 && stack.peek() == 'R') {
                        ans++;
                        stack.pop();
                    }
                    ans++;
                    stack.push('S');
                }
            } else if (c == 'S') {
                while (stack.size() > 0 && stack.peek() == 'R') {
                    ans++;
                    stack.pop();
                }
                stack.push('S');
            } else {
                stack.push(c);
            }
        }
        return ans;
    }
}
```

**另外一种解法，偏向于思考：**

道路两端向左向右的车必定不会发生碰撞，而其内部的车一定会碰撞。

```java
class Solution {
    public int countCollisions(String directions) {
        int left = 0;
        int right = directions.length() - 1;
        while (left <= right && directions.charAt(left) == 'L') {
            left++;
        }
        while (left <= right && directions.charAt(right) == 'R') {
            right--;
        }
        int ans = 0;
        for (int i = left; i <= right; i++) {
            if (directions.charAt(i) == 'L' || directions.charAt(i) == 'R') {
                ans++;
            }
        }
        return ans;
    }
}
```

