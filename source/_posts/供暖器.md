---
title: 供暖器
categories:
- 算法
- 贪心
tags:
- 算法
mathjax: true
---

### 供暖器（ 贪心 | 双指针 ）

<!--more-->

> 冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。
>
> 在加热器的加热半径范围内的每个房屋都可以获得供暖。
>
> 现在，给出位于一条水平线上的房屋 houses 和供暖器 heaters 的位置，
>
> 请你找出并返回可以覆盖所有房屋的最小加热半径。
>
> 说明：所有供暖器都遵循你的半径标准，加热的半径也一样。
>
> ```html
> 输入: houses = [1,2,3], heaters = [2]
> 输出: 1
> ```
>
> 题目详情参考：[475. 供暖器 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/heaters/)

### 解法一：贪心 +二分搜索

思路：考虑房屋和供暖器，那么**一定是房屋距离最近的供暖器，使得当前半径最小，**

因此，遍历所有的房屋，得到其所有距离的最大值，即为覆盖所有房屋的最小加热半径。

1. 首先对 `heaters` 数组排序，便于二分搜索；
2. **二分搜索过程中，如果未搜索到，需要对左右比较，得到最小距离；**

代码如下：

```java
class Solution {
    public int findRadius(int[] houses, int[] heaters) {
        Arrays.sort(heaters);
        int ans = 0;
        for (int i = 0; i < houses.length; i++) {
            int index = binarySearch(heaters, houses[i]);
            int dis = Math.abs(houses[i] - index);
            System.out.println(dis);
            ans = Math.max(ans, dis);
        }
        return ans;
    }

    private int binarySearch(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left < right) {
            int mid = (right - left) / 2 + left;
            if (nums[mid] == target) {
                return nums[mid];
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        if (left > nums.length) {
            return nums[--left];
        } else if (left == 0) {
            return nums[left];
        }
        if (target - nums[left - 1] > nums[left] - target) {
            return nums[left - 1];
        }
        return 0;
    }
}
```

$$
\begin{align}
&时间复杂度:O(nlogn)
&空间复杂度:O(logn)\\\\
&空间复杂度主要取决于排序算法
\end{align}
$$

------

### 解法二：贪心 + 双指针

思路：基于解法一，同时对 `houses` 数组排序，那么可以简化搜索过程。

1. 对于 `houses[i]` ，从左到右遍历 `heaters` ，用变量 `j` 记录位置；

2. 如果当前房屋和当前加热器的距离大于下一个加热器的距离，那么 `j++`;

3. 否则的话，说明当前距离就是最小距离，同时更新结果；

4. **在查找下一个房屋时，不需要从 `j=0` 开始，因为两个数组都已排序，**

   **不可能存在已经遍历的加热器比当前 `j` 位置的更近；**

5. 因此从当前 `j` 的值开始继续遍历，重复上述过程即可。

**注意：双指针遍历两个数组的时间复杂度是 O(m + n)！**

```java
class Solution {
    public int findRadius(int[] houses, int[] heaters) {
        Arrays.sort(houses);
        Arrays.sort(heaters);
        int ans = 0;
        for (int i = 0, j = 0; i < houses.length; i++) {
            int currDis = Math.abs(heaters[j] - houses[i]);
            while (j < heaters.length - 1 && 
                   currDis >= Math.abs(heaters[j + 1] - houses[i])) {
                currDis = Math.abs(heaters[++j] - houses[i]);
            }
            ans = Math.max(ans, currDis);
        }
        return ans;
    }
}
```

$$
\begin{align}
&时间复杂度:O(mlogm + nlogn) 
&空间复杂度:O(logm +logn)
\end{align}
$$

