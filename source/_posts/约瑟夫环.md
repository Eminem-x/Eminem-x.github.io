---
title: 约瑟夫环
categories:
- 算法
- 数学
tags:
- 算法
mathjax: true
---

### 约瑟夫环

<!--more-->

## 约瑟夫环的基础问题：

> [1823. 找出游戏的获胜者 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/)

### 解法一：状态模拟

思路：开辟一个数组，表示当前人的状态，而后循环模拟退圈过程。

#### 第一种状态模拟：

代码如下：

```java
class Solution {
    public int findTheWinner(int n, int k) {
        if (k == 1) {
            return n;
        }
        boolean[] arr = new boolean[n];
        int count = k;
        while (!isOne(arr)) {
            for (int i = 0; i < arr.length; i++) {
                if (arr[i]) {
                    continue;
                }
                count--;
                if (count == 0 && !arr[i]) {
                    arr[i] = true;
                    count = k;
                }
            }
        }
        for (int i = 0; i < arr.length; i++) {
            if (!arr[i]) {
                return i + 1;
            }
        }
        return 0;
    }

    // 额外开辟了一个循环 但是便于理解
    private boolean isOne(boolean[] arr) {
        int num = 0;
        for (int i = 0; i < arr.length; i++) {
            if (!arr[i]) {
                num++;
            }
        }
        return num == 1;
    }
}
```

#### 第二种状态模拟：

代码如下：

````java
class Solution {
    public int findTheWinner(int n, int k) {
        boolean[] arr = new boolean[n + 1];
        int count = 0, num = 0, index = 0;
        while (count != n - 1) {
            index++;
            if (index > n) {
                index = 1;
            }
            if (!arr[index]) {
                num++;
            }
            if (num == k) {
                arr[index] = true;
                num = 0;
                count++;
            }
        }
        for (int i = 1; i < arr.length; i++) {
            if (!arr[i]) {
                return i;
            }
        }
        return 0;
    }
}

````
$$
\begin{align}
&时间复杂度:O(n^2)
&空间复杂度:O(n)
\end{align}
$$

----

### 解法二：迭代递推

1. 为了方便处理，人数从 `0` 开始至 `n - 1`，并且从 `0` 开始报数至 `k - 1` ;

2. 第一次淘汰的人编号为 `(m - 1) mod n` ；

3. 那么剩下的 `n - 2` 人从 `m mod n` 开始报数，组成一个新的约瑟夫环：

   k、k + 1、... 、k - 2 对应为 0、1、... 、n - 2；

4. 若这个新问题的解为 `x` ，那么原问题的解也为此，但是需要将编号映射为原位置：

   x<sup>'</sup> = (x + k) mod n
   
5. 因此得到递归关系如下，其中 `f[i]` 表示人数为 `i` 时的解：
   $$
   f[i]=(f[i - 1] + m) mod (i - 1)
   $$

代码如下：

```java
class Solution {
    public int findTheWinner(int n, int k) {
        int f = 0;
        for (int i = 1; i <= n; i++) {
            f = (f + k) % i;
        }
        return ++f;
    }
}
```

$$
\begin{align}
&时间复杂度:O(n)
&空间复杂度:O(1)
\end{align}
$$

---

## 约瑟夫环的进阶问题：

其实有很多改编的题目，比如调整数据规模，O（n）降为 O（logn）；

下面一题，尽管并不应用约瑟夫环的解法，但仍为一种递归求解数学问题。

> [390. 消除游戏 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/elimination-game/)

### 解法一：等差数列模拟

1. 每次都将整数列表进行间隔删除，因此每次删除后剩余的整数列表都是等差数列；
2. 首先创建变量 `numOfCircles` ，用来确定正向或者反向遍历；
3. 当正向遍历的时候，需要确定当前整数列表的长度，因为奇偶不一致，处理也不一样；
4. 反向遍历亦然如此，即分类讨论；
5. 每次循环结束时，需要将等差 `d` 扩大一倍，数列长度 `n` 缩小一倍；
6. 退出循环的条件为：数列长度为 `1` 。

代码如下：

```java
class Solution {
    public int lastRemaining(int n) {
        int a1 = 1, an = n, d = 1;
        int numOfCircles = 0;
        while (n > 1) {
            if (numOfCircles % 2 == 0) {
                a1 = a1 + d;
                an = (n % 2 == 0) ? an : an - d;
            } else {
                an = an - d;
                a1 = (n % 2 == 0) ? a1 : a1 + d;
            }
            d = d << 1;
            n = n >> 1;
            numOfCircles++;
        }
        return a1;
    }
}
```

$$
\begin{align}
&时间复杂度:O(logn)
&空间复杂度:O(1)
\end{align}
$$

---

### 解法二：递归模拟

> 参见题解：[【宫水三叶】约瑟夫环运用题 - 消除游戏 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/elimination-game/solution/gong-shui-san-xie-yue-se-fu-huan-yun-yon-x60m/)

#### 尾递归的概念：

参考链接：

1. [尾递归_百度百科 (baidu.com)](https://baike.baidu.com/item/尾递归/554682)
2. [(20条消息) 详解什么是尾递归（通俗易懂，示例讲解）_Vermont_的博客-CSDN博客_尾递归](https://blog.csdn.net/Vermont_/article/details/84557065)

