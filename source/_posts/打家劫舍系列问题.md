---
title: 打家劫舍系列问题
categories:
- 算法
- 动态规划
tags:
- 算法
mathjax: true
---

### 打家劫舍系列问题（ 动态规划 ）

<!--more-->

### 打家劫舍Ⅰ

> 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，
>
> 影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，
>
> 如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
>
> 给定一个代表每个房屋存放金额的非负整数数组，
>
> 计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
>
> ```html
> 输入：[1,2,3,1]
> 输出：4
> ```
>
> 题目详情参考：[198. 打家劫舍 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/house-robber/)

思路：动态规划的经典题目，**一定要先找到动态转移方程！**

1. 不妨设一维数组 `dp` ，**其中 `dp[i]` 表示在从 `0` 到 `i` 时，所能偷取的最大金额；**
2. 那么根据题意可知，所偷的房子不能相邻，因此得到如下转移方程：

$$
dp[i] = max\lbrace dp[i - 1],dp[i - 2] + nums[i] \rbrace
$$

3. 即在当前位置，有两种选择：
   1. 不偷当前位置的房子，那么相当于偷前一个房子；
   2. 偷当前位置的房子，那么相当于不偷前一个房子；
4. **补充：也可以使用滚动数组降低空间复杂度！**

代码如下：

```java
class Solution {
    public int rob(int[] nums) {
        if (nums.length == 1) {
            return nums[0];
        }

        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        int ans = Math.max(dp[0], dp[1]);
        for (int i = 2; i < nums.length; i++) {
            dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
            ans = Math.max(dp[i], ans);
        }
        return ans;
    }
}
```

$$
\begin{align}
&时间复杂度:O(n)
&空间复杂度:O(n)
\end{align}
$$

----

### 打家劫舍Ⅱ

> 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。
>
> 这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。
>
> 同时，相邻的房屋装有相互连通的防盗系统，
>
> 如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。
>
> 给定一个代表每个房屋存放金额的非负整数数组，
>
> 计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。
>
> 题目详情参考：[213. 打家劫舍 II - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/house-robber-ii/)

思路：该题和第一题的不同之处在于，这次房屋不是直线而是闭合的环。

1. 如果偷了第一家，那么偷的范围应为 `0 ~ length - 1`；
2. 如果不偷第一家，那么偷的范围应为 `1 ~ length`；
3. **这两个解集的并集，包括所有情况，可以仔细思考一下；**
4. 其余思路和第一问相同。

代码如下：

```java
class Solution {
    public int rob(int[] nums) {
        if (nums.length == 1) {
            return nums[0];
        }
        if (nums.length == 2) {
            return Math.max(nums[0], nums[1]);
        }

        int[] dp = new int[nums.length];
        // get max value from 0 to length - 1
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        int ans = Math.max(dp[0], dp[1]);
        for (int i = 2; i < nums.length - 1; i++) {
            dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
            ans = Math.max(dp[i], ans);
        }

        // get max value from 1 to length
        dp[1] = nums[1];
        dp[2] = Math.max(nums[1], nums[2]);
        ans = Math.max(ans, Math.max(dp[1], dp[2]));
        for (int i = 3; i < nums.length; i++) {
            dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
            ans = Math.max(dp[i], ans);
        }

        return ans;
    }
}
```
$$
\begin{align}
&时间复杂度:O(n)
&空间复杂度:O(n)
\end{align}
$$

----

### 变形题：删除并获得点数

> 给你一个整数数组 nums ，你可以对它进行一些操作。
>
> 每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。
>
> 之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。
>
> 开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。
>
> ```html
> 输入：nums = [2,2,3,3,3,4]
> 输出：9
> ```
>
> 题目详情参考：[740. 删除并获得点数 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/delete-and-earn/)

思路：将该题转变为上面两题，二者的整体思路相差不多。

1. **采用Map统计**数组中各自元素的值和数量，以便后续求点数；

2. 不妨设二维数组 `dp` ，

   * `dp[i][0]` 表示当前位置的元素；

   * `dp[i][1]` 表示当前位置下元素的个数；
   * `dp[i][2]` **表示从开始至当前位置下所能获得最大点数；**

3. 对 `dp` 进行排序，那么对于 `dp[i]` 可以得到下面的情况：

   1. 如果 `dp[i - 1][0] + 1` 等于 `dp[i][0]` ；
   2. 如果 `dp[i - 1][0] + 1` 不等于 `dp[i][0]` ；
   3. **上述两种情况等价于第一题中的房子是否相邻！**

4. 那么可以得到动态转移方程：

$$
dp[i][2]=\begin{cases}max\lbrace dp[i - 1][2],dp[i-2][2]+dp[i][0]×dp[i][1] \rbrace &dp[i-1][0] + 1=dp[i][0] \\\\ dp[i-1][2]+dp[i][0]×dp[i][1] &反之\end{cases}
$$

代码如下：

```java
class Solution {
    public int deleteAndEarn(int[] nums) {
        int[][] dp = getElementNumArray(nums);
        Arrays.sort(dp, (o1, o2) -> o1[0] - o2[0]);

        int ans = 0;
        dp[0][2] = dp[0][0] * dp[0][1];
        if (dp.length == 1) {
            return dp[0][2];
        }

        if (dp[1][0] == dp[0][0] + 1) {
            dp[1][2] = Math.max(dp[0][2], dp[1][0] * dp[1][1]);
        } else {
            dp[1][2] = dp[0][2] + dp[1][0] * dp[1][1];
        }
        ans = Math.max(dp[0][2], dp[1][2]);
        if (dp.length == 2) {
            return ans;
        }

        for (int i = 2; i < dp.length; i++) {
            if (dp[i][0] == dp[i - 1][0] + 1) {
                dp[i][2] = dp[i - 2][2] + dp[i][0] * dp[i][1];
            } else {
                dp[i][2] = dp[i - 1][2] + dp[i][0] * dp[i][1];
            }
            ans = Math.max(dp[i][2], ans);
        }

        return ans;
    }

    private int[][] getElementNumArray(int[] nums) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int num : nums) {
            map.put(num, map.getOrDefault(num, 0) + 1);
        }
        int[][] arr = new int[map.size()][3];
        int index = 0;
        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
            arr[index][0] = entry.getKey();
            arr[index][1] = entry.getValue();
            index++;
        }
        return arr;
    }
}
```
$$
\begin{align}
&时间复杂度:O(n)
&空间复杂度:O(n)
\end{align}
$$

---

