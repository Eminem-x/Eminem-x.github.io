---
title: 最长递增子序列
categories:
- 算法
- 动态规划
tags:
- 算法
mathjax: true
---

### 最长递增子序列（ 动态规划 | 贪心 ）

<!--more-->

> 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
>
> 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。
>
> 例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
>
> 题目详情参考：[300. 最长递增子序列 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

### 解法一：动态规划

思路：找到最优子结构和动态转移方程。

1. 不妨设数组 `dp` ，其中 `dp[i]` 表示以 `i` 结尾时，当前的最长严格递增子序列，

   **注意：一定包含 `nums[i]` ;**

2. 因此对于 `dp[i]` ，可得动态转移方程：

$$
dp[i] = max \lbrace dp[j] \rbrace, \ 0≤j<i \ 并且\  nums[j] < nums[i]
$$

3. **最终答案即为：max{ dp[ i ] }，0 ≤ i < nums.length - 1；**

代码如下：

````java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        Arrays.fill(dp, 1);
        int ans = 0;
        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[j] + 1, dp[i]);
                }
            }
            ans = Math.max(dp[i], ans);
        }
        return ans;
    }
}
````

$$
\begin{align}
&时间复杂度:O(n^2)
&空间复杂度:O(n)
\end{align}
$$

----

### 解法二：贪心 + 二分搜索

思路：**如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，**

​           **因此我们希望每次在上升子序列最后加上的那个数尽可能的小。**

1. 基于上面的贪心思路，不妨维护一个数组 `incresingSeque[i]` ，

   表示长度为 `i` 的最长上升子序列的末尾元素的最小值；

2. 并且声明一个变量 `currLen` 记录当前最长上升子序列的长度；

3. 可以证明数组 `incresingSeque` 是一个单调递增的数组：

   不妨设 `incresingSeque[i]` < `incresingSeque[j]` && `i` > `j`，

   那么在数组末尾删除 `i - j` 个元素，

   那么就找到了一个长度为 `j` 的最长上升子序列，且末尾元素比 `d[j]` 小，矛盾，证明完毕；

4. 遍历数组，更新 `incresingSeque[i]` 的值以及 `currLen`：

   1. 当遇到值大于目前末尾时，将其添加至末尾，并且 `currLen++` ;
   2. 当遇到值不大于时，在数组**通过二分搜索找到合适位置**，更新数组；

代码如下：

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int currLen = 1;
        int[] incresingSeque = new int[nums.length + 1];
        incresingSeque[1] = nums[0];
        for (int i = 1; i < nums.length; i++) {
            if (incresingSeque[currLen] < nums[i]) {
                incresingSeque[++currLen] = nums[i];
            } else {
                int left = 1, right = currLen, pos = 0;
                while (left <= right) {
                    int mid = (left + right) >> 1;
                    if (incresingSeque[mid] < nums[i]) {
                        pos = mid;
                        left = mid + 1;
                    } else {
                        right = mid - 1;
                    }
                }
                incresingSeque[pos + 1] = nums[i];
            }
        }
        return currLen;
    }
}
```
$$
\begin{align}
&时间复杂度:O(nlogn)
&空间复杂度:O(n)
\end{align}
$$

----

### 变式：[使数组 K 递增的最少操作次数](https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-k-increasing/)

说明：LeetCode 272周赛最后一题，当时没有采用时间复杂度 nlogn 的算法，导致超时。

思路：该题目仔细思考就能看出来 LIS 的变式，相当于 `K` 个数组的最长子序列，然后变化即可；

细节：该题目为非严格递增，因此判断条件改为 `≤` 即可；

**重点：时空复杂度需要认真思考！**

代码如下：

```java
class Solution {
    public int kIncreasing(int[] arr, int k) {
        int ans = 0;
        for (int i = 0; i < k; i++) {
            List<Integer> list = new ArrayList<>();
            int j = i;
            while (j < arr.length) {
                list.add(arr[j]);
                j += k;
            }
            Integer[] nums = list.toArray(new Integer[list.size()]);
            int temp = lengthOfLIS(nums);
            ans += nums.length - temp;
        }
        return ans;
    }

    public int lengthOfLIS(Integer[] nums) {
        int len = 1, n = nums.length;
        if (n == 0) {
            return 0;
        }
        int[] d = new int[n + 1];
        d[len] = nums[0];
        for (int i = 1; i < n; ++i) {
            if (nums[i] >= d[len]) {
                d[++len] = nums[i];
            } else {
                int l = 1, r = len, pos = 0;
                while (l <= r) {
                    int mid = (l + r) >> 1;
                    if (d[mid] <= nums[i]) {
                        pos = mid;
                        l = mid + 1;
                    } else {
                        r = mid - 1;
                    }
                }
                d[pos + 1] = nums[i];
            }
        }
        return len;
    }
}
```
$$
\begin{align}
&时间复杂度:O(nlog\frac nk) \\\\
&空间复杂度:O(\frac nk)
\\\\&每个序列的长度为\ (\frac nk),LIS的时间复杂度\ O(\frac nklog\frac nk),\\\\&一共有k个序列，因此总时间复杂度为\ O(nlog\frac nk).
\end{align}
$$

