<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>蓄水</title>
      <link href="/2021/12/04/%E8%93%84%E6%B0%B4/"/>
      <url>/2021/12/04/%E8%93%84%E6%B0%B4/</url>
      
        <content type="html"><![CDATA[<h3 id="蓄水（-贪心-）"><a href="#蓄水（-贪心-）" class="headerlink" title="蓄水（ 贪心 ）"></a>蓄水（ 贪心 ）</h3><span id="more"></span><blockquote><blockquote><p>给定 N 个无限容量且初始均空的水缸，每个水缸配有一个水桶用来打水，</p><p>第 i 个水缸配备的水桶容量记作 bucket[i]。</p><p>有以下两种操作：</p><p>升级水桶：选择任意一个水桶，使其容量增加为 bucket[i]+1<br>蓄水：将全部水桶接满水，倒入各自对应的水缸<br>每个水缸对应最低蓄水量记作 vat[i]，返回至少需要多少次操作可以完成所有水缸蓄水要求。</p><p>注意：实际蓄水量 达到或超过 最低蓄水量，即完成蓄水要求。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：bucket = [1,3], vat = [6,8]</span><br><span class="line">&gt;输出：4</span><br><span class="line">&gt;解释：</span><br><span class="line">&gt;第 1 次操作升级 bucket[0]；</span><br><span class="line">&gt;第 2 ~ 4 次操作均选择蓄水，即可完成蓄水要求。</span><br></pre></td></tr></table></figure><p>题目详情参考：<a href="https://leetcode-cn.com/problems/o8SXZn/">LCP 33. 蓄水 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote></blockquote><p>思路：<strong>如果要升级水桶容量，那么就尽早升级，这一定是次数最少的情况。</strong></p><ol><li>题目数据规模不大，枚举出尽可能大的情况，得到最优解；</li><li><strong>（升级次数 + 初始蓄水量）× 倒水次数 = 容量</strong>；</li><li><strong>总次数 = 倒水次数 + 总升级次数</strong>；</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">storeWater</span><span class="params">(<span class="keyword">int</span>[] bucket, <span class="keyword">int</span>[] vat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">10001</span>;</span><br><span class="line">        <span class="comment">// 枚举倒水次数1-10000</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> pour = <span class="number">0</span>; pour &lt;= <span class="number">10000</span>; pour++) &#123; </span><br><span class="line">            <span class="keyword">if</span> (pour &gt;= ans) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">int</span> upgrade = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 枚举每个水桶，计算总升级次数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vat.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 贪心 先升级必定减少次数</span></span><br><span class="line">                <span class="comment">// （升级次数 + 初始蓄水量）* 倒水次数 = 容量</span></span><br><span class="line">                <span class="keyword">int</span> cur = (<span class="keyword">int</span>)Math.ceil((<span class="keyword">double</span>)vat[i] / pour - bucket[i]); </span><br><span class="line">                upgrade += cur &gt; <span class="number">0</span> ? cur : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (upgrade &gt;= ans) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 总次数 = 倒水次数 + 总升级次数</span></span><br><span class="line">            ans = Math.min(ans, upgrade + pour); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(10^4×n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 贪心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>螺旋矩阵</title>
      <link href="/2021/12/03/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
      <url>/2021/12/03/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="螺旋矩阵（数学）"><a href="#螺旋矩阵（数学）" class="headerlink" title="螺旋矩阵（数学）"></a>螺旋矩阵（数学）</h3><span id="more"></span><blockquote><blockquote><p>总结螺旋矩阵的三种问题：</p><ol><li>由外到内，如何构造螺旋矩阵</li><li>由内到位，如何输出螺旋矩阵</li><li>如何确定螺旋矩阵的位置元素</li></ol></blockquote></blockquote><h3 id="螺旋矩阵Ⅰ"><a href="#螺旋矩阵Ⅰ" class="headerlink" title="螺旋矩阵Ⅰ"></a>螺旋矩阵Ⅰ</h3><blockquote><blockquote><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><p>题目详情参考：<a href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote></blockquote><p>思路：模拟出 <code>顺时针螺旋顺序</code></p><ol><li>创建一个  <code>visited</code> 矩阵，用来判断是否被选取过；</li><li>创建方向数组 <code>dirs</code>，用来改变螺旋的方向；</li><li>创建变量 <code>currX</code>、<code>currY</code>，用来记录当前位置；</li><li><strong>当模拟遍历时，如果出界或者该位置已被遍历过，那么改变方向。</strong></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[row][col];</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> currX = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> currY = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> currDir = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (ans.size() != row * col) &#123;</span><br><span class="line">            <span class="keyword">if</span> (currX &gt;= <span class="number">0</span> &amp;&amp; currY &gt;= <span class="number">0</span> &amp;&amp; currX &lt; row </span><br><span class="line">                &amp;&amp; currY &lt; col &amp;&amp; !visited[currX][currY]) &#123;</span><br><span class="line">                ans.add(matrix[currX][currY]);</span><br><span class="line">                visited[currX][currY] = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                currX -= dirs[currDir][<span class="number">0</span>];</span><br><span class="line">                currY -= dirs[currDir][<span class="number">1</span>];</span><br><span class="line">                currDir++;</span><br><span class="line">                currDir %= <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            currX += dirs[currDir][<span class="number">0</span>];</span><br><span class="line">            currY += dirs[currDir][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(m×n)<br>&amp;空间复杂度:O(m×n)<br>\end{align}<br>$$</p><hr><h3 id="螺旋矩阵Ⅱ"><a href="#螺旋矩阵Ⅱ" class="headerlink" title="螺旋矩阵Ⅱ"></a>螺旋矩阵Ⅱ</h3><blockquote><blockquote><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n × n</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p>题目详情参考：<a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote></blockquote><p>思路：</p><ol><li><p>与螺旋矩阵Ⅰ的思路大体相似，不过是生成螺旋矩阵；</p></li><li><p>创建变量 <code>num</code> 填充并记录螺旋矩阵元素，遍历即可。</p></li></ol><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> currX = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> currY = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> currDir = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (num &lt;= n * n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (currX &gt;= <span class="number">0</span> &amp;&amp; currY &gt;= <span class="number">0</span> &amp;&amp; currX &lt; n </span><br><span class="line">                &amp;&amp; currY &lt; n &amp;&amp; !visited[currX][currY]) &#123;</span><br><span class="line">                ans[currX][currY] = num++;</span><br><span class="line">                visited[currX][currY] = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                currX -= dirs[currDir][<span class="number">0</span>];</span><br><span class="line">                currY -= dirs[currDir][<span class="number">1</span>];</span><br><span class="line">                currDir++;</span><br><span class="line">                currDir %= <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            currX += dirs[currDir][<span class="number">0</span>];</span><br><span class="line">            currY += dirs[currDir][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(m×n)<br>&amp;空间复杂度:O(m×n)<br>\end{align}<br>$$</p><hr><h3 id="螺旋矩阵Ⅲ"><a href="#螺旋矩阵Ⅲ" class="headerlink" title="螺旋矩阵Ⅲ"></a>螺旋矩阵Ⅲ</h3><blockquote><blockquote><p>在 R 行 C 列的矩阵上，我们从 (r0, c0) 面朝东面开始</p><p>这里，网格的西北角位于第一行第一列，网格的东南角位于最后一行最后一列。</p><p>现在，我们以顺时针按螺旋状行走，访问此网格中的每个位置。</p><p>每当我们移动到网格的边界之外时，我们会继续在网格之外行走（但稍后可能会返回到网格边界）。</p><p>最终，我们到过网格的所有 R * C 个空间。</p><p>按照访问顺序返回表示网格位置的坐标列表。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：R = 1, C = 4, r0 = 0, c0 = 0</span><br><span class="line">&gt;输出：[[0,0],[0,1],[0,2],[0,3]]</span><br></pre></td></tr></table></figure></blockquote></blockquote><p>思路：前面两个螺旋矩阵都是由外向内旋转，而此矩阵是由内向外旋转</p><ol><li>首先扩充该矩阵为 <code>n × n</code>  的方形矩阵，其中 <code>n</code> 为选中位置距离边界的最大距离；</li><li><strong>模拟遍历可知，最后的终点是拓展矩阵的右上角位置，那么可以反方向旋转求解；</strong></li><li>至此，已经转化为前两个问题，不过仍有需要注意的地方：<ol><li>起始位置和方向发生改变</li><li>需要记录拓展矩阵中哪些是需要记录的元素</li><li>如何确定原矩阵的位置</li></ol></li></ol><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] spiralMatrixIII(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> rStart, <span class="keyword">int</span> cStart) &#123;</span><br><span class="line">        <span class="keyword">int</span> nums = rows * cols;</span><br><span class="line">        <span class="keyword">boolean</span>[][] matrix = getExpendedMatrix(rows, cols, rStart, cStart);</span><br><span class="line">        <span class="keyword">int</span> sideLength = getSideLength(rows, cols, rStart, cStart);</span><br><span class="line">        <span class="keyword">return</span> getSipralOrder(matrix, nums, sideLength - rStart, sideLength - cStart);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][] getExpendedMatrix(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> rStart, <span class="keyword">int</span> cStart) &#123;</span><br><span class="line">        <span class="keyword">int</span> sideLength = getSideLength(rows, cols, rStart, cStart);</span><br><span class="line">        <span class="keyword">int</span> matrixSize = sideLength * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">boolean</span>[matrixSize][matrixSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = sideLength - rStart; i &lt; sideLength - rStart + rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = sideLength - cStart; j &lt; sideLength - cStart + cols; j++) &#123;</span><br><span class="line">                matrix[i][j] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSideLength</span><span class="params">(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> rStart, <span class="keyword">int</span> cStart)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxRow = Math.max(rStart, rows - <span class="number">1</span> - rStart);</span><br><span class="line">        <span class="keyword">int</span> maxCol = Math.max(cStart, cols - <span class="number">1</span> - cStart);</span><br><span class="line">        <span class="keyword">int</span> sideLength = Math.max(maxRow, maxCol);</span><br><span class="line">        <span class="keyword">return</span> sideLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] getSipralOrder(<span class="keyword">boolean</span>[][] matrix, <span class="keyword">int</span> nums, <span class="keyword">int</span> deltaX, <span class="keyword">int</span> deltaY) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = matrix.length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[size][size];</span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[nums][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> currX = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> currY = size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> currDir = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (index != nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (currX &gt;= <span class="number">0</span> &amp;&amp; currY &gt;= <span class="number">0</span> &amp;&amp; currX &lt; size </span><br><span class="line">                &amp;&amp; currY &lt; size &amp;&amp; !visited[currX][currY]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[currX][currY]) &#123;</span><br><span class="line">                    ans[nums - index - <span class="number">1</span>][<span class="number">0</span>] = currX - deltaX;</span><br><span class="line">                    ans[nums - index - <span class="number">1</span>][<span class="number">1</span>] = currY - deltaY;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">                visited[currX][currY] = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                currX -= dirs[currDir][<span class="number">0</span>];</span><br><span class="line">                currY -= dirs[currDir][<span class="number">1</span>];</span><br><span class="line">                currDir++;</span><br><span class="line">                currDir %= <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            currX += dirs[currDir][<span class="number">0</span>];</span><br><span class="line">            currY += dirs[currDir][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(m×n)<br>&amp;空间复杂度:O(m×n)<br>\end{align}<br>$$</p><hr><h3 id="螺旋矩阵Ⅳ"><a href="#螺旋矩阵Ⅳ" class="headerlink" title="螺旋矩阵Ⅳ"></a>螺旋矩阵Ⅳ</h3><blockquote><blockquote><p>给定一个 <code>n * n</code> 的矩阵，螺旋排列，如何确定某一位置的元素？</p><p>题目详情参考：<a href="https://leetcode-cn.com/problems/SNJvJP/">LCP 29. 乐团站位 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote></blockquote><p><img src="/2021/12/03/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E5%9B%BE.png" alt="示例图"></p><ol><li>将矩阵按圈的循环进行分割，再将圈，按照上述形式分割；</li><li>当前坐标为 <em>( xPos , yPos )</em>，首先获得该点所在的圈数，然后进行计算；</li><li>计算当前圈数前所有的点数，一个简单的等差数列求和；</li><li>分类讨论当前点所在圈的位置情况，计算总数，取余即为答案。</li></ol><p><strong>注意事项：</strong></p><ol><li>数据过大，将所有变量声明为 <code>long</code>；</li><li>结果取余时，为 <code>0</code> 时需要特殊考虑；</li><li>分类讨论时，不需要加上边界限制；</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">orchestraLayout</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> xPos, <span class="keyword">int</span> yPos)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 得到当前所在圈数 圈数从 0 开始</span></span><br><span class="line">        <span class="keyword">long</span> numOfTurns = Math.min(xPos, yPos);</span><br><span class="line">        numOfTurns = Math.min(num - <span class="number">1</span> - yPos, numOfTurns);</span><br><span class="line">        numOfTurns = Math.min(num - <span class="number">1</span> - xPos, numOfTurns);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算先前所有的点数和，以及当前圈的边长</span></span><br><span class="line">        <span class="keyword">long</span> preSum = (<span class="number">4</span> * (<span class="keyword">long</span>) num - <span class="number">4</span> * numOfTurns) * numOfTurns;</span><br><span class="line">        <span class="keyword">long</span> sideLength = num - <span class="number">2</span> * numOfTurns - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分类讨论得到目前点数和</span></span><br><span class="line">        <span class="keyword">long</span> currNum;</span><br><span class="line">        <span class="keyword">if</span> (xPos == numOfTurns) &#123;</span><br><span class="line">            currNum = preSum + yPos - numOfTurns + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (yPos == num - <span class="number">1</span> - numOfTurns) &#123;</span><br><span class="line">            currNum = preSum + sideLength + xPos - numOfTurns + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xPos == num - <span class="number">1</span> - numOfTurns) &#123;</span><br><span class="line">            currNum = preSum + sideLength * <span class="number">3</span> - yPos + numOfTurns + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            currNum = preSum + sideLength * <span class="number">4</span> - xPos + numOfTurns + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        currNum %= <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> currNum == <span class="number">0</span> ? <span class="number">9</span> : (<span class="keyword">int</span>) currNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(1)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大子数组和</title>
      <link href="/2021/12/01/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
      <url>/2021/12/01/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="最大子数组和（-动态规划-线段树-）"><a href="#最大子数组和（-动态规划-线段树-）" class="headerlink" title="最大子数组和（ 动态规划 | 线段树 ）"></a>最大子数组和（ 动态规划 | 线段树 ）</h3><span id="more"></span><blockquote><blockquote><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），</p><p>返回其最大和。<strong>子数组</strong> 是数组中的一个连续部分。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">&gt;输出：6</span><br><span class="line">&gt;解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="解法一：动态规划"><a href="#解法一：动态规划" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h3><p>假设数组长度为 <code>n</code> , 下标从 <em>0 ~ n - 1</em>,</p><p>不妨设 <em>f( i )</em> 表示以下标 <em>i</em> 结尾的连续子数组的最大和，那么所求答案即为：<br>$$<br>\max \limits_{0≤i≤n-1} \lbrace f(i) \rbrace<br>$$<br>那么可以得到转移方程：<br>$$<br>f(i) = max \lbrace f(i-1) + nums[i],nums[i] \rbrace<br>$$<br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> preSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            preSum = Math.max(preSum + nums[i], nums[i]);</span><br><span class="line">            ans = Math.max(preSum, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p><hr><h3 id="解法二：线段树"><a href="#解法二：线段树" class="headerlink" title="解法二：线段树"></a>解法二：线段树</h3><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(logn)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无限整数序列中定位数字</title>
      <link href="/2021/11/30/%E6%97%A0%E9%99%90%E6%95%B4%E6%95%B0%E5%BA%8F%E5%88%97%E4%B8%AD%E5%AE%9A%E4%BD%8D%E6%95%B0%E5%AD%97/"/>
      <url>/2021/11/30/%E6%97%A0%E9%99%90%E6%95%B4%E6%95%B0%E5%BA%8F%E5%88%97%E4%B8%AD%E5%AE%9A%E4%BD%8D%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h3 id="第-N-位数字（数学）"><a href="#第-N-位数字（数学）" class="headerlink" title="第 N 位数字（数学）"></a>第 N 位数字（数学）</h3><span id="more"></span><blockquote><blockquote><p>给你一个整数 <code>n</code> ，请你在无限的整数序列 <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...]</code> 中找出并返回第 <code>n</code> 位上的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">11</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="解法一：模拟查找"><a href="#解法一：模拟查找" class="headerlink" title="解法一：模拟查找"></a>解法一：模拟查找</h3><p>思路：将所有数字用字符串拼接，然后直接定位 <code>n</code> 返回当前下标的数字即可。</p><p>错误：因为 <code>n</code> 的取值范围是 <code>1 &lt;= n &lt;= 2^31 - 1</code>，会超出时间限制，无法解答，</p><p>​            实际上经过测试，当数据规模超过 10<sup>6</sup> 的规模时，就会超出时间限制。</p><hr><h3 id="解法二：数学定位"><a href="#解法二：数学定位" class="headerlink" title="解法二：数学定位"></a>解法二：数学定位</h3><p>思路：如果能够确定第 <code>n</code> 位上的数字，所在数字的位数，那么就可以进行定位求解。</p><ol><li><p><code>x</code> 位共计有 9 × 10<sup> x - 1</sup>个数字，共计有 <code>x</code> × 9 × 10<sup> x - 1</sup>位数字；</p></li><li><p>使用 <em>d</em> 和 <em>count</em> 分别表示当前遍历到的位数和当前位数下的所有整数的位数之和；</p></li><li><p>初始时 <code>d = 1</code>、<code>count = 9</code>，而后随之变化；</p></li><li><p>每次将 <em>n</em> 减去 <em>d×count</em>，然后将 <em>d</em> 加 <em>1</em>，将 <em>count</em> 乘 <em>10</em>，直到 <em>n ≤ d×count</em> ;</p></li><li><p>此时的 <code>d</code> 即为第 <code>n</code> 位上数字所在的数字位数，<em>n</em> 是所有 <em>d</em> 位数中从第一位到目标数字的位数；</p></li><li><p>使用目标数字在所有 <em>d</em> 位数中的下标进行计算，下标从 <em>0</em> 开始计数，</p><p>令  <em>index=n−1</em>，则 <em>index</em> 即为目标数字在所有 <em>d</em> 位数中的下标，<em>index</em> 的最小可能取值是 <em>0</em> ;</p></li><li><p>第 <em>n</em> 位数字是第 <em>m</em> 个 <em>d</em> 位数的第  <em>index mod d</em> 位，<strong>注意编号都从 <em>0</em> 开始</strong>;</p></li><li><p>由于最小的 <em>d</em> 位数是 <em>10<sup>d - 1</sup></em>，因此第 <em>n</em> 位数字所在的整数是 <em>10<sup>d - 1</sup> + m</em>，</p><p>该整数的右边第 <em>d − ( index mod d ) − 1</em> 位（计数从 <em>0</em> 开始）即为无限整数序列中的第 <em>n</em> 位。<br>$$<br>m = [\frac{index}{d}]<br>$$</p></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">1</span>, count = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; (<span class="keyword">long</span>) d * count) &#123;</span><br><span class="line">            n -= d * count;</span><br><span class="line">            d++;</span><br><span class="line">            count *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start = (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, d - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> num = start + index / d;</span><br><span class="line">        <span class="keyword">int</span> digitIndex = index % d;</span><br><span class="line">        <span class="keyword">int</span> digit = (num / (<span class="keyword">int</span>)(Math.pow(<span class="number">10</span>, d - digitIndex - <span class="number">1</span>))) % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> digit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(log_{10}n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p><hr><h3 id="解法三：二分优化"><a href="#解法三：二分优化" class="headerlink" title="解法三：二分优化"></a>解法三：二分优化</h3><p>思路：如果范围更广一些，可以对查找 <code>d</code> 的部分进行优化，采用二分查找。</p><p>结合解法二的从 <code>1</code> 开始遍历，当遍历到 <code>9</code> 时，即第九位个数时可知：<br>$$<br>9 × 9 × 10^8 = 8.1 × 10^9 ＞ 2^{31} - 1<br>$$<br>因此只需要在 <code>1 - 9</code> 之间进行二分查找即可。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">1</span>, high = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">if</span> (totalDigits(mid) &lt; n) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> d = low;</span><br><span class="line">        <span class="keyword">int</span> prevDigits = totalDigits(d - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> index = n - prevDigits - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start = (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, d - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> num = start + index / d;</span><br><span class="line">        <span class="keyword">int</span> digitIndex = index % d;</span><br><span class="line">        <span class="keyword">int</span> digit = (num / (<span class="keyword">int</span>) (Math.pow(<span class="number">10</span>, d - digitIndex - <span class="number">1</span>))) % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> digit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalDigits</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> digits = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curLength = <span class="number">1</span>, curCount = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">while</span> (curLength &lt;= length) &#123;</span><br><span class="line">            digits += curLength * curCount;</span><br><span class="line">            curLength++;</span><br><span class="line">            curCount *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(log_{10}n×loglog_{10}n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Next的界面优化</title>
      <link href="/2021/11/29/Hexo%E7%9A%84%E7%95%8C%E9%9D%A2%E4%BC%98%E5%8C%96/"/>
      <url>/2021/11/29/Hexo%E7%9A%84%E7%95%8C%E9%9D%A2%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="Hexo-Next的界面优化"><a href="#Hexo-Next的界面优化" class="headerlink" title="Hexo Next的界面优化"></a>Hexo Next的界面优化</h3><span id="more"></span><h3 id="如何将页面背景改为黑色模式？"><a href="#如何将页面背景改为黑色模式？" class="headerlink" title="如何将页面背景改为黑色模式？"></a>如何将页面背景改为黑色模式？</h3><p>修改 Next 主题下的 _config.yml 配置文件：将 darkmode 的值修改为 true 。</p><p>如果主界面已经设置了 hexo-tag-cloud 标签云的展示，那么修改博客站点的配置文件，</p><p>_config.yml 中标签云模块下的 textColor 更改为 ‘#FFFFFF’ # 白色，或者其他颜色即可。</p><hr><h3 id="如何为页面添加当前浏览进度？"><a href="#如何为页面添加当前浏览进度？" class="headerlink" title="如何为页面添加当前浏览进度？"></a>如何为页面添加当前浏览进度？</h3><p>修改 Next 主题下的 _config.yml 配置文件：</p><p>将 back2top 中的 enable 和 scrollpercent 值修改为 true 。</p><hr><h3 id="如何将页面的首页更改为归档？"><a href="#如何将页面的首页更改为归档？" class="headerlink" title="如何将页面的首页更改为归档？"></a>如何将页面的首页更改为归档？</h3><p>修改 Next 主题下的 _config.yml 配置文件：</p><p>将 menu 下的 home 路径修改为 archive 即可，同时注释掉 archive。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: <span class="regexp">/archives/</span> || fa fa-archive</span><br><span class="line">  <span class="attr">about</span>: <span class="regexp">/about/</span> || fa fa-user</span><br><span class="line">  <span class="attr">tags</span>: <span class="regexp">/tags/</span> || fa fa-tags</span><br><span class="line">  <span class="attr">categories</span>: <span class="regexp">/categories/</span> || fa fa-th</span><br><span class="line">  #archives: <span class="regexp">/archives/</span> || fa fa-archive</span><br><span class="line">  #schedule: <span class="regexp">/schedule/</span> || fa fa-calendar</span><br><span class="line">  #sitemap: /sitemap.xml || fa fa-sitemap</span><br><span class="line">  #commonweal: <span class="regexp">/404/</span> || fa fa-heartbeat</span><br></pre></td></tr></table></figure><p><em>（提醒：如果担心更改错误，备份原文件）</em></p><hr><h3 id="如何为页面添加加载特效？"><a href="#如何为页面添加加载特效？" class="headerlink" title="如何为页面添加加载特效？"></a>如何为页面添加加载特效？</h3><p>参考文章：<a><a href="https://juejin.cn/post/6844903789946896398">Hexo博客NexT主题美化之顶部加载进度条 - 掘金 (juejin.cn)</a></a></p><hr>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本概念</title>
      <link href="/2021/11/29/Java%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2021/11/29/Java%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><span id="more"></span><h3 id="Java语言有哪些优点？"><a href="#Java语言有哪些优点？" class="headerlink" title="Java语言有哪些优点？"></a>Java语言有哪些优点？</h3><ol><li><p>Java为纯面向对象的语言</p></li><li><p>平台无关性</p></li><li><p>Java提供了很多内置的类库</p></li><li><p>提供了对Web应用开发的支持</p></li><li><p>具有较好的安全性和健壮性</p></li><li><p>去除了C++语言中难以理解、容易混淆的特性</p><p><strong>说明：Java语言是由C++语言改进并重新设计而来的</strong></p></li></ol><hr><h3 id="Java与C、C-有什么异同"><a href="#Java与C、C-有什么异同" class="headerlink" title="Java与C、C++有什么异同"></a>Java与C、C++有什么异同</h3><ol><li><p><strong>Java为半编译半解释型语言，而C / C++为编译型语言</strong></p><ul><li>Java程序源代码先经过Java编译器编译成字节码，然后由JVM解释执行</li><li>C / C++程序源代码经过编译和链接后生成可执行的二进制代码</li></ul><p>因此C / C++的执行速度比Java快，但是Java因为JVM可以跨平台执行。</p></li><li><p><strong>Java为纯面向对象的语言，而C++兼具面向过程和面向对象的特点</strong></p><ul><li>Java中除了基本数据类型，所有类型都是类</li><li>Java语言中不存在全局变量或者全局函数</li></ul></li><li><p><strong>Java没有多重继承，但是可以实现多个接口</strong></p></li><li><p><strong>Java语言提供了垃圾回收器来实现垃圾的自动回收</strong></p><ul><li>C++语言中，需要开发人员去管理对内存的分配（申请与释放）</li><li>Java的GC机制，不需要开发人员去关心内存空间</li></ul></li><li><p><strong>Java具有平台无关性</strong></p><ul><li>Java中每种基本类型数据都分配固定长度</li><li>C / C++中在不同的平台会分配不同的字节数</li></ul></li><li><p><strong>其他不同的地方</strong></p><ol><li>Java不支持运算符重载</li><li>Java没有预处理器，但是提供 import 机制</li><li>Java不支持默认函数参数</li><li>Java不提供 goto 语句，但是做为保留关键字</li><li>Java不提供自动强制类型转化，需要显示转换</li><li>Java不包含结构和联合，所有内容封装在类里面</li><li>Java没有指针的概念，避免指针引起的系统问题</li><li>Java提供了一些标准库，用于完成特定的任务，比如 JDBC</li></ol></li></ol><p><strong>常见的一个错误说法：Java语言中的方法属于类的成员</strong></p><p>静态方法：类成员</p><p>非静态方法：实例成员</p><hr><h3 id="为什么需要-main-方法"><a href="#为什么需要-main-方法" class="headerlink" title="为什么需要 main 方法"></a>为什么需要 main 方法</h3><p><code>public static void main(String args[]) &#123;&#125;</code></p><ol><li><p>该方法为Java程序的入口方法，JVM在运行程序时，会首先查找 main() 方法</p></li><li><p>字符串数组 args 为开发人员在命令行状态下与程序交互提供了一种手段</p></li><li><p>因为 main() 方法是程序的入口，要执行一个类的方法，就必须实例化一个对象，</p><p>此时还没有实例化对象，所以该方法需要被定义成 public 和 static </p></li><li><p>main() 方法其他可用的定义格式：</p><p><em><strong>说明：public 和 static 的位置可以互换，没有先后关系</strong></em></p><ol><li><code>static public void main(String args[]) &#123;&#125;</code></li><li><code>public static final void main(String args[]) &#123;&#125;</code></li><li><code>public static synchronized void main(String args[]) &#123;&#125;</code></li></ol><p><strong>但是不可以用 abstract 关键字修饰，因为该函数为程序的入口方法</strong></p></li></ol><hr><h3 id="一个Java文件中是否可以定义多个类"><a href="#一个Java文件中是否可以定义多个类" class="headerlink" title="一个Java文件中是否可以定义多个类"></a>一个Java文件中是否可以定义多个类</h3><ol><li>可以定义多个类，但是<strong>最多只能有一个被 public 修饰的类</strong>，并且该类与文件名相同</li><li>如果没有 public 类，那么文件名随便一个类的名字即可</li><li>当编译此文件时，每一个类都会生成一个对应的字节码文件 .class</li><li><strong>普通方法可以与构造函数有相同的方法名</strong></li></ol><hr><h3 id="Java程序初始化的顺序"><a href="#Java程序初始化的顺序" class="headerlink" title="Java程序初始化的顺序"></a>Java程序初始化的顺序</h3><p>在Java语言中，当实例化对象时，对象所在类的所有成员变量首先要进行初始化，</p><p>只有当所有类成员完成初始化后，才会调用对象所在类的构造函数创建对象。</p><p><strong>程序初始化一般遵循三个原则（优先级依次递减）：</strong></p><ol><li>静态对象（变量）优先于非静态</li><li>父类优先于子类</li><li>按照成员变量的定义顺序进行初始化</li></ol><p><strong>具体的执行顺序如下：</strong></p><p>父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、</p><p>父类非静态变量、父类非静态代码块、父类构造函数、</p><p>子类非静态变量、子类非静态代码块、子类构造函数。</p><p><strong>示例代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Load B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Create B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Load B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Load A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Create A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>程序运行结果是：</strong>Load B    Load B    Load A    Create B    Create A</p><hr><h3 id="Java中的作用域"><a href="#Java中的作用域" class="headerlink" title="Java中的作用域"></a>Java中的作用域</h3><table><thead><tr><th align="center">作用域与可见性</th><th align="center">当前类</th><th align="center">同一package</th><th align="center">子类</th><th align="center">其他package</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">protected</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">default</td><td align="center">√</td><td align="center">√</td><td align="center">×</td><td align="center">×</td></tr><tr><td align="center">private</td><td align="center">√</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><p>注意：private 和 protected 不能用来修饰类</p><hr><h3 id="Java中的标识接口"><a href="#Java中的标识接口" class="headerlink" title="Java中的标识接口"></a>Java中的标识接口</h3><p>标识接口：没有任何方法声明的接口</p><p>作用：仅仅充当一个标识作用，用来表明实现它的类属于一个特定的类型</p><hr><h3 id="Java中的clone方法"><a href="#Java中的clone方法" class="headerlink" title="Java中的clone方法"></a>Java中的clone方法</h3><p>实际编程中，需要从某个已有的对象 A 创建处另外一个与 A 具有相同状态的对象 B，</p><p>并且对 B 的修改不会影响到 A 的自身状态，因此提供了 clone 方法返回一个新的对象。</p><p><strong>使用clone方法的步骤：</strong></p><ol><li>实现clone的类首先需要继承 Cloneable 接口</li><li>在类中重写 Object 类中的 clone() 方法</li><li>在 clone() 方法章调用 super.clone() <strong>（浅复制）</strong></li><li>对对象中的非基本类型的属性也调用 clone() 方法 <strong>（深复制）</strong></li><li>把复制的引用指向原型对象新的克隆体</li></ol><p><strong>示例代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date birth = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getBirth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birth.setMonth(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Obj o = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 实现浅复制</span></span><br><span class="line">            o = (Obj) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现深复制</span></span><br><span class="line">        o.birth = (Date) <span class="keyword">this</span>.getBirth().clone();</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Obj a = <span class="keyword">new</span> Obj();</span><br><span class="line">        Obj b = (Obj)a.clone();</span><br><span class="line">        b.changeDate();</span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span> + a.getBirth());</span><br><span class="line">        System.out.println(<span class="string">&quot;b = &quot;</span> + b.getBirth());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>程序运行结果是：</strong></p><p>a = Mon Nov 29 19:05:03 CST 2021<br>b = Sat May 29 19:05:03 CST 2021</p><hr><h3 id="Java创建对象的四种方式"><a href="#Java创建对象的四种方式" class="headerlink" title="Java创建对象的四种方式"></a>Java创建对象的四种方式</h3><ol><li>通过 new 语句实例化一个对象</li><li>通过反射机制创建对象</li><li>通过 clone() 方法创建一个对象</li><li>通过反序列化的方式船舰一个对象</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Next的基础搭建</title>
      <link href="/2021/11/27/Hexo%E7%9A%84%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/"/>
      <url>/2021/11/27/Hexo%E7%9A%84%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="Hexo-Next的基础搭建"><a href="#Hexo-Next的基础搭建" class="headerlink" title="Hexo Next的基础搭建"></a>Hexo Next的基础搭建</h3><span id="more"></span><h3 id="如何通过GitHub搭建Hexo博客？"><a href="#如何通过GitHub搭建Hexo博客？" class="headerlink" title="如何通过GitHub搭建Hexo博客？"></a>如何通过GitHub搭建Hexo博客？</h3><p>推荐UP主 CodeSheep 的这期视频：<a><a href="https://www.bilibili.com/video/BV1Yb411a7ty?from=search&seid=12143109252670934815&spm_id_from=333.337.0.0">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo_哔哩哔哩_bilibili</a></a></p><p><em>（讲的很详细，并且其他视频对于初学者都很有帮助）</em></p><p><strong>补充：这里如果windows下的cmd操作不适配，推荐下载使用Git，仿照视频操作。</strong></p><hr><h3 id="如何添加-分类-标签-模块？"><a href="#如何添加-分类-标签-模块？" class="headerlink" title="如何添加 分类 | 标签 模块？"></a>如何添加 分类 | 标签 模块？</h3><p>推荐文章：<a><a href="https://juejin.cn/post/6921750181297782798">Hexo添加分类及标签（在Next主题下） - 掘金 (juejin.cn)</a></a></p><p><strong>补充：文章只能属于一个分类，但是可以属于多个标签。</strong></p><hr><h3 id="如何在文章内部署图片？"><a href="#如何在文章内部署图片？" class="headerlink" title="如何在文章内部署图片？"></a>如何在文章内部署图片？</h3><p>推荐文章：<a><a href="https://www.jianshu.com/p/f72aaad7b852">HEXO插入图片（详细版） - 简书 (jianshu.com)</a></a></p><p><strong>补充：</strong></p><ol><li><p>此方法插入图片时，typora或者其他markdown软件中，不可见图片，但是网页部署会出现，</p><p>这里推荐文章：<a>hexo博客如何插入图片 - 知乎 (zhihu.com)](<a href="https://zhuanlan.zhihu.com/p/265077468">https://zhuanlan.zhihu.com/p/265077468</a>)</a>的第三点说明。</p></li><li><p>在执行npm的时候可能会报错，参考下面文章依据情况解决：</p><p><a><a href="https://blog.csdn.net/zzq00zzj/article/details/120826520?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link">(13条消息) npm install报错 npm ERR! 的四种解决办法_zzq00zzj的博客-CSDN博客</a></a></p></li></ol><hr><h3 id="如何添加访客统计和文章阅读次数？"><a href="#如何添加访客统计和文章阅读次数？" class="headerlink" title="如何添加访客统计和文章阅读次数？"></a>如何添加访客统计和文章阅读次数？</h3><p>推荐文章：<a><a href="https://blog.csdn.net/baidu_34310405/article/details/102665373">(13条消息) Hexo Next主题添加访客统计、访问次数统计、文章阅读次数统计_AcLings的博客-CSDN博客</a></a></p><hr><h3 id="如何美化代码块以-Mac-Pane的风格？"><a href="#如何美化代码块以-Mac-Pane的风格？" class="headerlink" title="如何美化代码块以 Mac Pane的风格？"></a>如何美化代码块以 Mac Pane的风格？</h3><p>推荐文章：<a><a href="https://miaosakurai.com/2020/04/20/Hexo-NexT%E7%BE%8E%E5%8C%96%F0%9F%8D%95Mac-Panel%E9%A3%8E%E6%A0%BC%E4%BB%A3%E7%A0%81%E5%9D%97%E9%85%8D%E7%BD%AE/">Hexo+NexT美化🍕Mac Panel风格代码块配置 | 樱井喵 (miaosakurai.com)</a></a></p><hr><h3 id="如何添加-标签云模块-博客背景-搜索功能-模块？"><a href="#如何添加-标签云模块-博客背景-搜索功能-模块？" class="headerlink" title="如何添加 标签云模块 |博客背景 |搜索功能 模块？"></a>如何添加 标签云模块 |博客背景 |搜索功能 模块？</h3><p>推荐博主：<a><a href="https://vic.kim/">归档 | Vicの博客</a></a></p><p><strong>补充：标签云至少存在两个标签才会生效显示</strong></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>祖玛游戏</title>
      <link href="/2021/11/25/%E7%A5%96%E7%8E%9B%E6%B8%B8%E6%88%8F/"/>
      <url>/2021/11/25/%E7%A5%96%E7%8E%9B%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="祖玛游戏（-搜索剪枝-记忆化搜索）"><a href="#祖玛游戏（-搜索剪枝-记忆化搜索）" class="headerlink" title="祖玛游戏（ 搜索剪枝 | 记忆化搜索）"></a>祖玛游戏（ 搜索剪枝 | 记忆化搜索）</h3><span id="more"></span><blockquote><blockquote><p>祖玛游戏的最小步数求解</p><p>题目详情参见：<a><a href="https://leetcode-cn.com/problems/zuma-game/">488. 祖玛游戏 - 力扣（LeetCode） (leetcode-cn.com)</a></a></p></blockquote></blockquote><h3 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h3><ol><li><p>因为插入球的选择和颜色情况太多，并且所带来的影响可能是在多次操作后才能体现出来，</p><p>因此倘若使用贪心算法，很难建立起全局最优的决策，故而不采用贪心；</p></li><li><p>因此需要对状态空间进行枚举，通过穷尽所有的可能来找到最优解，</p><p>并使用剪枝的方法来优化搜索过程；</p></li><li><p>如果使用深度优先搜索，则需要使用记忆化搜索，以避免重复计算相同的状态；</p></li><li><p>该题目只需要得到回合数最少的方案，因此广度优先搜索即可;</p></li><li><p>设当前桌面上有 n 个球，手中持有 m 个球，<br>  $$<br>  则此时一共有C^m_{m+n} * m! = A^m_{m+n}种插入方法<br>  $$</p></li></ol><h3 id="解法一：BFS-剪枝"><a href="#解法一：BFS-剪枝" class="headerlink" title="解法一：BFS + 剪枝"></a>解法一：BFS + 剪枝</h3><p>思路：不妨规定，每一种不同的桌面上球的情况和手中球的情况的组合都是一种不同的状态，</p><p>​            然后对状态空间进行枚举，即可得解答；</p><p><strong>在搜索过程中，需要剪枝来简化算法的复杂性:</strong></p><ul><li>手中颜色相同的球每次选择时只需要考虑其中一个即可；</li><li>只在连续相同颜色的球的开头位置或者结尾位置插入新的颜色相同的球；</li><li>只考虑放置新球后有可能得到更优解的位置，以下三种情况：<ol><li>插入新球与插入位置右侧的球颜色相同</li><li>插入新球与插入位置两侧的球颜色均不相同，且插入位置两侧的球的颜色不同</li><li>插入新球与插入位置两侧的球颜色均不相同，且插入位置两侧的球的颜色相同</li><li>对于如果手中的球全部插入也无法满足新的消除，则直接进行中止</li></ol></li></ul><p><strong>当然还可以有更多的剪枝技巧。</strong></p><p>具体实现的细节处理：</p><ol><li><p>消除操作后，如果导致出现了新的连续三个以上颜色相同的球，</p><p>则继续消除这些球，直到不再满足消除条件；</p></li><li><p>消除时利用栈的特性，每次遇到连续可以消除的球时，将其从栈中弹出；</p></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinStep</span><span class="params">(String board, String hand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] arr = hand.toCharArray();</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        hand = <span class="keyword">new</span> String(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化用队列维护的状态队列：其中的三个元素分别为桌面球状态、手中球状态和回合数</span></span><br><span class="line">        Queue&lt;State&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;State&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> State(board, hand, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化用哈希集合维护的已访问过的状态</span></span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        visited.add(board + <span class="string">&quot; &quot;</span> + hand);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            State state = queue.poll();</span><br><span class="line">            String curBoard = state.board;</span><br><span class="line">            String curHand = state.hand;</span><br><span class="line">            <span class="keyword">int</span> step = state.step;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= curBoard.length(); ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; curHand.length(); ++j) &#123;</span><br><span class="line">                    <span class="comment">// 第 1 个剪枝条件: 当前球的颜色和上一个球的颜色相同</span></span><br><span class="line">                    <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; curHand.charAt(j) == curHand.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 第 2 个剪枝条件: 只在连续相同颜色的球的开头位置插入新球</span></span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; curBoard.charAt(i - <span class="number">1</span>) == curHand.charAt(j)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 第 3 个剪枝条件: 只在以下两种情况放置新球</span></span><br><span class="line">                    <span class="keyword">boolean</span> choose = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">//  - 第 1 种情况 : 当前球颜色与后面的球的颜色相同</span></span><br><span class="line">                    <span class="keyword">if</span> (i &lt; curBoard.length() &amp;&amp; curBoard.charAt(i) == curHand.charAt(j)) &#123;</span><br><span class="line">                        choose = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//  - 第 2 种情况 : 当前后颜色相同且与当前颜色不同时候放置球</span></span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; i &lt; curBoard.length() &amp;&amp; </span><br><span class="line">                        curBoard.charAt(i - <span class="number">1</span>) == curBoard.charAt(i) &amp;&amp; </span><br><span class="line">                        curBoard.charAt(i - <span class="number">1</span>) != curHand.charAt(j)) &#123;</span><br><span class="line">                        choose = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (choose) &#123;</span><br><span class="line">                        String newBoard = clean(curBoard.substring(<span class="number">0</span>, i) + </span><br><span class="line">                                                curHand.charAt(j) + curBoard.substring(i));</span><br><span class="line">                        String newHand = curHand.substring(<span class="number">0</span>, j) + curHand.substring(j + <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">if</span> (newBoard.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        String str = newBoard + <span class="string">&quot; &quot;</span> + newHand;</span><br><span class="line">                        <span class="keyword">if</span> (visited.add(str)) &#123;</span><br><span class="line">                            queue.offer(<span class="keyword">new</span> State(newBoard, newHand, step + <span class="number">1</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">clean</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        Deque&lt;Character&gt; letterStack = <span class="keyword">new</span> ArrayDeque&lt;Character&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; countStack = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">while</span> (!letterStack.isEmpty() &amp;&amp; c != letterStack.peek() &amp;&amp; countStack.peek() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                letterStack.pop();</span><br><span class="line">                countStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (letterStack.isEmpty() || c != letterStack.peek()) &#123;</span><br><span class="line">                letterStack.push(c);</span><br><span class="line">                countStack.push(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                countStack.push(countStack.pop() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!countStack.isEmpty() &amp;&amp; countStack.peek() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">            letterStack.pop();</span><br><span class="line">            countStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!letterStack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">char</span> letter = letterStack.pop();</span><br><span class="line">            <span class="keyword">int</span> count = countStack.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">                sb.append(letter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.reverse();</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    String board;</span><br><span class="line">    String hand;</span><br><span class="line">    <span class="keyword">int</span> step;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">State</span><span class="params">(String board, String hand, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.board = board;</span><br><span class="line">        <span class="keyword">this</span>.hand = hand;</span><br><span class="line">        <span class="keyword">this</span>.step = step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(m×n×A^n_{m+n})\<br>&amp;空间复杂度:O((m+n)×A^m_{m+n})<br>\end{align}<br>$$</p><hr><h3 id="解法二：记忆化搜索（AStar算法）"><a href="#解法二：记忆化搜索（AStar算法）" class="headerlink" title="解法二：记忆化搜索（AStar算法）"></a>解法二：记忆化搜索（AStar算法）</h3><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Integer&gt; dp = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinStep</span><span class="params">(String board, String hand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] arr = hand.toCharArray();</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        hand = <span class="keyword">new</span> String(arr);</span><br><span class="line">        <span class="keyword">int</span> ans = dfs(board, hand);</span><br><span class="line">        <span class="keyword">return</span> ans &lt;= <span class="number">5</span> ? ans : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(String board, String hand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String key = board + <span class="string">&quot; &quot;</span> + hand;</span><br><span class="line">        <span class="keyword">if</span> (!dp.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">6</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; hand.length(); ++j) &#123;</span><br><span class="line">                <span class="comment">// 第 1 个剪枝条件: 当前球的颜色和上一个球的颜色相同</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; hand.charAt(j) == hand.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= board.length(); ++i) &#123;</span><br><span class="line">                    <span class="comment">// 第 2 个剪枝条件: 只在连续相同颜色的球的开头位置插入新球</span></span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; board.charAt(i - <span class="number">1</span>) == hand.charAt(j)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 第 3 个剪枝条件: 只在以下两种情况放置新球</span></span><br><span class="line">                    <span class="keyword">boolean</span> choose = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">//  - 第 1 种情况 : 当前球颜色与后面的球的颜色相同</span></span><br><span class="line">                    <span class="keyword">if</span> (i &lt; board.length() &amp;&amp; board.charAt(i) == hand.charAt(j)) &#123;</span><br><span class="line">                        choose = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//  - 第 2 种情况 : 当前后颜色相同且与当前颜色不同时候放置球</span></span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; i &lt; board.length() &amp;&amp; </span><br><span class="line">                        board.charAt(i - <span class="number">1</span>) == board.charAt(i) &amp;&amp; </span><br><span class="line">                        board.charAt(i - <span class="number">1</span>) != hand.charAt(j)) &#123;</span><br><span class="line">                        choose = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (choose) &#123;</span><br><span class="line">                        String newBoard = clean(board.substring(<span class="number">0</span>, i) + </span><br><span class="line">                                                hand.charAt(j) + board.substring(i));</span><br><span class="line">                        String newHand = hand.substring(<span class="number">0</span>, j) + hand.substring(j + <span class="number">1</span>);</span><br><span class="line">                        res = Math.min(res, dfs(newBoard, newHand) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp.put(key, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">clean</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        Deque&lt;Character&gt; letterStack = <span class="keyword">new</span> ArrayDeque&lt;Character&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; countStack = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">while</span> (!letterStack.isEmpty() &amp;&amp; c != letterStack.peek() &amp;&amp; countStack.peek() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                letterStack.pop();</span><br><span class="line">                countStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (letterStack.isEmpty() || c != letterStack.peek()) &#123;</span><br><span class="line">                letterStack.push(c);</span><br><span class="line">                countStack.push(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                countStack.push(countStack.pop() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!countStack.isEmpty() &amp;&amp; countStack.peek() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">            letterStack.pop();</span><br><span class="line">            countStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!letterStack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">char</span> letter = letterStack.pop();</span><br><span class="line">            <span class="keyword">int</span> count = countStack.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">                sb.append(letter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.reverse();</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    String board;</span><br><span class="line">    String hand;</span><br><span class="line">    <span class="keyword">int</span> step;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">State</span><span class="params">(String board, String hand, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.board = board;</span><br><span class="line">        <span class="keyword">this</span>.hand = hand;</span><br><span class="line">        <span class="keyword">this</span>.step = step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(m×n×A^n_{m+n})\<br>&amp;空间复杂度:O((m+n)×A^m_{m+n})<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 广度优先搜索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维 接雨水</title>
      <link href="/2021/11/25/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E2%85%A1/"/>
      <url>/2021/11/25/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E2%85%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="二维-接雨水（-最小堆-广度优先搜索-）"><a href="#二维-接雨水（-最小堆-广度优先搜索-）" class="headerlink" title="二维 接雨水（ 最小堆 | 广度优先搜索 ）"></a>二维 接雨水（ 最小堆 | 广度优先搜索 ）</h3><span id="more"></span><blockquote><blockquote><p>给你一个 <code>m x n</code> 的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: heightMap = <span class="string">[[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]</span></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure><p>题目详情参见: <a><a href="https://leetcode-cn.com/problems/trapping-rain-water-ii/">407. 接雨水 II - 力扣（LeetCode） (leetcode-cn.com)</a></a></p></blockquote></blockquote><h3 id="解法一：模拟遍历（参照接雨水Ⅰ）"><a href="#解法一：模拟遍历（参照接雨水Ⅰ）" class="headerlink" title="解法一：模拟遍历（参照接雨水Ⅰ）"></a>解法一：模拟遍历（参照接雨水Ⅰ）</h3><p>思路：一维转化为二维，那么是否可以同样的思路去解答？</p><ol><li>对于每个点，寻找所在行左右最大值的最小值，寻找所在列上下最大值的最小值；</li><li>然后取这两个值的最小值，减去当前位置的高度，即为此位置接雨水量。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trapRainWater</span><span class="params">(<span class="keyword">int</span>[][] heightMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = heightMap.length;</span><br><span class="line">        <span class="keyword">int</span> col = heightMap[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> curr = heightMap[i][j];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> minRow = getMinRow(heightMap,i,j,col);</span><br><span class="line">                <span class="keyword">int</span> minCol = getMinCol(heightMap,i,j,row);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果均大于当前位置，那么可以接雨水</span></span><br><span class="line">                <span class="keyword">if</span>(minCol &gt; curr &amp;&amp; minRow &gt; curr) &#123;</span><br><span class="line">                    ans += Math.min(minRow,minCol);</span><br><span class="line">                    ans -= heightMap[i][j];</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找所在行的左右最大值的最小值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMinRow</span><span class="params">(<span class="keyword">int</span>[][] heightMap,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftMax = heightMap[x][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> rightMax = heightMap[x][col - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; y; k++) &#123;</span><br><span class="line">            leftMax = Math.max(leftMax,heightMap[x][k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = y; k &lt; col; k++) &#123;</span><br><span class="line">            rightMax = Math.max(rightMax,heightMap[x][k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(leftMax,rightMax);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找所在列的上下最大值的最小值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMinCol</span><span class="params">(<span class="keyword">int</span>[][] heightMap,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> upMax = heightMap[<span class="number">0</span>][y];</span><br><span class="line">        <span class="keyword">int</span> downMax = heightMap[row - <span class="number">1</span>][y];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; x; k++) &#123;</span><br><span class="line">            upMax = Math.max(upMax,heightMap[k][y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = x; k &lt; row; k++) &#123;</span><br><span class="line">             downMax = Math.max(downMax,heightMap[k][y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(upMax,downMax);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个思路解答是错误的，因为当前位置可能会溢出流向其他区域！</p><p>比如：<code>[[12,13,1,12],[13,4,13,12],[13,8,10,12],[12,13,12,12],[13,13,13,13]]</code></p><p>按照上述做法的答案<code>15</code>，正确答案<code>14</code>。</p><p><strong>因此该方块自身的高度比其上下左右四个相邻的方块接水后的高度都要低。</strong></p><hr><h3 id="解法二：最小堆"><a href="#解法二：最小堆" class="headerlink" title="解法二：最小堆"></a>解法二：最小堆</h3><p>思路：反思解法一的过程，思考总结什么样的方块能接水?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 该方块不为最外层的方块；</span><br><span class="line">- 该方块自身的高度比其上下左右四个相邻的方块接水后的高度都要低；</span><br></pre></td></tr></table></figure><ol><li><p>假设方块的索引为 <em>(i,j)</em>，方块的高度为 <em>heightMap[i][j]</em>，方块接水后的高度为 <em>water[i][j]</em>；</p></li><li><p>并且 <em>water[i][j] = max(heightMap[i][j], min(water[i−1][j], water[i+1][j], water[i][j−1], water[i][j+1]))</em>；</p></li><li><p>因此方块 <em>(i,j)</em> 实际接水的容量计算公式为 <em>water[i][j] − heightMap[i][j]</em>;</p></li><li><p>因为最外层的方块无法接水，因此最外层的方块 <em>water[i][j] = heightMap[i][j]</em>;</p></li><li><p>根据木桶原理，接到的雨水的高度由这个容器周围最短的木板来确定的,</p><p>因此容器内水的高度取决于最外层高度最低的方块；</p></li><li><p>确定最小高度方块的相邻方块的接水高度，我们同时更新最外层的方块标记，</p><p>在新的最外层的方块再次找到接水后的高度的最小值，同时确定与其相邻的方块的接水高度；</p></li><li><p>依次迭代求出所有方块的接水，即可得解。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trapRainWater</span><span class="params">(<span class="keyword">int</span>[][] heightMap)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方块数小于4，无法接水</span></span><br><span class="line">        <span class="keyword">if</span> (heightMap.length &lt;= <span class="number">2</span> || heightMap[<span class="number">0</span>].length &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = heightMap.length;</span><br><span class="line">        <span class="keyword">int</span> n = heightMap[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 访问过的结点</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] visit = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o1[<span class="number">1</span>] - o2[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || i == m - <span class="number">1</span> || j == <span class="number">0</span> || j == n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// i * n + j代表第几个</span></span><br><span class="line">                    pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i * n + j, heightMap[i][j]&#125;);</span><br><span class="line">                    visit[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dirs = &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] curr = pq.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                <span class="comment">// 第几个取位置，/n是行数，%n是列数</span></span><br><span class="line">                <span class="keyword">int</span> nx = curr[<span class="number">0</span>] / n + dirs[k];</span><br><span class="line">                <span class="keyword">int</span> ny = curr[<span class="number">0</span>] % n + dirs[k + <span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 不越界并且没有被访问过</span></span><br><span class="line">                <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; n &amp;&amp; !visit[nx][ny]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (curr[<span class="number">1</span>] &gt; heightMap[nx][ny]) &#123;</span><br><span class="line">                        res += curr[<span class="number">1</span>] - heightMap[nx][ny];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 更新边界</span></span><br><span class="line">                    pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nx * n + ny, Math.max(heightMap[nx][ny], curr[<span class="number">1</span>])&#125;);</span><br><span class="line">                    <span class="comment">// 将访问过的位置设置为true</span></span><br><span class="line">                    visit[nx][ny] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(MNlog(M+N))\<br>&amp;空间复杂度:O(MN)<br>\end{align}<br>$$</p><hr><h3 id="解法三：广度优先搜索"><a href="#解法三：广度优先搜索" class="headerlink" title="解法三：广度优先搜索"></a>解法三：广度优先搜索</h3><p>思路:    让区域都接满水，因此此时每一块的高度都是 <code>maxHeight</code>，为区域中最高值，</p><p>​             然后让其顺着低处自然流出，因此需要广度优先搜索；</p><ol><li><p>假设初始时矩阵的每个格子都接满了水，且高度均为 <em>maxHeight</em>，区域中的最高值；</p></li><li><p>同解法二：<em>water[i][j] = max(heightMap[i][j], min(water[i−1][j], water[i+1][j], water[i][j−1], water[i][j+1]))</em>；</p></li><li><p>方块 <em>(i,j)</em> 实际接水的容量计算公式为 <em>water[i][j] − heightMap[i][j]</em>;</p></li><li><p>每次发现当前方块 <em>(i,j)</em> 的接水高度 <em>water[i][j]</em> 小于与它相邻的 4 个模块的接水高度时，</p><p>则我们将进行调整接水高度，将其相邻的四个方块的接水高度调整与 (<em>i</em>,<em>j</em>) 的高度保持一致；</p></li><li><p>不断重复的进行调整，直到所有的方块的接水高度不再有调整时即为满足要求。</p></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trapRainWater</span><span class="params">(<span class="keyword">int</span>[][] heightMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = heightMap.length;</span><br><span class="line">        <span class="keyword">int</span> n = heightMap[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] dirs = &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> maxHeight = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                maxHeight = Math.max(maxHeight, heightMap[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] water = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                water[i][j] = maxHeight;      </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; qu = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || i == m - <span class="number">1</span> || j == <span class="number">0</span> || j == n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (water[i][j] &gt; heightMap[i][j]) &#123;</span><br><span class="line">                        water[i][j] = heightMap[i][j];</span><br><span class="line">                        qu.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">while</span> (!qu.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] curr = qu.poll();</span><br><span class="line">            <span class="keyword">int</span> x = curr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = curr[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = x + dirs[i], ny = y + dirs[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= m || ny &lt; <span class="number">0</span> || ny &gt;= n) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (water[x][y] &lt; water[nx][ny] &amp;&amp; water[nx][ny] &gt; heightMap[nx][ny]) &#123;</span><br><span class="line">                    water[nx][ny] = Math.max(water[x][y], heightMap[nx][ny]);</span><br><span class="line">                    qu.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nx, ny&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                res += water[i][j] - heightMap[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(M^2N^2)\<br>&amp;空间复杂度:O(MN)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 优先队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一维 接雨水</title>
      <link href="/2021/11/24/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E2%85%A0/"/>
      <url>/2021/11/24/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E2%85%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="一维-接雨水（-模拟-动态规划-双指针-单调栈-）"><a href="#一维-接雨水（-模拟-动态规划-双指针-单调栈-）" class="headerlink" title="一维 接雨水（ 模拟 | 动态规划 | 双指针 | 单调栈 ）"></a>一维 接雨水（ 模拟 | 动态规划 | 双指针 | 单调栈 ）</h3><span id="more"></span><blockquote><blockquote><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p>示例：输入 <code>height = [0,1,0,2,1,0,1,3,2,1,2,1]</code> ，输出 <code>6</code></p><p>题目详情参见 <a><a href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水 - 力扣（LeetCode） (leetcode-cn.com)</a></a></p></blockquote></blockquote><h3 id="解法一：模拟遍历"><a href="#解法一：模拟遍历" class="headerlink" title="解法一：模拟遍历"></a>解法一：模拟遍历</h3><p>思路：</p><ol><li>不妨设数组的长度为 <code>n</code> ，那么从下标 <code>1</code> 到 <code>n - 1</code> 进行遍历；</li><li>对于每个下标 <code>i</code> ，分别向左向右搜索最大值，然后取二者的最小值；</li><li>将此最小值减去 <code>height[i]</code>，即为此下标所能接的雨水数；</li><li>遍历求和，即可得到正确的解答。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> size = height.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> max_left = <span class="number">0</span>, max_right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123; <span class="comment">// 寻找左部最大值</span></span><br><span class="line">            max_left = Math.max(max_left, height[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; size; j++) &#123; <span class="comment">// 寻找右部最大值</span></span><br><span class="line">            max_right = Math.max(max_right, height[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans += Math.min(max_left, max_right) - height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度: O(n^2)\<br>&amp;空间复杂度: O(1)<br>\end{align}<br>$$</p><hr><h3 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h3><p>思路：在解法一（模拟遍历）的时候，每次都需要向左向右进行搜寻，不妨简化这个搜寻过程，从而降低时间复杂度。</p><ol><li>开辟两个数组 <em>leftMax、rightMax</em>，分别记录左边的最大值和右边的最大值；</li><li>因为两个数组记录的值意义不同，所以进行不同的遍历，得到两个数组的值；</li><li><strong>正向遍历得到 <em>leftMax</em>, 反向遍历得到 <em>rightMax</em> ;</strong></li><li>然后从下标 <code>1</code> 到 <code>n - 1</code> 进行遍历求解。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = height.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正向遍历得到左边最大值</span></span><br><span class="line">        <span class="keyword">int</span>[] leftMax = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        leftMax[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            leftMax[i] = Math.max(leftMax[i - <span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反向遍历得到右边最大值</span></span><br><span class="line">        <span class="keyword">int</span>[] rightMax = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        rightMax[n - <span class="number">1</span>] = height[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            rightMax[i] = Math.max(rightMax[i + <span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求和得解</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans += Math.min(leftMax[i], rightMax[i]) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度: O(n)\<br>&amp;空间复杂度: O(n)<br>\end{align}<br>$$</p><hr><h3 id="解法三：双指针"><a href="#解法三：双指针" class="headerlink" title="解法三：双指针"></a>解法三：双指针</h3><p>思路：解法二（动态规划）优化了模拟遍历，但是额外了开辟了空间，那么如何减少空间开辟？</p><ol><li><p><strong>使用双指针和两个变量代替正反遍历得到的两个数组；</strong></p></li><li><p>双指针 <em>left、right</em>, 两个变量 <em>leftMax，rightMax</em>;</p></li><li><p>当两个指针在移动的过程中，进行以下操作：</p><ol><li><p>使用 <em>height[left]，height[right]</em> 更新 <em>leftMax，rightMax</em> 的值；</p></li><li><p>如果 <em>height[left] &lt; height[right]</em>, 那么一定有 <em>leftMax &lt; rightMax</em>，</p><p>下标 <em>left</em> 处的接水量就等于 <em>leftMax - height[left]</em>，然后 <em>left</em> 右移一位；</p><p><a href="#1">（原因解释）</a></p></li><li><p>如果 <em>height[left] ≥ height[right]</em>, 那么一定有 <em>leftMax ≥ rightMax</em>，</p><p>下标 <em>right</em> 处的接水量就等于 <em>rightMax - height[right]</em>，然后 <em>right</em> 左移一位；</p></li></ol></li><li><p>当两个指针相遇时，即可得到接雨水的总量。</p></li></ol><p><strong><a id="1">为什么”一定有”的解释说明：</a></strong></p><blockquote><p>左指针右移的终止条件是找到比 <em>rightMax</em> 大的 <em>leftMax</em>，</p><p>也就是说一旦左指针终止左移，此时的<em>height[left]</em> 一定是 <em>leftMax</em>，且大于 <em>rightMax</em>。</p><p>同理，右指针左移的终止条件是找到比 <em>leftMax</em> 大的 <em>rightMax</em>，</p><p>而此时的 <em>height[right]</em> 就是 <em>rightMax</em>。</p><p>所以这里 <em>height[left] &lt; height[right]</em> 中的 <em>height[right]</em> 就是当前的 <em>rightMax</em>，</p><p>而 <em>height[left] &lt; height[right]</em> 意味着还没找到大于 <em>rightMax 的 leftMax</em>，</p><p>所以 <em>leftMax &lt; rightMax</em></p></blockquote><p>如果 <em>height[left] < height[right]</em>, 那么一定有 <em>leftMax < rightMax</em>，是一个充要条件,</p><p><strong>因此将此判断条件改为：如果 <em>leftMax &lt; rightMax</em>, 依然正确，</strong>可看代码部分注释。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> leftMax = <span class="number">0</span>, rightMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            leftMax = Math.max(leftMax, height[left]);</span><br><span class="line">            rightMax = Math.max(rightMax, height[right]);</span><br><span class="line">            <span class="comment">// if(leftMax &lt; rightMax) 依然正确</span></span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">                ans += leftMax - height[left];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += rightMax - height[right];</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度: O(n)\<br>&amp;空间复杂度: O(1)<br>\end{align}<br>$$</p><hr><h3 id="解法四：单调栈"><a href="#解法四：单调栈" class="headerlink" title="解法四：单调栈"></a>解法四：单调栈</h3><p>思路：上面几种做法都可以理解成<strong>垂直处理</strong>，单调栈的方式为<strong>水平处理</strong>。</p><ol><li>维护一个单调栈存储数组下标，满足从栈底到栈顶的下标对应的数组 <em>height</em> 中的元素<strong>非严格递减</strong>；</li><li>从左到右遍历数组，遍历到下标 <em>i</em> 时，如果栈内至少有两个元素，记栈顶元素为 <em>top</em>，<em>top</em> 的下面一个元素是 <em>left</em>；</li><li>则一定有 <em>height[left] ≥ height[top]</em>，如果 <em>height[i] &gt; height[top]</em>，则得到一个接雨水的区域；</li><li>该区域的宽度是 <em>i−left−1</em>，高度是 <em>min( height[left] , height[i] ) − height[top]</em>，根据宽度和高度即可计算得到该区域能接的雨水量；</li><li>为了得到  <em>left</em>，需要将 <em>top</em> 出栈。在对 <em>top</em> 计算能接的雨水量之后，<em>left</em> 变成新的 <em>top</em>；</li><li>重复上述操作，直到栈变为空，或者栈顶下标对应的 <em>height</em> 中的元素大于或等于 <em>height[i]</em>；</li><li>遍历结束之后即可得到能接的雨水总量。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = height.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> top = stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> left = stack.peek();</span><br><span class="line">                <span class="keyword">int</span> currWidth = i - left - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> currHeight = Math.min(height[left], height[i]) - height[top];</span><br><span class="line">                ans += currWidth * currHeight;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度: O(n)\<br>&amp;空间复杂度: O(n)<br>\end{align}<br>$$</p><hr><h3 id="补充说明：为什么使用-Deque-而不是-Stack-？"><a href="#补充说明：为什么使用-Deque-而不是-Stack-？" class="headerlink" title="补充说明：为什么使用 Deque 而不是 Stack ？"></a><strong>补充说明：为什么使用 Deque 而不是 Stack ？</strong></h3><ol><li><p><code>Deque</code> 是 <code>double ended queue</code> 的简称，习惯上称之为<strong>双端队列</strong></p></li><li><p>由于<code>Vector</code>因效率问题已经被弃用，因此继承<code>Vector</code>的<code>Stack</code>也存在效率问题，故不推荐。</p></li></ol><p>详情可参考文章：</p><p><a>深入理解Java集合之—Deque - 简书 (jianshu.com)](<a href="https://www.jianshu.com/p/d78a7c982edb">https://www.jianshu.com/p/d78a7c982edb</a>)</a></p><p><a><a href="https://www.cnblogs.com/code-duck/p/13569388.html">为什么使用Deque而不使用Stack构造栈 - codeduck - 博客园 (cnblogs.com)</a></a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洗牌算法</title>
      <link href="/2021/11/23/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"/>
      <url>/2021/11/23/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="洗牌算法-模拟洗牌-Fisher-Yates算法"><a href="#洗牌算法-模拟洗牌-Fisher-Yates算法" class="headerlink" title="洗牌算法( 模拟洗牌 | Fisher-Yates算法 )"></a>洗牌算法( 模拟洗牌 | Fisher-Yates算法 )</h3><span id="more"></span><blockquote><blockquote><p>设计算法打乱一个没有重复元素的给定整数数组 nums</p></blockquote></blockquote><h3 id="解法一：模拟洗牌"><a href="#解法一：模拟洗牌" class="headerlink" title="解法一：模拟洗牌"></a>解法一：模拟洗牌</h3><p>思路：首先不妨设数组 <em>nums</em> 的长度为 <em>n</em>，</p><ol><li>不妨用数据结构 <em>waiting</em> 来存放 <em>nums</em> 中的所有元素，并初始化打乱后的数组 <em>shuffled</em></li><li>从数组 <em>shuttle</em> 的 <em>0</em> 下标开始，每次从 <em>waiting</em> 中随机选取一个数据放置到 <em>shuffled</em>，并且从 <em>waiting</em> 中移除该数据</li></ol><p><em>（整体来说：模拟洗牌，每次的选择概率均相等，可以理解成抽签模拟）</em></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] shuffle() &#123;</span><br><span class="line"><span class="keyword">int</span>[] shuffled = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        list.add(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = random.nextInt(list.size());</span><br><span class="line">        shuffled[i] = list.remove(j);</span><br><span class="line">    &#125;</span><br><span class="line">    System.arraycopy(shuffled, <span class="number">0</span>, nums, <span class="number">0</span>, nums.length);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度：O(n^2)<br>&amp;空间复杂度：O(n)<br>\end{align}<br>$$</p><hr><h3 id="解法二：Fisher-Yates洗牌算法"><a href="#解法二：Fisher-Yates洗牌算法" class="headerlink" title="解法二：Fisher-Yates洗牌算法"></a>解法二：Fisher-Yates洗牌算法</h3><p>首先需要理解为什么上面介绍的模拟洗牌算法的时间复杂度为 O(n<sup>2</sup>)，</p><p><code>list.remove(int index)的时间复杂度是O(n - index)</code>, 因此改进算法：</p><ol><li>如果每次的 <em>index</em> 是最后一位，那么时间复杂度就降为 O(1)；</li><li>那么在放入 <em>shuffled</em> 之前, 先将 当前的 index 和 最后一位进行交换；</li><li>将最后一位移除的同时放入 <em>shuffled</em> 的指定位置即可。</li></ol><p>那么在此基础上，我们可以再进行改进，实现<strong>数组的原地乱序</strong></p><ol><li>不再使用数据结构 <em>waiting</em>，仅在原数组上操作；</li><li><strong>不再从数组中移除元素，每次将第 <em>k</em> 个元素与第 <em>1</em> 个元素交换</strong> </li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] shuffle() &#123;</span><br><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i + random.nextInt(nums.length - i);</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度：O(n)<br>&amp;空间复杂度：O(n)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>范围内查询质数</title>
      <link href="/2021/11/23/%E8%8C%83%E5%9B%B4%E5%86%85%E6%9F%A5%E8%AF%A2%E8%B4%A8%E6%95%B0/"/>
      <url>/2021/11/23/%E8%8C%83%E5%9B%B4%E5%86%85%E6%9F%A5%E8%AF%A2%E8%B4%A8%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="查询质数-枚举-埃氏筛-线性筛"><a href="#查询质数-枚举-埃氏筛-线性筛" class="headerlink" title="查询质数( 枚举 | 埃氏筛 | 线性筛 )"></a>查询质数( 枚举 | 埃氏筛 | 线性筛 )</h3><span id="more"></span><blockquote><blockquote><p>统计所有小于非负整数 <em><code>n</code></em> 的质数的数量。</p></blockquote></blockquote><h4 id="解法一：枚举求解"><a href="#解法一：枚举求解" class="headerlink" title="解法一：枚举求解"></a><strong>解法一：枚举求解</strong></h4><p>思路：从 1 ~ n 遍历，统计其中为质数的个数即可。</p><p><em><strong>一些常用的技巧：</strong></em></p><ol><li>在判断循环终止条件时，采用 <code>i * i &lt;= n</code>而不要采用 <code>i &lt;= Math.sqrt(n)</code>,可以降低程序运行时间；</li><li>在循环进行时，循环的变化条件增值，可以改成 <code>i = i + 2</code>而不是 <code>i = i + 1</code>，可以降低程序运行时间；</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans += isPrime(i) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i * i &lt;= x; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度：O(n\sqrt(n))\<br>&amp;空间复杂度：O(1)<br>\end{align}<br>$$</p><hr><h4 id="解法二：厄拉多塞筛法（埃氏筛）"><a href="#解法二：厄拉多塞筛法（埃氏筛）" class="headerlink" title="解法二：厄拉多塞筛法（埃氏筛）"></a><strong>解法二：厄拉多塞筛法（埃氏筛）</strong></h4><blockquote><blockquote><p>枚举没有考虑到数与数的关联性，因此难以再继续优化时间复杂度。</p><p>介绍一个常见的算法，该算法由希腊数学家厄拉多塞（Eratosthenes）提出，称为厄拉多塞筛法，简称埃氏筛。</p></blockquote></blockquote><p><strong>首先确定一个基准：如果 x 是一个质数，那么 2x、3x , ... 一定不是质数。</strong></p><p>那么依然从 2 开始遍历，如果 <code>x</code>是质数，那么标记它的整数倍为合数，最后统计多少质数即可：</p><ol><li>如果<code>x</code>是合数：说明必定存在一个小于<code>x</code>的<code>y</code>，使得其为合数，推断正确；</li><li>如果<code>x</code>是质数：说明不存在比<code>x</code>小的数，是其因子，推断正确。</li></ol><p><em><strong>对于基准的优化：不必从<code>2x</code>、<code>3x</code>这样开始标记，直接从<code>x * x</code>开始标记即可。</strong></em></p><p>不妨声明数组 <code>isPrime[]</code>来记录上述过程，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] isPrime = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(isPrime, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                ans += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">long</span>) i * i &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; n; j += i) &#123;</span><br><span class="line">                        isPrime[j] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度：O(nloglogn)\<br>&amp;空间复杂度：O(n)<br>\end{align}<br>$$</p><hr><h4 id="解法三：线性筛"><a href="#解法三：线性筛" class="headerlink" title="解法三：线性筛"></a>解法三：线性筛</h4><blockquote><blockquote><p>埃氏筛其实存在冗余的标记操作，比如对于<code>45</code>这个数，它会同时被 <code>3</code>,<code>5</code>两个数标记为合数，</p><p>因此我们优化的目标是让每个合数只被标记一次，这样时间复杂度即能保证为 O(n)</p></blockquote></blockquote><p><strong>优化方法：</strong></p><ol><li><p>额外维护一个 primes 数组表示当前得到的质数集合；</p></li><li><p>从小到大遍历，如果当前的数 x 是质数，就将其加入 primes 数组；</p></li><li><p>「标记过程」不再仅当 x 为质数时才进行，而是对每个整数 x 都进行,</p><p>​    对于整数 x，我们不再标记其所有的倍数 <code>x·x</code>,<code>x·(x+1)</code>, … ,</p><p>​    而是只标记质数集合中的数与 x 相乘的数，即 x · primes<sub>0</sub> , x · primes<sub>1</sub> , x⋅primes <sub>2</sub> , … ，</p><p>​    且在发现 x mod primes<sub>i</sub> = 0 时结束当前标记过程 (<strong>这一步确保了不会重复标记</strong>)。</p></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; primes = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] isPrime = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(isPrime, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                primes.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; primes.size() &amp;&amp; i * primes.get(j) &lt; n; ++j) &#123;</span><br><span class="line">                isPrime[i * primes.get(j)] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i % primes.get(j) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> primes.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度：O(n)\<br>&amp;空间复杂度：O(n)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java课设总结</title>
      <link href="/2021/11/18/JavaFX/"/>
      <url>/2021/11/18/JavaFX/</url>
      
        <content type="html"><![CDATA[<h3 id="简易PPT实现"><a href="#简易PPT实现" class="headerlink" title="简易PPT实现"></a>简易PPT实现</h3><span id="more"></span><h3 id="内容要求"><a href="#内容要求" class="headerlink" title="内容要求"></a>内容要求</h3><ol><li><strong>内容：开发一个简易的幻灯片制作与播放软件</strong></li><li><strong>基本功能：</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">新建幻灯片，幻灯片由不少于一个页面组成</span><br><span class="line">新建一个空白的幻灯片页面</span><br><span class="line">打开或保存整个幻灯片</span><br><span class="line">在幻灯片页面上绘制基本图形</span><br><span class="line">在幻灯片页面上绘制任意直线</span><br><span class="line">添加文字</span><br><span class="line">设定颜色与文字风格</span><br><span class="line">对幻灯片页面上已有的基本图形、线形、文字进行选取和移动</span><br><span class="line">通过鼠标拖动完成上述绘制和添加文字等操作</span><br></pre></td></tr></table></figure><ol><li><strong>选作功能：</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">幻灯片的全屏播放、翻页</span><br><span class="line">设定画笔、插入图像、修改图像（使用橡皮擦）</span><br><span class="line">图形填充、线型设置</span><br><span class="line">对幻灯片页面上已有的基本图形、线性、文字进行修改</span><br><span class="line">操作的撤销与重组</span><br><span class="line">菜单</span><br><span class="line">简易的JDBC连接MySQL数据库实现用户登录</span><br></pre></td></tr></table></figure><hr><h3 id="帮助文档"><a href="#帮助文档" class="headerlink" title="帮助文档"></a>帮助文档</h3><ol><li><p><strong>开发环境和插件选择</strong>：</p><p><code>Gradle + JavaFx + JPoneiX + JDK 1.8 + Spire.Presentation + IDEA </code></p><p>说明：</p><ol><li>按照 <code>non-modular + idea</code> 使用 JavaFx，会带来配置修改问题</li><li>使用 <code>JPoneiX</code> 开源项目优化 UI 界面，更加美观和方便</li><li>使用<code>Gradle</code>管理项目更加方便，兼容性更好</li></ol></li><li><p><strong>本人项目地址：</strong></p><p>GitHub：<a><a href="https://github.com/Eminem-x/JFoenix">https://github.com/Eminem-x/JFoenix</a></a></p></li></ol><ol start="2"><li><p><strong>JavaFX的基本操作指南：</strong></p><ol><li>官方文档: <a><a href="https://openjfx.io/">https://openjfx.io/</a></a><ul><li>基本内容以及示例说明</li><li>JavaFX的doc文档说明 </li></ul></li><li>WiKi教程: <a><a href="https://iowiki.com/javafx/javafx_images.html">https://iowiki.com/javafx/javafx_images.html</a></a></li><li>JavaFX和FXML的关系阐述： <a><a href="https://blog.csdn.net/theonegis/article/details/50181339">https://blog.csdn.net/theonegis/article/details/50181339</a></a></li></ol></li><li><p><strong>Java操作PPT的免费非开源组件:</strong></p><ol><li><p>官方网址：<a>冰蓝科技 PowerPoint 组件<a href="https://www.e-iceblue.cn/">https://www.e-iceblue.cn/</a></a></p></li><li><p>说明：</p><ol><li><p>此组件目前没有免费开源，会带有水印，不过不影响整体的实现，</p><p>可以通过适当操作，去掉水印的显示；</p></li><li><p>另外官方没有Gradle方式添加到工程，附上Gradle如何添加本地外包的方法：<br> <a href="https://blog.csdn.net/m1213642578/article/details/52763130?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link">Gradle添加本地外包</a></p></li></ol></li></ol></li><li><p><strong>JavaFX实现绘图功能的项目：</strong></p><ol><li>GitHub链接：<a><a href="https://github.com/FlyuZ/FYDrawing-JAVAFX">https://github.com/FlyuZ/FYDrawing-JAVAFX</a></a></li><li>可以参考实现方法，按照需求更改</li></ol></li><li><p><strong>JPoneiX开源项目：</strong></p><ol><li>GitHub链接：<a href="https://github.com/sshahine/JFoenix">https://github.com/sshahine/JFoenix</a></li><li>官方doc文档：<a><a href="https://javadoc.io/doc/com.jfoenix/jfoenix/latest/overview-summary.html">https://javadoc.io/doc/com.jfoenix/jfoenix/latest/overview-summary.html</a></a></li><li>此开源项目美化了JavaFx的组件UI，并且提供了许多便于使用和操作的组件</li></ol></li><li><p><strong>可用 Icon 的选取：</strong></p><ol><li>样式链接：<a><a href="https://fontawesome.com/v5.15/icons?d=gallery&amp;p=4&amp;s=solid&amp;m=free">https://fontawesome.com/v5.15/icons?d=gallery&amp;p=4&amp;s=solid&amp;m=free</a></a></li><li>使用时在 <code>Extern Libraries</code>下寻找此插件的 <code>solid</code>样式，然后相应位置替换即可</li><li>其他图片可能会失效，尝试即可，推荐使用 <code>solid</code></li></ol></li></ol><hr><h3 id="项目演示"><a href="#项目演示" class="headerlink" title="项目演示"></a>项目演示</h3><ol><li><p>文件结构：</p><p><img src="/2021/11/18/JavaFX/java%E8%AF%BE%E8%AE%BE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="文件结构"></p></li><li><p>项目运行效果：</p><p><img src="/2021/11/18/JavaFX/java%E8%AF%BE%E8%AE%BE%E6%95%88%E6%9E%9C%E5%9B%BE1.png" alt="主界面"></p><p><img src="/2021/11/18/JavaFX/java%E8%AF%BE%E8%AE%BE%E6%95%88%E6%9E%9C%E5%9B%BE2.png" alt="画图"></p><p><img src="/2021/11/18/JavaFX/java%E8%AF%BE%E8%AE%BE%E6%95%88%E6%9E%9C%E5%9B%BE3.png" alt="放映"></p></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 课程设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
