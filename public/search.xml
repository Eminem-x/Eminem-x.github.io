<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>可见点的最大数目</title>
      <link href="/2021/12/16/%E5%8F%AF%E8%A7%81%E7%82%B9%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/"/>
      <url>/2021/12/16/%E5%8F%AF%E8%A7%81%E7%82%B9%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="可见点的最大数目（-图-数学）"><a href="#可见点的最大数目（-图-数学）" class="headerlink" title="可见点的最大数目（ 图 | 数学）"></a>可见点的最大数目（ 图 | 数学）</h3><span id="more"></span><blockquote><p>题目详情参考：<a href="https://leetcode-cn.com/problems/maximum-number-of-visible-points/">1610. 可见点的最大数目 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><p>该题目建立在数学基础上，需要对每一步都了解，层层递进。</p><h3 id="解法一：二分搜索"><a href="#解法一：二分搜索" class="headerlink" title="解法一：二分搜索"></a>解法一：二分搜索</h3> <img src="/2021/12/16/%E5%8F%AF%E8%A7%81%E7%82%B9%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/整体思路.png" alt="整体思路" style="zoom:33%;"><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[2,1],[2,2],[3,3]], angle = 90, location = [1,1]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p>不妨以这个示例，另外额外在图中添加一个样例点，说明一下整体思路：</p><ol><li>在本题中视角可转换为相对于 <code>location</code> 的<a href="[极角_百度百科 (baidu.com)](https://baike.baidu.com/item/极角/12726003?fr=aladdin)">极角</a>；</li><li>将所有点 <code>point</code> 的坐标转化为相对于 <code>location</code> 的极角；</li><li>如何通过数学计算得到极角：</li></ol> <img src="/2021/12/16/%E5%8F%AF%E8%A7%81%E7%82%B9%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/极角计算.png" alt="极角计算" style="zoom:33%;"><p>​        在程序中，<strong>采用 <a href="[Math (Java SE 9 & JDK 9 ) (oracle.com)](https://docs.oracle.com/javase/9/docs/api/java/lang/Math.html#atan2-double-double-)"><code>atan2</code></a> 方法来计算，因为其值域为 [ -Π，Π ]；</strong></p><ol start="4"><li><p>不妨设当前 <code>point</code> 的极角为 <code>polarDegree</code> ，*(如下简称为  d<sub>p</sub> )*</p><p> <strong>那么找到坐标的极角处于区间 [d<sub>p</sub>, d<sub>p</sub> + angle]的最大数量即可</strong>;</p></li></ol> <img src="/2021/12/16/%E5%8F%AF%E8%A7%81%E7%82%B9%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/视角内数量.png" style="zoom:33%;"><ol start="5"><li><p>第三步的处理很妙，即如何确定视角范围内的数量，通过极角的大小关系即可；</p></li><li><p>在具体计算中，<strong>需要特殊处理和 <code>location</code> 相同的点，</strong></p><p>因为 <code>atan2</code> 的两个参数不能同时为 0；</p></li><li><p><strong>对所有点的极角排序，然后在范围内二分搜索得到数量值</strong>，但是可能会出现下面情况：</p><p>d<sub>p</sub> + angle &gt; 180°，导致范围内无解，这是因为 <code>atan2</code> 所得的范围是 [-180°，180°]；</p><p>因此将所有的极角加上 360° 再添加到原序列后面，不会影响大小排序，可以避免上述情况；</p></li><li><p><strong>注意程序中的数据是采用弧度制计算的。</strong></p></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">visiblePoints</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; points, <span class="keyword">int</span> angle, List&lt;Integer&gt; location)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sameCnt = <span class="number">0</span>;</span><br><span class="line">        List&lt;Double&gt; polarDegrees = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> locationX = location.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> locationY = location.get(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = points.get(i).get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> y = points.get(i).get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (x == locationX &amp;&amp; y == locationY) &#123;</span><br><span class="line">                sameCnt++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Double degree = Math.atan2(y - locationY, x - locationX);</span><br><span class="line">            polarDegrees.add(degree);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(polarDegrees);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = polarDegrees.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            polarDegrees.add(polarDegrees.get(i) + <span class="number">2</span> * Math.PI);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxCnt = <span class="number">0</span>;</span><br><span class="line">        Double toDegree = angle * Math.PI / <span class="number">180</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> iteration = binarySearch(polarDegrees, polarDegrees.get(i) + toDegree);</span><br><span class="line">            maxCnt = Math.max(maxCnt, iteration - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxCnt + sameCnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;Double&gt; nums, Double target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = nums.size();</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums.get(mid) &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n×logn)<br>&amp;空间复杂度:O(n)<br>\end{align}<br>$$</p><hr><h3 id="解法二：滑动窗口"><a href="#解法二：滑动窗口" class="headerlink" title="解法二：滑动窗口"></a>解法二：滑动窗口</h3><p>整体思路同一，尽管整体的时间复杂度没变，但是优化了搜索过程：</p><p><strong>搜索过程的时间复杂度从 O（2n × log2n）降低为 O（2n × 2n）</strong></p> <img src="/2021/12/16/%E5%8F%AF%E8%A7%81%E7%82%B9%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/时空复杂度.png" alt="复杂度对比" style="zoom: 80%;"><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">visiblePoints</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; points, <span class="keyword">int</span> angle, List&lt;Integer&gt; location)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sameCnt = <span class="number">0</span>;</span><br><span class="line">        List&lt;Double&gt; polarDegrees = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> locationX = location.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> locationY = location.get(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = points.get(i).get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> y = points.get(i).get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (x == locationX &amp;&amp; y == locationY) &#123;</span><br><span class="line">                sameCnt++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Double degree = Math.atan2(y - locationY, x - locationX);</span><br><span class="line">            polarDegrees.add(degree);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(polarDegrees);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = polarDegrees.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            polarDegrees.add(polarDegrees.get(i) + <span class="number">2</span> * Math.PI);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> toDegree = angle * Math.PI / <span class="number">180</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            Double curr = polarDegrees.get(i) + toDegree;</span><br><span class="line">            <span class="keyword">while</span> (right &lt; polarDegrees.size() &amp;&amp; polarDegrees.get(right) &lt;= curr) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            maxCnt = Math.max(maxCnt, right - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxCnt + sameCnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n×logn)<br>&amp;空间复杂度:O(n)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单词拆分</title>
      <link href="/2021/12/15/%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/"/>
      <url>/2021/12/15/%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h3 id="单词拆分（-动态规划-）"><a href="#单词拆分（-动态规划-）" class="headerlink" title="单词拆分（ 动态规划 ）"></a>单词拆分（ 动态规划 ）</h3><span id="more"></span><blockquote><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典，</p><p>判定 s 是否可以由空格拆分为一个或多个在字典中出现的单词。</p><p>说明：拆分时可以重复使用字典中的单词。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>题目详情参考：<a href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><h3 id="解法一：模拟遍历（错误）"><a href="#解法一：模拟遍历（错误）" class="headerlink" title="解法一：模拟遍历（错误）"></a>解法一：模拟遍历（错误）</h3><p>思路：</p><ol><li>将字典中的单词放入哈希表中，创建变量记录当前字符串；</li><li>遍历字符串，当哈希表中含有此单词，那么清空当前字符串，否则继续；</li><li>在遍历过程中，变量 <code>ans</code> ，记录当前的真值。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String word : wordDict) &#123;</span><br><span class="line">            set.add(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> ans = <span class="keyword">true</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();                 </span><br><span class="line">        <span class="keyword">while</span>(index &lt;= s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(sb.toString())) &#123;</span><br><span class="line">                sb.delete(<span class="number">0</span>, sb.length());</span><br><span class="line">                ans = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(index &lt; s.length()) &#123;</span><br><span class="line">                sb.append(s.charAt(index));</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>错误原因：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;aaaaaaa&quot;, wordDict = [&quot;aaa&quot;, &quot;aaaa&quot;]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>对于上述用例时，就会出错，因为会先处理 <code>aaa</code> 的情况，导致结果出错。</p><hr><h3 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h3><p>思路：如果当前字符串能够被拆分，一定存在空格位置，使其分割。</p><ol><li>创建数组 <code>dp</code> ，<code>dp[i]</code> 表示以 <code>i</code> 下标结尾的子串是否在字典中含有；</li><li>依然用哈希表存储字典中的单词，以便快速查询；</li><li>那么对于 <code>dp[i]</code> 而言，如果其能够被拆分，那么不妨设被拆分的点为 <code>j</code> ：</li></ol><p>$$<br>dp[i] = dp[j]\  \&amp; \&amp; \ check(s[j，i-1])<br>$$</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; wordDictSet = <span class="keyword">new</span> HashSet(wordDict);</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] &amp;&amp; wordDictSet.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n^2)<br>&amp;空间复杂度:O(n)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>喧闹和富有</title>
      <link href="/2021/12/15/%E5%96%A7%E9%97%B9%E5%92%8C%E5%AF%8C%E6%9C%89/"/>
      <url>/2021/12/15/%E5%96%A7%E9%97%B9%E5%92%8C%E5%AF%8C%E6%9C%89/</url>
      
        <content type="html"><![CDATA[<h3 id="喧闹和富有（-DFS-拓扑排序-）"><a href="#喧闹和富有（-DFS-拓扑排序-）" class="headerlink" title="喧闹和富有（ DFS | 拓扑排序 ）"></a>喧闹和富有（ DFS | 拓扑排序 ）</h3><span id="more"></span><blockquote><p>题目详情参考：<a href="https://leetcode-cn.com/problems/loud-and-rich/">851. 喧闹和富有 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><p>心得：第一次遇见和学习有关图的问题，日复一日，必有精进。</p><h3 id="解法一：深度优先搜索"><a href="#解法一：深度优先搜索" class="headerlink" title="解法一：深度优先搜索"></a>解法一：深度优先搜索</h3><p>思路：建立一个有向图，然后从当前点出发搜索满足题意的点。</p><ol><li>每一个人的位置看成一个点，如果 <code>x</code> 比 <code>y</code> 更有钱，那么就从 <code>y</code> 向 <code>x</code> 连一条有向边；</li><li>根据题目所给数组，构建一个有向图，并且由题可知，不存在环；</li><li>因此从图上任意一点（设为 <code>x</code> ）出发，沿着有向边所能访问到的点，都比 <code>x</code> 更有钱；</li><li>题目需要计算拥有的钱肯定不少于 <code>x</code> 的人中，最安静的人，包括两种人：<ol><li>拥有的钱等于 <code>x</code> ，比如 <code>x</code> 本身；</li><li>拥有的钱大于 <code>x</code> ，有向边所能访问的点；</li></ol></li><li>因此搜索所能到达的点，寻找答案；</li><li>如果当前位置已经计算出最安静的人，那么就不再搜索，减少搜索。</li></ol> <img src="/2021/12/15/%E5%96%A7%E9%97%B9%E5%92%8C%E5%AF%8C%E6%9C%89/示例图.png" alt="示例图" style="zoom: 33%;"><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] loudAndRich(<span class="keyword">int</span>[][] richer, <span class="keyword">int</span>[] quiet) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = quiet.length;</span><br><span class="line">        List&lt;Integer&gt;[] graph = <span class="keyword">new</span> List[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] value : richer) &#123;</span><br><span class="line">            graph[value[<span class="number">1</span>]].add(value[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(ans, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dfs(i, quiet, graph, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span>[] quiet, List&lt;Integer&gt;[] graph, <span class="keyword">int</span>[] ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[x] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[x] = x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> next : graph[x]) &#123;</span><br><span class="line">            dfs(next, quiet, graph, ans);</span><br><span class="line">            <span class="keyword">if</span> (quiet[ans[next]] &lt; quiet[ans[x]]) &#123;</span><br><span class="line">                ans[x] = ans[next];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(n)<br>\end{align}<br>$$</p><hr><h3 id="解法二：拓扑排序"><a href="#解法二：拓扑排序" class="headerlink" title="解法二：拓扑排序"></a>解法二：拓扑排序</h3><p>思路：与思路一不同之处在于，有向图的方向为钱多指向钱少。</p><ol><li>每一个人的位置看成一个点，<strong>如果 <code>x</code> 比 <code>y</code> 更有钱，那么就从 <code>x</code> 向 <code>y</code> 连一条有向边；</strong></li><li>与此同时，<strong>记录每一个点的入度，</strong>以便后续处理；</li><li>从图上任意一点（设为 <code>x</code> ）出发，沿着有向边所能访问到的点，都没有 <code>x</code> 有钱；</li><li>因此可以在计算出 <code>ans[x]</code> 后，用 <code>ans[x]</code> 去更新 x 所能访问到的点的 <code>ans</code> 值</li><li>具体开始时，依次遍历入度为 0 的点，访问更新值，并且减少已经访问点的入度；</li></ol> <img src="/2021/12/15/%E5%96%A7%E9%97%B9%E5%92%8C%E5%AF%8C%E6%9C%89/拓扑排序.png" alt="示例图" style="zoom: 33%;"><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] loudAndRich(<span class="keyword">int</span>[][] richer, <span class="keyword">int</span>[] quiet) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = quiet.length;</span><br><span class="line">        List&lt;Integer&gt;[] graph = <span class="keyword">new</span> List[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] inDeg = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] value : richer) &#123;</span><br><span class="line">            graph[value[<span class="number">0</span>]].add(value[<span class="number">1</span>]);</span><br><span class="line">            inDeg[value[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> next : graph[x]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (quiet[ans[x]] &lt; quiet[ans[next]]) &#123;</span><br><span class="line">                    ans[next] = ans[x];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (--inDeg[next] == <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.offer(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(n)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跳跃游戏</title>
      <link href="/2021/12/14/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
      <url>/2021/12/14/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="跳跃游戏（-贪心-）"><a href="#跳跃游戏（-贪心-）" class="headerlink" title="跳跃游戏（ 贪心 ）"></a>跳跃游戏（ 贪心 ）</h3><span id="more"></span><h3 id="跳跃游戏Ⅰ"><a href="#跳跃游戏Ⅰ" class="headerlink" title="跳跃游戏Ⅰ"></a>跳跃游戏Ⅰ</h3><blockquote><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>题目详情参考：<a href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><p>思路：只需要判断是否能够跳到最终位置即可，那么不妨直接求总体跳跃的最大距离即可。</p><ol><li>定义一个变量 <code>visitedEnd</code> 表示遍历过程中得到的总体跳跃最大距离；</li><li>循环遍历数组，更新上述变量，最后判断是否超过终点即可。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> visitedEnd = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visitedEnd &gt;= nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= visitedEnd) &#123;</span><br><span class="line">            visitedEnd = Math.max(i + nums[i], visitedEnd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p><hr><h3 id="跳跃游戏Ⅱ"><a href="#跳跃游戏Ⅱ" class="headerlink" title="跳跃游戏Ⅱ"></a>跳跃游戏Ⅱ</h3><blockquote><p>给你一个非负整数数组 nums ，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>假设你总是可以到达数组的最后一个位置。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>题目详情参考：<a href="https://leetcode-cn.com/problems/jump-game-ii/">45. 跳跃游戏 II - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><p>思路：和跳跃游戏Ⅰ不同之处在于，该题需要求解最少跳跃次数。</p><ol><li><strong>首先明确一个准则，如果能够跳跃至终点，那么路径上的任何一点都可以到达；</strong></li><li>因此，只需要从终点往前求出最远的跳跃位置即可，然后更新终点；</li><li>以此类推，直至终点和起点相同即可；</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (begin + nums[begin] &gt;= end) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            end = begin;</span><br><span class="line">            begin = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            begin++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 贪心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打家劫舍系列问题</title>
      <link href="/2021/12/13/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98/"/>
      <url>/2021/12/13/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="打家劫舍系列问题（-动态规划-）"><a href="#打家劫舍系列问题（-动态规划-）" class="headerlink" title="打家劫舍系列问题（ 动态规划 ）"></a>打家劫舍系列问题（ 动态规划 ）</h3><span id="more"></span><h3 id="打家劫舍Ⅰ"><a href="#打家劫舍Ⅰ" class="headerlink" title="打家劫舍Ⅰ"></a>打家劫舍Ⅰ</h3><blockquote><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，</p><p>影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，</p><p>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，</p><p>计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p>题目详情参考：<a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><p>思路：动态规划的经典题目，<strong>一定要先找到动态转移方程！</strong></p><ol><li>不妨设一维数组 <code>dp</code> ，<strong>其中 <code>dp[i]</code> 表示在从 <code>0</code> 到 <code>i</code> 时，所能偷取的最大金额；</strong></li><li>那么根据题意可知，所偷的房子不能相邻，因此得到如下转移方程：</li></ol><p>$$<br>dp[i] = max\lbrace dp[i - 1],dp[i - 2] + nums[i] \rbrace<br>$$</p><ol start="3"><li>即在当前位置，有两种选择：<ol><li>不偷当前位置的房子，那么相当于偷前一个房子；</li><li>偷当前位置的房子，那么相当于不偷前一个房子；</li></ol></li><li><strong>补充：也可以使用滚动数组降低空间复杂度！</strong></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> ans = Math.max(dp[<span class="number">0</span>], dp[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">            ans = Math.max(dp[i], ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(n)<br>\end{align}<br>$$</p><hr><h3 id="打家劫舍Ⅱ"><a href="#打家劫舍Ⅱ" class="headerlink" title="打家劫舍Ⅱ"></a>打家劫舍Ⅱ</h3><blockquote><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。</p><p>这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。</p><p>同时，相邻的房屋装有相互连通的防盗系统，</p><p>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，</p><p>计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p><p>题目详情参考：<a href="https://leetcode-cn.com/problems/house-robber-ii/">213. 打家劫舍 II - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><p>思路：该题和第一题的不同之处在于，这次房屋不是直线而是闭合的环。</p><ol><li>如果偷了第一家，那么偷的范围应为 <code>0 ~ length - 1</code>；</li><li>如果不偷第一家，那么偷的范围应为 <code>1 ~ length</code>；</li><li><strong>这两个解集的并集，包括所有情况，可以仔细思考一下；</strong></li><li>其余思路和第一问相同。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="comment">// get max value from 0 to length - 1</span></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> ans = Math.max(dp[<span class="number">0</span>], dp[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">            ans = Math.max(dp[i], ans);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get max value from 1 to length</span></span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>] = Math.max(nums[<span class="number">1</span>], nums[<span class="number">2</span>]);</span><br><span class="line">        ans = Math.max(ans, Math.max(dp[<span class="number">1</span>], dp[<span class="number">2</span>]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">            ans = Math.max(dp[i], ans);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(n)<br>\end{align}<br>$$</p><hr><h3 id="变形题：删除并获得点数"><a href="#变形题：删除并获得点数" class="headerlink" title="变形题：删除并获得点数"></a>变形题：删除并获得点数</h3><blockquote><p>给你一个整数数组 nums ，你可以对它进行一些操作。</p><p>每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。</p><p>之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。</p><p>开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,3,3,3,4]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure><p>题目详情参考：<a href="https://leetcode-cn.com/problems/delete-and-earn/">740. 删除并获得点数 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><p>思路：将该题转变为上面两题，二者的整体思路相差不多。</p><ol><li><p><strong>采用Map统计</strong>数组中各自元素的值和数量，以便后续求点数；</p></li><li><p>不妨设二维数组 <code>dp</code> ，</p><ul><li><p><code>dp[i][0]</code> 表示当前位置的元素；</p></li><li><p><code>dp[i][1]</code> 表示当前位置下元素的个数；</p></li><li><p><code>dp[i][2]</code> <strong>表示从开始至当前位置下所能获得最大点数；</strong></p></li></ul></li><li><p>对 <code>dp</code> 进行排序，那么对于 <code>dp[i]</code> 可以得到下面的情况：</p><ol><li>如果 <code>dp[i - 1][0] + 1</code> 等于 <code>dp[i][0]</code> ；</li><li>如果 <code>dp[i - 1][0] + 1</code> 不等于 <code>dp[i][0]</code> ；</li><li><strong>上述两种情况等价于第一题中的房子是否相邻！</strong></li></ol></li><li><p>那么可以得到动态转移方程：</p></li></ol><p>$$<br>dp[i][2]=\begin{cases}max\lbrace dp[i - 1][2],dp[i-2][2]+dp[i][0]×dp[i][1] \rbrace &amp;dp[i-1][0] + 1=dp[i][0] \\ dp[i-1][2]+dp[i][0]×dp[i][1] &amp;反之\end{cases}<br>$$</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteAndEarn</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = getElementNumArray(nums);</span><br><span class="line">        Arrays.sort(dp, (o1, o2) -&gt; o1[<span class="number">0</span>] - o2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = dp[<span class="number">0</span>][<span class="number">0</span>] * dp[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (dp.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[<span class="number">1</span>][<span class="number">0</span>] == dp[<span class="number">0</span>][<span class="number">0</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">2</span>] = Math.max(dp[<span class="number">0</span>][<span class="number">2</span>], dp[<span class="number">1</span>][<span class="number">0</span>] * dp[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">2</span>] = dp[<span class="number">0</span>][<span class="number">2</span>] + dp[<span class="number">1</span>][<span class="number">0</span>] * dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(dp[<span class="number">0</span>][<span class="number">2</span>], dp[<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">if</span> (dp.length == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i][<span class="number">0</span>] == dp[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">2</span>] = dp[i - <span class="number">2</span>][<span class="number">2</span>] + dp[i][<span class="number">0</span>] * dp[i][<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>] + dp[i][<span class="number">0</span>] * dp[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(dp[i][<span class="number">2</span>], ans);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] getElementNumArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[map.size()][<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            arr[index][<span class="number">0</span>] = entry.getKey();</span><br><span class="line">            arr[index][<span class="number">1</span>] = entry.getValue();</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(n)<br>\end{align}<br>$$</p><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树的基本操作</title>
      <link href="/2021/12/11/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2021/12/11/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="二叉搜索树的基本操作"><a href="#二叉搜索树的基本操作" class="headerlink" title="二叉搜索树的基本操作"></a>二叉搜索树的基本操作</h3><span id="more"></span> <img src="/2021/12/11/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/示例图.png" alt="示例图" style="zoom:67%;"><p>如上图所示的一棵树，左孩子以及其子树小于父亲，右孩子以及其子树大于父亲的结构。</p><h3 id="二叉搜索树中的搜索"><a href="#二叉搜索树中的搜索" class="headerlink" title="二叉搜索树中的搜索"></a>二叉搜索树中的搜索</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; val) &#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.left, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; val) &#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二叉搜索树的插入操作"><a href="#二叉搜索树的插入操作" class="headerlink" title="二叉搜索树的插入操作"></a>二叉搜索树的插入操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &gt; root.val) &#123;</span><br><span class="line">            root.right = insertIntoBST(root.right, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.left = insertIntoBST(root.left, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二叉搜索树的验证"><a href="#二叉搜索树的验证" class="headerlink" title="二叉搜索树的验证"></a>二叉搜索树的验证</h3><h4 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h4><p>不仅仅需要保证当前结构下的左右孩子满足搜索树，</p><p><strong>还要保证左右孩子不破坏整体的搜索树结构</strong>，因此记录父亲结点的父亲值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode node, <span class="keyword">long</span> lower, <span class="keyword">long</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.val &lt;= lower || node.val &gt;= upper) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> isLeftCorrect = isValidBST(node.left, lower, node.val);</span><br><span class="line">        <span class="keyword">boolean</span> isRightCorrect = isValidBST(node.right, node.val, upper);</span><br><span class="line">        <span class="keyword">return</span> isLeftCorrect &amp;&amp; isRightCorrect;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解法二：中序遍历"><a href="#解法二：中序遍历" class="headerlink" title="解法二：中序遍历"></a>解法二：中序遍历</h4><p><strong>二叉搜索树的中序遍历是递增的</strong>，根据此性质判断即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">double</span> inorder = -Double.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">              <span class="comment">// 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树</span></span><br><span class="line">            <span class="keyword">if</span> (root.val &lt;= inorder) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            inorder = root.val;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合</title>
      <link href="/2021/12/10/%E7%BB%84%E5%90%88/"/>
      <url>/2021/12/10/%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><span id="more"></span><blockquote><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p></blockquote><h3 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>找到一个长度为 <code>n</code> 的序列 <code>a</code> 的所有子序列，代码框架如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == n + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 记录答案</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 考虑选择当前位置</span></span><br><span class="line">    temp.push_back(cur);</span><br><span class="line">    dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">    temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 考虑不选择当前位置</span></span><br><span class="line">    dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于本题，加上一些改进和优化：</p><ol><li>剪枝：如果当前 <code>temp</code> 内的元素数量和后续待选的总和小于所求，返回；</li><li>不判断 <code>curr == n + 1</code>，判断当前解集是否正确满足即可。</li></ol><p><strong>为什么记录合法的答案时为<code>ans.add(new ArrayList&lt;&gt;(temp))</code>？</strong></p><p>如果是<code>ans.add(temp)</code>，那么<strong>放入的是一个引用类型，其值在递归过程中一直变化，</strong></p><p>导致最终存储的数据也发生变化，因此需要重新开辟，再放入解集中。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        dfs(<span class="number">1</span>, n, k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 剪枝：temp 长度加上区间 [cur, n] 的长度小于 k，不可能构造出长度为 k 的 temp</span></span><br><span class="line">        <span class="keyword">if</span> (temp.size() + (n - cur + <span class="number">1</span>) &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录合法的答案</span></span><br><span class="line">        <span class="keyword">if</span> (temp.size() == k) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑选择当前位置</span></span><br><span class="line">        temp.add(cur);</span><br><span class="line">        dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">        temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 考虑不选择当前位置</span></span><br><span class="line">        dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(C^k_n×k)<br>&amp;空间复杂度:O(n+k)=O(n)<br>\end{align}<br>$$</p><hr><h3 id="解法二：字典序法"><a href="#解法二：字典序法" class="headerlink" title="解法二：字典序法"></a>解法二：字典序法</h3><p>思路：希望通过合适的手段，消除递归栈带来的额外空间代价。</p><p><strong>考虑一个二进制数数字 x，它由 k 个 1 和 n − k 个 0 组成</strong></p><ol><li>用含 k 个 1 的二进制数表示方案，1 表示选取 0 表示不选取，下图为例</li></ol><table><thead><tr><th align="center">原序列中被选的数</th><th align="center">对应的二进制数</th><th align="center">方案</th></tr></thead><tbody><tr><td align="center">4 3 [2] [1]</td><td align="center">0011</td><td align="center">1 2</td></tr><tr><td align="center">4 [3] 2 [1]</td><td align="center">0101</td><td align="center">1 3</td></tr><tr><td align="center">4 [3] [2] 1</td><td align="center">0110</td><td align="center">2 3</td></tr><tr><td align="center">[4] 3 2 [1]</td><td align="center">1001</td><td align="center">1 4</td></tr><tr><td align="center">[4] 3 [2] 1</td><td align="center">1010</td><td align="center">2 4</td></tr><tr><td align="center">[4] [3] 2 1</td><td align="center">1100</td><td align="center">3 4</td></tr></tbody></table><ol start="2"><li><p>如何获得二进制数的字典序，即从小到大，如下两个规则：</p><ol><li><p>如果当前最低位为 1，不妨设末尾由 t 个连续的 1 组成，</p><p>直接将倒数第 t 位的 1 和倒数第 t + 1 位的 0 替换即可；</p><p>比如：1001111 → 1010111</p></li><li><p>如果当前最低位为 0，不妨设末尾由 t 个连续的 0 组成，而这之前有 m 个连续的 1，</p><p>将倒数第 t + m 位置的 1 和倒数第 t + m + 1 位的 0 对换，</p><p>然后把倒数第 t + 1 位到倒数第 t + m − 1 位的 1 移动到最低位；</p><p>比如：1011100 → 1100011</p></li><li><p><strong>实际上规则一是规则二 t 为 0 的特殊情况。</strong></p></li></ol></li></ol><h4 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        initTemp(n, k);</span><br><span class="line">        <span class="keyword">while</span> (!isEnd(k)) &#123;</span><br><span class="line">            getMappingElement(temp);</span><br><span class="line">            getNewTemp();</span><br><span class="line">        &#125;</span><br><span class="line">        getMappingElement(temp);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initTemp</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            temp.add(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k + <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            temp.add(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEnd</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = temp.size() - <span class="number">1</span>; i &gt;= temp.size() - k; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.get(i) != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getMappingElement</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list.get(i) == <span class="number">1</span>) &#123;</span><br><span class="line">                temp.add(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getNewTemp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = getConstantZeroSum();</span><br><span class="line">        <span class="keyword">int</span> m = getConstantOneSum(t);</span><br><span class="line">        temp.set(t + m - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        temp.set(t + m, <span class="number">1</span>);</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i &lt; t + m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            list.add(temp.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line">            list.add(temp.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = t + m - <span class="number">1</span>; i &lt; temp.size(); i++) &#123;</span><br><span class="line">            list.add(temp.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        temp = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getConstantZeroSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> constanZeroSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.get(i) == <span class="number">0</span>) &#123;</span><br><span class="line">                constanZeroSum++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> constanZeroSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getConstantOneSum</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> constantOneSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i &lt; temp.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.get(i) == <span class="number">1</span>) &#123;</span><br><span class="line">                constantOneSum++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> constantOneSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化处理："><a href="#优化处理：" class="headerlink" title="优化处理："></a>优化处理：</h4><p>不通过存储一个二进制序列迭代得到方案，而是直接在方案本身上操作；</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="comment">// 将 temp 中 [0, k - 1] 每个位置 i 设置为 i + 1，即 [0, k - 1] 存 [1, k]</span></span><br><span class="line">        <span class="comment">// 末尾加一位 n + 1 作为哨兵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">            temp.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        temp.add(n + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(temp.subList(<span class="number">0</span>, k)));</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 寻找第一个 temp[j] + 1 != temp[j + 1] 的位置 t</span></span><br><span class="line">            <span class="comment">// 我们需要把 [0, t - 1] 区间内的每个位置重置成 [1, t]</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; k &amp;&amp; temp.get(j) + <span class="number">1</span> == temp.get(j + <span class="number">1</span>)) &#123;</span><br><span class="line">                temp.set(j, j + <span class="number">1</span>);</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// j 是第一个 temp[j] + 1 != temp[j + 1] 的位置</span></span><br><span class="line">            temp.set(j, temp.get(j) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(C^k_n×k)<br>&amp;空间复杂度:O(k)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01矩阵</title>
      <link href="/2021/12/09/01%E7%9F%A9%E9%98%B5/"/>
      <url>/2021/12/09/01%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="01矩阵（-动态规划-）"><a href="#01矩阵（-动态规划-）" class="headerlink" title="01矩阵（ 动态规划 ）"></a>01矩阵（ 动态规划 ）</h3><span id="more"></span><blockquote><p>给定一个由 0 和 1 组成的矩阵 mat ，请输出一个大小相同的矩阵，</p><p>其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。</p><p>两个相邻元素间的距离为 1 。</p><p>题目详情参考：<a href="https://leetcode-cn.com/problems/01-matrix/">542. 01 矩阵 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><p>思路：首先该题也可以广度优先搜索，但是这次尝试动态规划解决问题。</p><ol><li>首先明确一点：<strong>一个点到另一个点的最近距离移动方式</strong>一定是以下四种：<ol><li>只有水平向左移动和竖直向上移动</li><li>只有水平向左移动和竖直向下移动</li><li>只有水平向右移动和竖直向上移动</li><li>只有水平向右移动和竖直向下移动</li></ol></li><li>创建一个二维数组 <em>dp[i][j]</em> ,其值表示当前点到最近 <code>0</code> 的距离；</li><li>那么以<strong><em>只有水平向左移动和竖直向上移动 </em></strong>来举例说明转移方程：</li></ol><p>$$<br>dp[i][j]=\begin{cases}1+min\lbrace dp[i][j-1],dp[i-1][j]\rbrace&amp;当前位置元素为\ 1\\<br>0&amp;当前位置元素为\ 0\end{cases}<br>$$</p><ol start="4"><li>因此只需要对这四种方式都进行一次动态规划转移方程即可；</li><li><strong>需要注意动态规划的计算顺序：从移动方式的对角开始遍历！</strong></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp;</span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] mat) &#123;</span><br><span class="line">        initDpArray(mat);</span><br><span class="line">        moveByDirs();</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initDpArray</span><span class="params">(<span class="keyword">int</span>[][] mat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.row = mat.length;</span><br><span class="line">        <span class="keyword">this</span>.col = mat[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">this</span>.dp = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], Integer.MAX_VALUE / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mat[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveByDirs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        moveLeftOrUp();</span><br><span class="line">        moveLeftOrDown();</span><br><span class="line">        moveRightOrUp();</span><br><span class="line">        moveRightOrDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveLeftOrUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveLeftOrDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; row) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i + <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveRightOrUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = col - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt; col) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i][j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveRightOrDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = col - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; row) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i + <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt; col) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i][j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(m×n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的层序遍历</title>
      <link href="/2021/12/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/2021/12/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h3><span id="more"></span> <img src="/2021/12/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/示例图.png" alt="示例图" style="zoom:67%;"><p><code>以上图为例: [[A],[B,C],[D,E,F,G],[H,I],[J]]</code></p><p>思路：</p><ol><li><p>遍历结点，将结点放入队列中，刚好按层处理；</p></li><li><p>这里有个细节，如何按层处理：</p><p><strong>每次处理时，处理当前队列中的所有结点，这些结点一定是同层！</strong></p></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> currentSize = queue.size();</span><br><span class="line">            List&lt;Integer&gt; layer = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; currentSize; i++) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    layer.add(node.val);</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(layer.size() != <span class="number">0</span>) &#123;</span><br><span class="line">                ans.add(layer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(n)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>定长子数组的最大和</title>
      <link href="/2021/12/08/%E5%AE%9A%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
      <url>/2021/12/08/%E5%AE%9A%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="定长子数组的最大和（-滑动窗口-）"><a href="#定长子数组的最大和（-滑动窗口-）" class="headerlink" title="定长子数组的最大和（ 滑动窗口 ）"></a>定长子数组的最大和（ 滑动窗口 ）</h3><span id="more"></span><blockquote><p>给你一个整数数组 nums 和一个整数 k ，找出三个长度为 k 、互不重叠、</p><p>且 3 * k 项的和最大的子数组，并返回这三个子数组。</p><p>以下标的数组形式返回结果，数组中的每一项分别指示每个子数组的起始位置（下标从 0 开始）。</p><p>如果有多个结果，返回字典序最小的一个。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：nums = [1,2,1,2,6,7,5,1], k = 2</span><br><span class="line">&gt;输出：[0,3,5]</span><br></pre></td></tr></table></figure><p>题目详情参考：<a href="https://leetcode-cn.com/problems/maximum-sum-of-3-non-overlapping-subarrays/">689. 三个无重叠子数组的最大和 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><h3 id="解法一：滑动窗口"><a href="#解法一：滑动窗口" class="headerlink" title="解法一：滑动窗口"></a>解法一：滑动窗口</h3><p>思路：三个长度为 k 且不互相重叠的子数组最大和，先考虑一个、两个的情况。</p><h4 id="模型一：单个长度为-k-的子数组最大和"><a href="#模型一：单个长度为-k-的子数组最大和" class="headerlink" title="模型一：单个长度为 k 的子数组最大和"></a>模型一：单个长度为 k 的子数组最大和</h4><p>思路：规定一个长度为 k 的窗口，向右滑动，寻找最大和。</p><ol><li>求和时不需要每次都重新求和，这样会增加时间复杂度；</li><li>窗口向右滑动过程中，减去左值，加上新值，即为这一段数组和；</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSumOfOneSubarray(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> sum1 = <span class="number">0</span>, maxSum1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            sum1 += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sum1 &gt; maxSum1) &#123;</span><br><span class="line">                    maxSum1 = sum1;</span><br><span class="line">                    ans[<span class="number">0</span>] = i - k + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sum1 -= nums[i - k + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p><h4 id="模型二：两个长度为-k-的不重叠子数组最大和"><a href="#模型二：两个长度为-k-的不重叠子数组最大和" class="headerlink" title="模型二：两个长度为 k 的不重叠子数组最大和"></a>模型二：两个长度为 k 的不重叠子数组最大和</h4><p>思路：规定两个长度为 k 的不重叠窗口，第一个从 [0,k-1]开始，第二个从[k,2k - 1]开始；</p><ol><li>两个窗口同时向右滑动，滑动过程中，记录更新第一个窗口的最大和值 <code>maxSum1</code>；</li><li>每次记录更新 <code>maxSum1</code> + <code>sum2</code> 的最大值，并存储下标信息即对应位置；</li></ol><p>思路正确性的说明：</p><ol><li>对于窗口二而言，每次加上的一定是前面不与自己重叠的最大窗口值；</li><li>而对于整体而言，两个窗口和的最大值也在不断随之更新。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSumOfTwoSubarrays(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> sum1 = <span class="number">0</span>, maxSum1 = <span class="number">0</span>, maxSum1Idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum2 = <span class="number">0</span>, maxSum12 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            sum1 += nums[i - k];</span><br><span class="line">            sum2 += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k * <span class="number">2</span> - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sum1 &gt; maxSum1) &#123;</span><br><span class="line">                    maxSum1 = sum1;</span><br><span class="line">                    maxSum1Idx = i - k * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (maxSum1 + sum2 &gt; maxSum12) &#123;</span><br><span class="line">                    maxSum12 = maxSum1 + sum2;</span><br><span class="line">                    ans[<span class="number">0</span>] = maxSum1Idx;</span><br><span class="line">                    ans[<span class="number">1</span>] = i - k + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sum1 -= nums[i - k * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">                sum2 -= nums[i - k + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p><h4 id="该题目的解析："><a href="#该题目的解析：" class="headerlink" title="该题目的解析："></a>该题目的解析：</h4><p>思路：规定两个长度为 k 的不重叠窗口，分别从[0,k-1]、[k,2k - 1]、[2k,3k-1]开始，；</p><ol><li>我们同时向右滑动这三个窗口，按照模型二的方法并维护 maxSum12 及其对应位置；</li><li>每次滑动时，计算当前 maxSum12 与 sum3之和；</li><li>统计这一过程中的 maxSum12 + sum3 的最大值及其对应位置；</li><li>当且仅当最大和值大于记录时，才更新下标，保证字典序。</li></ol><p><strong>细节：在更新 maxSum12 时也更新两个窗口的起始位置，因为第一个窗口最大时，不意味着和最大。</strong></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSumOfThreeSubarrays(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> sum1 = <span class="number">0</span>, maxSum1 = <span class="number">0</span>, maxSum1Index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum2 = <span class="number">0</span>, maxSum12 = <span class="number">0</span>, maxSum2Index1 = <span class="number">0</span>, maxSum2Index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum3 = <span class="number">0</span>, maxTotal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * k; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum1 += nums[i - <span class="number">2</span> * k];</span><br><span class="line">            sum2 += nums[i - k];</span><br><span class="line">            sum3 += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">3</span> * k - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sum1 &gt; maxSum1) &#123;</span><br><span class="line">                    maxSum1 = sum1;</span><br><span class="line">                    maxSum1Index = i - <span class="number">3</span> * k + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sum2 + maxSum1 &gt; maxSum12) &#123;</span><br><span class="line">                    maxSum12 = sum2 + maxSum1;</span><br><span class="line">                    maxSum2Index1 = maxSum1Index;</span><br><span class="line">                    maxSum2Index2 = i - <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sum3 + maxSum12 &gt; maxTotal) &#123;</span><br><span class="line">                    maxTotal = sum3 + maxSum12;</span><br><span class="line">                    ans[<span class="number">0</span>] = maxSum2Index1;</span><br><span class="line">                    ans[<span class="number">1</span>] = maxSum2Index2;</span><br><span class="line">                    ans[<span class="number">2</span>] = i - k + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sum1 -= nums[i - k * <span class="number">3</span> + <span class="number">1</span>];</span><br><span class="line">                sum2 -= nums[i - k * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">                sum3 -= nums[i - k + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动零</title>
      <link href="/2021/12/06/%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
      <url>/2021/12/06/%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="移动零（-双指针-）"><a href="#移动零（-双指针-）" class="headerlink" title="移动零（ 双指针 ）"></a>移动零（ 双指针 ）</h3><span id="more"></span><blockquote><blockquote><p>给定数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="解法一：模拟遍历"><a href="#解法一：模拟遍历" class="headerlink" title="解法一：模拟遍历"></a>解法一：模拟遍历</h3><p>思路：遍历数组，每次遇到 <code>0</code> ，将此位置后的所有元素前移，然后数组末尾补 <code>0</code> ；</p><p>细节：特殊情况 <code>0 0 1 0 3 2</code> → <code>0 1 0 3 2 0</code>，此时下标已经向前移动了，会越过 <code>0</code> 。</p><ol><li>每次移动数组后，向后遍历，如果全为 <code>0</code> 则退出；</li><li>如果不全为 <code>0</code>，并且此时 <code>i</code> 下标的元素为 <code>0</code>，那么回退一步；</li><li>上面都不满足，继续遍历，不需要更改循环。</li></ol><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 遇到 0,位置后的所有元素前移，末尾补 0 </span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; nums.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                    nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                nums[nums.length - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 防止出现移动后,少处理0的情况</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                        i--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果全是0,则结束</span></span><br><span class="line">                <span class="keyword">if</span>(j == nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n^2)<br>&amp;空间复杂度:O(n)<br>\end{align}<br>$$</p><hr><h3 id="解法二：双指针"><a href="#解法二：双指针" class="headerlink" title="解法二：双指针"></a>解法二：双指针</h3><p>思路：使用双指针，<strong>左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。</strong></p><ol><li><p>右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。</p></li><li><p>注意到以下性质：</p><ol><li><p>左指针左边均为非零数；</p></li><li><p>右指针左边直到左指针处均为零。</p></li></ol></li><li><p>因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。</p></li></ol><p><strong>难点说明：</strong></p><ol><li>如果当前左右指针相等，那么二者同时移动，即均加一；</li><li>当遇到 <code>0</code> 时，快指针继续向前寻找非零元素，慢指针则停留在 <code>0</code> 处等待； </li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[slow];</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">                nums[fast++] = temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fast++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环形链表</title>
      <link href="/2021/12/06/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/12/06/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="环形链表（-双指针-）"><a href="#环形链表（-双指针-）" class="headerlink" title="环形链表（ 双指针 ）"></a>环形链表（ 双指针 ）</h3><span id="more"></span><blockquote><blockquote><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>题目详情参考：<a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote></blockquote><h3 id="解法一：数学"><a href="#解法一：数学" class="headerlink" title="解法一：数学"></a>解法一：数学</h3><p>思路：因为该题目的链表长度有上限，所以遍历链表，记录节点数，如果大于上限，那么一定存在环。</p><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count &gt; <span class="number">100001</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p><hr><h3 id="解法二：哈希表"><a href="#解法二：哈希表" class="headerlink" title="解法二：哈希表"></a>解法二：哈希表</h3><p>思路：遍历过程中哈希表记录即可，出现重复即存在环。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(head)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(n)<br>\end{align}<br>$$</p><hr><h3 id="解法三：双指针"><a href="#解法三：双指针" class="headerlink" title="解法三：双指针"></a>解法三：双指针</h3><p>思路：基于<strong>Floyd判圈算法（龟兔赛跑算法）</strong></p><ol><li>定义两个指针：快指针、慢指针，并且快指针移动比慢指针快；</li><li>快指针每次移动两个结点，慢指针每次移动一个结点；</li><li>如果快指针和慢指针对应的结点相同，那么说明存在环。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速幂</title>
      <link href="/2021/12/06/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
      <url>/2021/12/06/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<h3 id="快速幂（-数学-）"><a href="#快速幂（-数学-）" class="headerlink" title="快速幂（ 数学 ）"></a>快速幂（ 数学 ）</h3><span id="more"></span><h3 id="基础快速幂"><a href="#基础快速幂" class="headerlink" title="基础快速幂"></a>基础快速幂</h3><blockquote><blockquote><p>实现 pow(x , n) ，即计算 x 的 n 次幂函数（即，x<sup>n</sup> )。</p><p>题目详情参考：<a href="https://leetcode-cn.com/problems/powx-n/solution/powx-n-by-leetcode-solution/">Pow(x, n) - Pow(x, n) - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote></blockquote><p>思路：分治算法，不去累乘，减少计算量。</p><p>比如计算 x<sup>64</sup>，如果累乘需要计算64次，但是如果按照下面的方法：</p><p>x → x<sup>2</sup> → x<sup>4</sup> → x<sup>8</sup> → x<sup>16</sup> → x<sup>32</sup> → x<sup>64</sup>  只需要计算6次，大大减少了计算量。</p><p><strong>迭代比递归节省了空间，因为递归过程中会使用栈空间。</strong></p><h4 id="递归-代码如下："><a href="#递归-代码如下：" class="headerlink" title="递归    代码如下："></a>递归    代码如下：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> pow(x * x, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> pow(x * x, n / <span class="number">2</span>) * x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            n = Math.abs(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pow(x,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(logn)<br>&amp;空间复杂度:O(logn)<br>\end{align}<br>$$</p><h4 id="迭代-代码如下："><a href="#迭代-代码如下：" class="headerlink" title="迭代    代码如下："></a>迭代    代码如下：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// 贡献的初始值为 x</span></span><br><span class="line">        <span class="keyword">double</span> x_contribute = x;</span><br><span class="line">        <span class="comment">// 在对 N 进行二进制拆分的同时计算答案</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span></span><br><span class="line">                ans *= x_contribute;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将贡献不断地平方</span></span><br><span class="line">            x_contribute *= x_contribute;</span><br><span class="line">            <span class="comment">// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span></span><br><span class="line">            N /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(logn)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p><hr><h3 id="进阶快速幂"><a href="#进阶快速幂" class="headerlink" title="进阶快速幂"></a>进阶快速幂</h3><blockquote><blockquote><p>你的任务是计算 <code>a<sup>b</sup></code> 对 <code>1337</code> 取模，<code>a</code> 是一个正整数，<code>b</code> 是一个非常大的正整数且会以数组形式给出。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = 2, b = [3]</span><br><span class="line">输出：8</span><br></pre></td></tr></table></figure><p>题目详情参考：<a href="https://leetcode-cn.com/problems/super-pow/">372. 超级次方 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote></blockquote><p>思路：依然用到快速幂，但是需要数学推导，推导如下：</p><p><img src="/2021/12/06/%E5%BF%AB%E9%80%9F%E5%B9%82/%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC.png" alt="公式推导"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            ans = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) ans * pow(a, b[i]) % MOD);</span><br><span class="line">            a = pow(a, <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                res = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) res * x % MOD);</span><br><span class="line">            &#125;</span><br><span class="line">            x = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) x * x % MOD);</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(\sum\limits_{i=0}^{m-1}logb_i)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p><p><strong>上述方法是倒序遍历，该题还有一种正序遍历解法：秦九韶算法</strong></p><p>感兴趣可以参考下面题解：<a href="https://leetcode-cn.com/problems/super-pow/solution/chao-ji-ci-fang-by-leetcode-solution-ow8j/">超级次方 - 超级次方 - 力扣（LeetCode） (leetcode-cn.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的三种遍历</title>
      <link href="/2021/12/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86/"/>
      <url>/2021/12/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h3 id="二叉树的三种遍历"><a href="#二叉树的三种遍历" class="headerlink" title="二叉树的三种遍历"></a>二叉树的三种遍历</h3><span id="more"></span><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>给定一棵二叉树的结构如下图所示，分别给出 前序、中序、后序遍历的三种结果：</p> <img src="/2021/12/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86/示例图.png" alt="示例二叉树" style="zoom:67%;"><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">前序：A B D E H C F I J G</span><br><span class="line"></span><br><span class="line">中序：D B H E A J I F C G</span><br><span class="line"></span><br><span class="line">后序：D H E B J I F G C A</span><br></pre></td></tr></table></figure><p><strong>1. 三种方式得到遍历结果</strong></p><p>​    递归、迭代、Morris算法</p><p><strong>2. 先序遍历得到根节点到某一结点的路径</strong></p><p>​    比如上述 A → I ：R L R</p><p><strong>不要使用String，因为String是定长的，因此可能会超出内存限制，使用StringBuilder代替。</strong></p><hr><h3 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h3><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    StringBuilder path = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先序遍历以及给出某一结点路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorderDfs</span><span class="params">(TreeNode root,StringBuilder path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果查询到指定结点值 返回路径</span></span><br><span class="line">        <span class="keyword">if</span>(root.val == res.val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.path.append(path.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先放入根节点</span></span><br><span class="line">        res.add(root.val);</span><br><span class="line">        preorderDfs(root.left,path.append(<span class="string">&#x27;L&#x27;</span>));</span><br><span class="line">        path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">        preorderDfs(root.right,path.append(<span class="string">&#x27;R&#x27;</span>));</span><br><span class="line">        path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorderDfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先放入左节点</span></span><br><span class="line">        inorderDfs(root.left);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        inorderDfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorderDfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postorderDfs(root.left);</span><br><span class="line">        postorderDfs(root.right);</span><br><span class="line">        <span class="comment">// 最后放入根节点</span></span><br><span class="line">        res.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">traversal</span><span class="params">(TreeNode root,<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value; </span><br><span class="line">        preorderDfs(root,<span class="keyword">new</span> StringBuilder())</span><br><span class="line">        inorderDfs(root);</span><br><span class="line">        postorderDfs(root)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(n)<br>\end{align}<br>$$</p><hr><h3 id="迭代遍历"><a href="#迭代遍历" class="headerlink" title="迭代遍历"></a>迭代遍历</h3><p>可以用迭代的方式实现方法一的递归函数，两种方式是等价的，</p><p><strong>区别在于递归的时候隐式地维护了一个栈，在迭代的时候需要显式地将这个栈模拟出来，</strong></p><p>其余的实现与细节都相同。</p><p><strong>迭代遍历相较于递归的优势：可以快速退出遍历。</strong></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                res.add(node.val);</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            ans.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (root.right == <span class="keyword">null</span> || root.right == prev) &#123;</span><br><span class="line">                ans.add(root.val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(n)<br>\end{align}<br>$$</p><hr><h3 id="Morris算法"><a href="#Morris算法" class="headerlink" title="Morris算法"></a>Morris算法</h3>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>房屋间收集雨水</title>
      <link href="/2021/12/04/%E6%88%BF%E5%B1%8B%E9%97%B4%E6%94%B6%E9%9B%86%E9%9B%A8%E6%B0%B4/"/>
      <url>/2021/12/04/%E6%88%BF%E5%B1%8B%E9%97%B4%E6%94%B6%E9%9B%86%E9%9B%A8%E6%B0%B4/</url>
      
        <content type="html"><![CDATA[<h3 id="房屋间收集雨水（-贪心-）"><a href="#房屋间收集雨水（-贪心-）" class="headerlink" title="房屋间收集雨水（ 贪心 ）"></a>房屋间收集雨水（ 贪心 ）</h3><span id="more"></span><blockquote><p>给你一个下标从 0 开始的字符串 street 。</p><p>street 中每个字符要么是表示房屋的 ‘H’ ，要么是表示空位的 ‘.’ 。</p><p>你可以在 空位 放置水桶，从相邻的房屋收集雨水。</p><p>位置在 i - 1 或者 i + 1 的水桶可以收集位置为 i 处房屋的雨水。</p><p>一个水桶如果相邻两个位置都有房屋，那么它可以收集 两个 房屋的雨水。</p><p>在确保每个房屋旁边都至少有一个水桶的前提下，请你返回需要的 最少 水桶数。如果无解请返回 -1 。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：street = &quot;H..H&quot;</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p>题目详情参考：<a href="https://leetcode-cn.com/problems/minimum-number-of-buckets-required-to-collect-rainwater-from-houses/">2086. 从房屋收集雨水需要的最少水桶数 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><p>思路：<strong>如果房屋周围可以收集雨水，那么先判断是否左边可以共享，不行的话尽可能使用右边空间。</strong></p><ol><li>创建变量 <code>index</code> 记录可以被共享的位置，遍历更新即可；</li><li>先判断左边是否存在空位以及是否已被使用，如果可以，那么跳过；</li><li>反之，判断右边是否存在空位，如果可以，记录位置并且更新结果；</li><li>如果左右均没有空位，返回 <code>-1</code>;</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumBuckets</span><span class="params">(String street)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = street.length();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录可以被共享的位置</span></span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(street.charAt(i) == <span class="string">&#x27;H&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 先判断左边是否可以共享</span></span><br><span class="line">                <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; street.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(index != i - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">// 如果左边没有被共享过 优先选择右边</span></span><br><span class="line">                        <span class="keyword">if</span>(i + <span class="number">1</span> &lt; len &amp;&amp; street.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                            index = i + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ans++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i + <span class="number">1</span> &lt; len &amp;&amp; street.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    index = i + <span class="number">1</span>;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 贪心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓄水</title>
      <link href="/2021/12/04/%E8%93%84%E6%B0%B4/"/>
      <url>/2021/12/04/%E8%93%84%E6%B0%B4/</url>
      
        <content type="html"><![CDATA[<h3 id="蓄水（-贪心-）"><a href="#蓄水（-贪心-）" class="headerlink" title="蓄水（ 贪心 ）"></a>蓄水（ 贪心 ）</h3><span id="more"></span><blockquote><blockquote><p>给定 N 个无限容量且初始均空的水缸，每个水缸配有一个水桶用来打水，</p><p>第 i 个水缸配备的水桶容量记作 bucket[i]。</p><p>有以下两种操作：</p><p>升级水桶：选择任意一个水桶，使其容量增加为 bucket[i]+1<br>蓄水：将全部水桶接满水，倒入各自对应的水缸<br>每个水缸对应最低蓄水量记作 vat[i]，返回至少需要多少次操作可以完成所有水缸蓄水要求。</p><p>注意：实际蓄水量 达到或超过 最低蓄水量，即完成蓄水要求。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：bucket = [1,3], vat = [6,8]</span><br><span class="line">&gt;输出：4</span><br><span class="line">&gt;解释：</span><br><span class="line">&gt;第 1 次操作升级 bucket[0]；</span><br><span class="line">&gt;第 2 ~ 4 次操作均选择蓄水，即可完成蓄水要求。</span><br></pre></td></tr></table></figure><p>题目详情参考：<a href="https://leetcode-cn.com/problems/o8SXZn/">LCP 33. 蓄水 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote></blockquote><p>思路：<strong>如果要升级水桶容量，那么就尽早升级，这一定是次数最少的情况。</strong></p><ol><li>题目数据规模不大，枚举出尽可能大的情况，得到最优解；</li><li><strong>（升级次数 + 初始蓄水量）× 倒水次数 = 容量</strong>；</li><li><strong>总次数 = 倒水次数 + 总升级次数</strong>；</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">storeWater</span><span class="params">(<span class="keyword">int</span>[] bucket, <span class="keyword">int</span>[] vat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">10001</span>;</span><br><span class="line">        <span class="comment">// 枚举倒水次数1-10000</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> pour = <span class="number">0</span>; pour &lt;= <span class="number">10000</span>; pour++) &#123; </span><br><span class="line">            <span class="keyword">if</span> (pour &gt;= ans) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">int</span> upgrade = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 枚举每个水桶，计算总升级次数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vat.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 贪心 先升级必定减少次数</span></span><br><span class="line">                <span class="comment">// （升级次数 + 初始蓄水量）* 倒水次数 = 容量</span></span><br><span class="line">                <span class="keyword">int</span> cur = (<span class="keyword">int</span>)Math.ceil((<span class="keyword">double</span>)vat[i] / pour - bucket[i]); </span><br><span class="line">                upgrade += cur &gt; <span class="number">0</span> ? cur : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (upgrade &gt;= ans) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 总次数 = 倒水次数 + 总升级次数</span></span><br><span class="line">            ans = Math.min(ans, upgrade + pour); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(10^4×n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 贪心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>螺旋矩阵</title>
      <link href="/2021/12/03/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
      <url>/2021/12/03/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="螺旋矩阵（数学）"><a href="#螺旋矩阵（数学）" class="headerlink" title="螺旋矩阵（数学）"></a>螺旋矩阵（数学）</h3><span id="more"></span><blockquote><blockquote><p>总结螺旋矩阵的三种问题：</p><ol><li>由外到内，如何构造螺旋矩阵</li><li>由内到位，如何输出螺旋矩阵</li><li>如何确定螺旋矩阵的位置元素</li></ol></blockquote></blockquote><h3 id="螺旋矩阵Ⅰ"><a href="#螺旋矩阵Ⅰ" class="headerlink" title="螺旋矩阵Ⅰ"></a>螺旋矩阵Ⅰ</h3><blockquote><blockquote><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><p>题目详情参考：<a href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote></blockquote><p>思路：模拟出 <code>顺时针螺旋顺序</code></p><ol><li>创建一个  <code>visited</code> 矩阵，用来判断是否被选取过；</li><li>创建方向数组 <code>dirs</code>，用来改变螺旋的方向；</li><li>创建变量 <code>currX</code>、<code>currY</code>，用来记录当前位置；</li><li><strong>当模拟遍历时，如果出界或者该位置已被遍历过，那么改变方向。</strong></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[row][col];</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> currX = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> currY = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> currDir = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (ans.size() != row * col) &#123;</span><br><span class="line">            <span class="keyword">if</span> (currX &gt;= <span class="number">0</span> &amp;&amp; currY &gt;= <span class="number">0</span> &amp;&amp; currX &lt; row </span><br><span class="line">                &amp;&amp; currY &lt; col &amp;&amp; !visited[currX][currY]) &#123;</span><br><span class="line">                ans.add(matrix[currX][currY]);</span><br><span class="line">                visited[currX][currY] = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                currX -= dirs[currDir][<span class="number">0</span>];</span><br><span class="line">                currY -= dirs[currDir][<span class="number">1</span>];</span><br><span class="line">                currDir++;</span><br><span class="line">                currDir %= <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            currX += dirs[currDir][<span class="number">0</span>];</span><br><span class="line">            currY += dirs[currDir][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(m×n)<br>&amp;空间复杂度:O(m×n)<br>\end{align}<br>$$</p><hr><h3 id="螺旋矩阵Ⅱ"><a href="#螺旋矩阵Ⅱ" class="headerlink" title="螺旋矩阵Ⅱ"></a>螺旋矩阵Ⅱ</h3><blockquote><blockquote><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n × n</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p>题目详情参考：<a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote></blockquote><p>思路：</p><ol><li><p>与螺旋矩阵Ⅰ的思路大体相似，不过是生成螺旋矩阵；</p></li><li><p>创建变量 <code>num</code> 填充并记录螺旋矩阵元素，遍历即可。</p></li></ol><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> currX = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> currY = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> currDir = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (num &lt;= n * n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (currX &gt;= <span class="number">0</span> &amp;&amp; currY &gt;= <span class="number">0</span> &amp;&amp; currX &lt; n </span><br><span class="line">                &amp;&amp; currY &lt; n &amp;&amp; !visited[currX][currY]) &#123;</span><br><span class="line">                ans[currX][currY] = num++;</span><br><span class="line">                visited[currX][currY] = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                currX -= dirs[currDir][<span class="number">0</span>];</span><br><span class="line">                currY -= dirs[currDir][<span class="number">1</span>];</span><br><span class="line">                currDir++;</span><br><span class="line">                currDir %= <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            currX += dirs[currDir][<span class="number">0</span>];</span><br><span class="line">            currY += dirs[currDir][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(m×n)<br>&amp;空间复杂度:O(m×n)<br>\end{align}<br>$$</p><hr><h3 id="螺旋矩阵Ⅲ"><a href="#螺旋矩阵Ⅲ" class="headerlink" title="螺旋矩阵Ⅲ"></a>螺旋矩阵Ⅲ</h3><blockquote><blockquote><p>在 R 行 C 列的矩阵上，我们从 (r0, c0) 面朝东面开始</p><p>这里，网格的西北角位于第一行第一列，网格的东南角位于最后一行最后一列。</p><p>现在，我们以顺时针按螺旋状行走，访问此网格中的每个位置。</p><p>每当我们移动到网格的边界之外时，我们会继续在网格之外行走（但稍后可能会返回到网格边界）。</p><p>最终，我们到过网格的所有 R * C 个空间。</p><p>按照访问顺序返回表示网格位置的坐标列表。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：R = 1, C = 4, r0 = 0, c0 = 0</span><br><span class="line">&gt;输出：[[0,0],[0,1],[0,2],[0,3]]</span><br></pre></td></tr></table></figure></blockquote></blockquote><p>思路：前面两个螺旋矩阵都是由外向内旋转，而此矩阵是由内向外旋转</p><ol><li>首先扩充该矩阵为 <code>n × n</code>  的方形矩阵，其中 <code>n</code> 为选中位置距离边界的最大距离；</li><li><strong>模拟遍历可知，最后的终点是拓展矩阵的右上角位置，那么可以反方向旋转求解；</strong></li><li>至此，已经转化为前两个问题，不过仍有需要注意的地方：<ol><li>起始位置和方向发生改变</li><li>需要记录拓展矩阵中哪些是需要记录的元素</li><li>如何确定原矩阵的位置</li></ol></li></ol><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] spiralMatrixIII(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> rStart, <span class="keyword">int</span> cStart) &#123;</span><br><span class="line">        <span class="keyword">int</span> nums = rows * cols;</span><br><span class="line">        <span class="keyword">boolean</span>[][] matrix = getExpendedMatrix(rows, cols, rStart, cStart);</span><br><span class="line">        <span class="keyword">int</span> sideLength = getSideLength(rows, cols, rStart, cStart);</span><br><span class="line">        <span class="keyword">return</span> getSipralOrder(matrix, nums, sideLength - rStart, sideLength - cStart);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][] getExpendedMatrix(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> rStart, <span class="keyword">int</span> cStart) &#123;</span><br><span class="line">        <span class="keyword">int</span> sideLength = getSideLength(rows, cols, rStart, cStart);</span><br><span class="line">        <span class="keyword">int</span> matrixSize = sideLength * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">boolean</span>[matrixSize][matrixSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = sideLength - rStart; i &lt; sideLength - rStart + rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = sideLength - cStart; j &lt; sideLength - cStart + cols; j++) &#123;</span><br><span class="line">                matrix[i][j] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSideLength</span><span class="params">(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> rStart, <span class="keyword">int</span> cStart)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxRow = Math.max(rStart, rows - <span class="number">1</span> - rStart);</span><br><span class="line">        <span class="keyword">int</span> maxCol = Math.max(cStart, cols - <span class="number">1</span> - cStart);</span><br><span class="line">        <span class="keyword">int</span> sideLength = Math.max(maxRow, maxCol);</span><br><span class="line">        <span class="keyword">return</span> sideLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] getSipralOrder(<span class="keyword">boolean</span>[][] matrix, <span class="keyword">int</span> nums, <span class="keyword">int</span> deltaX, <span class="keyword">int</span> deltaY) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = matrix.length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[size][size];</span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[nums][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> currX = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> currY = size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> currDir = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (index != nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (currX &gt;= <span class="number">0</span> &amp;&amp; currY &gt;= <span class="number">0</span> &amp;&amp; currX &lt; size </span><br><span class="line">                &amp;&amp; currY &lt; size &amp;&amp; !visited[currX][currY]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[currX][currY]) &#123;</span><br><span class="line">                    ans[nums - index - <span class="number">1</span>][<span class="number">0</span>] = currX - deltaX;</span><br><span class="line">                    ans[nums - index - <span class="number">1</span>][<span class="number">1</span>] = currY - deltaY;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">                visited[currX][currY] = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                currX -= dirs[currDir][<span class="number">0</span>];</span><br><span class="line">                currY -= dirs[currDir][<span class="number">1</span>];</span><br><span class="line">                currDir++;</span><br><span class="line">                currDir %= <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            currX += dirs[currDir][<span class="number">0</span>];</span><br><span class="line">            currY += dirs[currDir][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(m×n)<br>&amp;空间复杂度:O(m×n)<br>\end{align}<br>$$</p><hr><h3 id="螺旋矩阵Ⅳ"><a href="#螺旋矩阵Ⅳ" class="headerlink" title="螺旋矩阵Ⅳ"></a>螺旋矩阵Ⅳ</h3><blockquote><blockquote><p>给定一个 <code>n * n</code> 的矩阵，螺旋排列，如何确定某一位置的元素？</p><p>题目详情参考：<a href="https://leetcode-cn.com/problems/SNJvJP/">LCP 29. 乐团站位 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote></blockquote><p><img src="/2021/12/03/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E5%9B%BE.png" alt="示例图"></p><ol><li>将矩阵按圈的循环进行分割，再将圈，按照上述形式分割；</li><li>当前坐标为 <em>( xPos , yPos )</em>，首先获得该点所在的圈数，然后进行计算；</li><li>计算当前圈数前所有的点数，一个简单的等差数列求和；</li><li>分类讨论当前点所在圈的位置情况，计算总数，取余即为答案。</li></ol><p><strong>注意事项：</strong></p><ol><li>数据过大，将所有变量声明为 <code>long</code>；</li><li>结果取余时，为 <code>0</code> 时需要特殊考虑；</li><li>分类讨论时，不需要加上边界限制；</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">orchestraLayout</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> xPos, <span class="keyword">int</span> yPos)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 得到当前所在圈数 圈数从 0 开始</span></span><br><span class="line">        <span class="keyword">long</span> numOfTurns = Math.min(xPos, yPos);</span><br><span class="line">        numOfTurns = Math.min(num - <span class="number">1</span> - yPos, numOfTurns);</span><br><span class="line">        numOfTurns = Math.min(num - <span class="number">1</span> - xPos, numOfTurns);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算先前所有的点数和，以及当前圈的边长</span></span><br><span class="line">        <span class="keyword">long</span> preSum = (<span class="number">4</span> * (<span class="keyword">long</span>) num - <span class="number">4</span> * numOfTurns) * numOfTurns;</span><br><span class="line">        <span class="keyword">long</span> sideLength = num - <span class="number">2</span> * numOfTurns - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分类讨论得到目前点数和</span></span><br><span class="line">        <span class="keyword">long</span> currNum;</span><br><span class="line">        <span class="keyword">if</span> (xPos == numOfTurns) &#123;</span><br><span class="line">            currNum = preSum + yPos - numOfTurns + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (yPos == num - <span class="number">1</span> - numOfTurns) &#123;</span><br><span class="line">            currNum = preSum + sideLength + xPos - numOfTurns + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xPos == num - <span class="number">1</span> - numOfTurns) &#123;</span><br><span class="line">            currNum = preSum + sideLength * <span class="number">3</span> - yPos + numOfTurns + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            currNum = preSum + sideLength * <span class="number">4</span> - xPos + numOfTurns + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        currNum %= <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> currNum == <span class="number">0</span> ? <span class="number">9</span> : (<span class="keyword">int</span>) currNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(1)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大子数组和</title>
      <link href="/2021/12/01/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
      <url>/2021/12/01/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="最大子数组和（-动态规划-线段树-）"><a href="#最大子数组和（-动态规划-线段树-）" class="headerlink" title="最大子数组和（ 动态规划 | 线段树 ）"></a>最大子数组和（ 动态规划 | 线段树 ）</h3><span id="more"></span><blockquote><blockquote><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），</p><p>返回其最大和。<strong>子数组</strong> 是数组中的一个连续部分。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">&gt;输出：6</span><br><span class="line">&gt;解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="解法一：动态规划"><a href="#解法一：动态规划" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h3><p>假设数组长度为 <code>n</code> , 下标从 <em>0 ~ n - 1</em>,</p><p>不妨设 <em>f( i )</em> 表示以下标 <em>i</em> 结尾的连续子数组的最大和，那么所求答案即为：<br>$$<br>\max \limits_{0≤i≤n-1} \lbrace f(i) \rbrace<br>$$<br>那么可以得到转移方程：<br>$$<br>f(i) = max \lbrace f(i-1) + nums[i],nums[i] \rbrace<br>$$<br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> preSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            preSum = Math.max(preSum + nums[i], nums[i]);</span><br><span class="line">            ans = Math.max(preSum, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p><hr><h3 id="解法二：线段树"><a href="#解法二：线段树" class="headerlink" title="解法二：线段树"></a>解法二：线段树</h3><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(logn)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无限整数序列中定位数字</title>
      <link href="/2021/11/30/%E6%97%A0%E9%99%90%E6%95%B4%E6%95%B0%E5%BA%8F%E5%88%97%E4%B8%AD%E5%AE%9A%E4%BD%8D%E6%95%B0%E5%AD%97/"/>
      <url>/2021/11/30/%E6%97%A0%E9%99%90%E6%95%B4%E6%95%B0%E5%BA%8F%E5%88%97%E4%B8%AD%E5%AE%9A%E4%BD%8D%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h3 id="第-N-位数字（数学）"><a href="#第-N-位数字（数学）" class="headerlink" title="第 N 位数字（数学）"></a>第 N 位数字（数学）</h3><span id="more"></span><blockquote><blockquote><p>给你一个整数 <code>n</code> ，请你在无限的整数序列 <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...]</code> 中找出并返回第 <code>n</code> 位上的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">11</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="解法一：模拟查找"><a href="#解法一：模拟查找" class="headerlink" title="解法一：模拟查找"></a>解法一：模拟查找</h3><p>思路：将所有数字用字符串拼接，然后直接定位 <code>n</code> 返回当前下标的数字即可。</p><p>错误：因为 <code>n</code> 的取值范围是 <code>1 &lt;= n &lt;= 2^31 - 1</code>，会超出时间限制，无法解答，</p><p>​            实际上经过测试，当数据规模超过 10<sup>6</sup> 的规模时，就会超出时间限制。</p><hr><h3 id="解法二：数学定位"><a href="#解法二：数学定位" class="headerlink" title="解法二：数学定位"></a>解法二：数学定位</h3><p>思路：如果能够确定第 <code>n</code> 位上的数字，所在数字的位数，那么就可以进行定位求解。</p><ol><li><p><code>x</code> 位共计有 9 × 10<sup> x - 1</sup>个数字，共计有 <code>x</code> × 9 × 10<sup> x - 1</sup>位数字；</p></li><li><p>使用 <em>d</em> 和 <em>count</em> 分别表示当前遍历到的位数和当前位数下的所有整数的位数之和；</p></li><li><p>初始时 <code>d = 1</code>、<code>count = 9</code>，而后随之变化；</p></li><li><p>每次将 <em>n</em> 减去 <em>d×count</em>，然后将 <em>d</em> 加 <em>1</em>，将 <em>count</em> 乘 <em>10</em>，直到 <em>n ≤ d×count</em> ;</p></li><li><p>此时的 <code>d</code> 即为第 <code>n</code> 位上数字所在的数字位数，<em>n</em> 是所有 <em>d</em> 位数中从第一位到目标数字的位数；</p></li><li><p>使用目标数字在所有 <em>d</em> 位数中的下标进行计算，下标从 <em>0</em> 开始计数，</p><p>令  <em>index=n−1</em>，则 <em>index</em> 即为目标数字在所有 <em>d</em> 位数中的下标，<em>index</em> 的最小可能取值是 <em>0</em> ;</p></li><li><p>第 <em>n</em> 位数字是第 <em>m</em> 个 <em>d</em> 位数的第  <em>index mod d</em> 位，<strong>注意编号都从 <em>0</em> 开始</strong>;</p></li><li><p>由于最小的 <em>d</em> 位数是 <em>10<sup>d - 1</sup></em>，因此第 <em>n</em> 位数字所在的整数是 <em>10<sup>d - 1</sup> + m</em>，</p><p>该整数的右边第 <em>d − ( index mod d ) − 1</em> 位（计数从 <em>0</em> 开始）即为无限整数序列中的第 <em>n</em> 位。<br>$$<br>m = [\frac{index}{d}]<br>$$</p></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">1</span>, count = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; (<span class="keyword">long</span>) d * count) &#123;</span><br><span class="line">            n -= d * count;</span><br><span class="line">            d++;</span><br><span class="line">            count *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start = (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, d - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> num = start + index / d;</span><br><span class="line">        <span class="keyword">int</span> digitIndex = index % d;</span><br><span class="line">        <span class="keyword">int</span> digit = (num / (<span class="keyword">int</span>)(Math.pow(<span class="number">10</span>, d - digitIndex - <span class="number">1</span>))) % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> digit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(log_{10}n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p><hr><h3 id="解法三：二分优化"><a href="#解法三：二分优化" class="headerlink" title="解法三：二分优化"></a>解法三：二分优化</h3><p>思路：如果范围更广一些，可以对查找 <code>d</code> 的部分进行优化，采用二分查找。</p><p>结合解法二的从 <code>1</code> 开始遍历，当遍历到 <code>9</code> 时，即第九位个数时可知：<br>$$<br>9 × 9 × 10^8 = 8.1 × 10^9 ＞ 2^{31} - 1<br>$$<br>因此只需要在 <code>1 - 9</code> 之间进行二分查找即可。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">1</span>, high = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">if</span> (totalDigits(mid) &lt; n) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> d = low;</span><br><span class="line">        <span class="keyword">int</span> prevDigits = totalDigits(d - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> index = n - prevDigits - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start = (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, d - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> num = start + index / d;</span><br><span class="line">        <span class="keyword">int</span> digitIndex = index % d;</span><br><span class="line">        <span class="keyword">int</span> digit = (num / (<span class="keyword">int</span>) (Math.pow(<span class="number">10</span>, d - digitIndex - <span class="number">1</span>))) % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> digit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalDigits</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> digits = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curLength = <span class="number">1</span>, curCount = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">while</span> (curLength &lt;= length) &#123;</span><br><span class="line">            digits += curLength * curCount;</span><br><span class="line">            curLength++;</span><br><span class="line">            curCount *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(log_{10}n×loglog_{10}n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Next的界面优化</title>
      <link href="/2021/11/29/Hexo%E7%9A%84%E7%95%8C%E9%9D%A2%E4%BC%98%E5%8C%96/"/>
      <url>/2021/11/29/Hexo%E7%9A%84%E7%95%8C%E9%9D%A2%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="Hexo-Next的界面优化"><a href="#Hexo-Next的界面优化" class="headerlink" title="Hexo Next的界面优化"></a>Hexo Next的界面优化</h3><span id="more"></span><h3 id="如何将页面背景改为黑色模式？"><a href="#如何将页面背景改为黑色模式？" class="headerlink" title="如何将页面背景改为黑色模式？"></a>如何将页面背景改为黑色模式？</h3><p>修改 Next 主题下的 _config.yml 配置文件：将 darkmode 的值修改为 true 。</p><p>如果主界面已经设置了 hexo-tag-cloud 标签云的展示，那么修改博客站点的配置文件，</p><p>_config.yml 中标签云模块下的 textColor 更改为 ‘#FFFFFF’ # 白色，或者其他颜色即可。</p><hr><h3 id="如何为页面添加当前浏览进度？"><a href="#如何为页面添加当前浏览进度？" class="headerlink" title="如何为页面添加当前浏览进度？"></a>如何为页面添加当前浏览进度？</h3><p>修改 Next 主题下的 _config.yml 配置文件：</p><p>将 back2top 中的 enable 和 scrollpercent 值修改为 true 。</p><hr><h3 id="如何将页面的首页更改为归档？"><a href="#如何将页面的首页更改为归档？" class="headerlink" title="如何将页面的首页更改为归档？"></a>如何将页面的首页更改为归档？</h3><p>修改 Next 主题下的 _config.yml 配置文件：</p><p>将 menu 下的 home 路径修改为 archive 即可，同时注释掉 archive。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: <span class="regexp">/archives/</span> || fa fa-archive</span><br><span class="line">  <span class="attr">about</span>: <span class="regexp">/about/</span> || fa fa-user</span><br><span class="line">  <span class="attr">tags</span>: <span class="regexp">/tags/</span> || fa fa-tags</span><br><span class="line">  <span class="attr">categories</span>: <span class="regexp">/categories/</span> || fa fa-th</span><br><span class="line">  #archives: <span class="regexp">/archives/</span> || fa fa-archive</span><br><span class="line">  #schedule: <span class="regexp">/schedule/</span> || fa fa-calendar</span><br><span class="line">  #sitemap: /sitemap.xml || fa fa-sitemap</span><br><span class="line">  #commonweal: <span class="regexp">/404/</span> || fa fa-heartbeat</span><br></pre></td></tr></table></figure><p><em>（提醒：如果担心更改错误，备份原文件）</em></p><hr><h3 id="如何为页面添加加载特效？"><a href="#如何为页面添加加载特效？" class="headerlink" title="如何为页面添加加载特效？"></a>如何为页面添加加载特效？</h3><p>参考文章：<a><a href="https://juejin.cn/post/6844903789946896398">Hexo博客NexT主题美化之顶部加载进度条 - 掘金 (juejin.cn)</a></a></p><hr>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本概念</title>
      <link href="/2021/11/29/Java%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2021/11/29/Java%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><span id="more"></span><h3 id="Java语言有哪些优点？"><a href="#Java语言有哪些优点？" class="headerlink" title="Java语言有哪些优点？"></a>Java语言有哪些优点？</h3><ol><li><p>Java为纯面向对象的语言</p></li><li><p>平台无关性</p></li><li><p>Java提供了很多内置的类库</p></li><li><p>提供了对Web应用开发的支持</p></li><li><p>具有较好的安全性和健壮性</p></li><li><p>去除了C++语言中难以理解、容易混淆的特性</p><p><strong>说明：Java语言是由C++语言改进并重新设计而来的</strong></p></li></ol><hr><h3 id="Java与C、C-有什么异同"><a href="#Java与C、C-有什么异同" class="headerlink" title="Java与C、C++有什么异同"></a>Java与C、C++有什么异同</h3><ol><li><p><strong>Java为半编译半解释型语言，而C / C++为编译型语言</strong></p><ul><li>Java程序源代码先经过Java编译器编译成字节码，然后由JVM解释执行</li><li>C / C++程序源代码经过编译和链接后生成可执行的二进制代码</li></ul><p>因此C / C++的执行速度比Java快，但是Java因为JVM可以跨平台执行。</p></li><li><p><strong>Java为纯面向对象的语言，而C++兼具面向过程和面向对象的特点</strong></p><ul><li>Java中除了基本数据类型，所有类型都是类</li><li>Java语言中不存在全局变量或者全局函数</li></ul></li><li><p><strong>Java没有多重继承，但是可以实现多个接口</strong></p></li><li><p><strong>Java语言提供了垃圾回收器来实现垃圾的自动回收</strong></p><ul><li>C++语言中，需要开发人员去管理对内存的分配（申请与释放）</li><li>Java的GC机制，不需要开发人员去关心内存空间</li></ul></li><li><p><strong>Java具有平台无关性</strong></p><ul><li>Java中每种基本类型数据都分配固定长度</li><li>C / C++中在不同的平台会分配不同的字节数</li></ul></li><li><p><strong>其他不同的地方</strong></p><ol><li>Java不支持运算符重载</li><li>Java没有预处理器，但是提供 import 机制</li><li>Java不支持默认函数参数</li><li>Java不提供 goto 语句，但是做为保留关键字</li><li>Java不提供自动强制类型转化，需要显示转换</li><li>Java不包含结构和联合，所有内容封装在类里面</li><li>Java没有指针的概念，避免指针引起的系统问题</li><li>Java提供了一些标准库，用于完成特定的任务，比如 JDBC</li></ol></li></ol><p><strong>常见的一个错误说法：Java语言中的方法属于类的成员</strong></p><p>静态方法：类成员</p><p>非静态方法：实例成员</p><hr><h3 id="为什么需要-main-方法"><a href="#为什么需要-main-方法" class="headerlink" title="为什么需要 main 方法"></a>为什么需要 main 方法</h3><p><code>public static void main(String args[]) &#123;&#125;</code></p><ol><li><p>该方法为Java程序的入口方法，JVM在运行程序时，会首先查找 main() 方法</p></li><li><p>字符串数组 args 为开发人员在命令行状态下与程序交互提供了一种手段</p></li><li><p>因为 main() 方法是程序的入口，要执行一个类的方法，就必须实例化一个对象，</p><p>此时还没有实例化对象，所以该方法需要被定义成 public 和 static </p></li><li><p>main() 方法其他可用的定义格式：</p><p><em><strong>说明：public 和 static 的位置可以互换，没有先后关系</strong></em></p><ol><li><code>static public void main(String args[]) &#123;&#125;</code></li><li><code>public static final void main(String args[]) &#123;&#125;</code></li><li><code>public static synchronized void main(String args[]) &#123;&#125;</code></li></ol><p><strong>但是不可以用 abstract 关键字修饰，因为该函数为程序的入口方法</strong></p></li></ol><hr><h3 id="一个Java文件中是否可以定义多个类"><a href="#一个Java文件中是否可以定义多个类" class="headerlink" title="一个Java文件中是否可以定义多个类"></a>一个Java文件中是否可以定义多个类</h3><ol><li>可以定义多个类，但是<strong>最多只能有一个被 public 修饰的类</strong>，并且该类与文件名相同</li><li>如果没有 public 类，那么文件名随便一个类的名字即可</li><li>当编译此文件时，每一个类都会生成一个对应的字节码文件 .class</li><li><strong>普通方法可以与构造函数有相同的方法名</strong></li></ol><hr><h3 id="Java程序初始化的顺序"><a href="#Java程序初始化的顺序" class="headerlink" title="Java程序初始化的顺序"></a>Java程序初始化的顺序</h3><p>在Java语言中，当实例化对象时，对象所在类的所有成员变量首先要进行初始化，</p><p>只有当所有类成员完成初始化后，才会调用对象所在类的构造函数创建对象。</p><p><strong>程序初始化一般遵循三个原则（优先级依次递减）：</strong></p><ol><li>静态对象（变量）优先于非静态</li><li>父类优先于子类</li><li>按照成员变量的定义顺序进行初始化</li></ol><p><strong>具体的执行顺序如下：</strong></p><p>父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、</p><p>父类非静态变量、父类非静态代码块、父类构造函数、</p><p>子类非静态变量、子类非静态代码块、子类构造函数。</p><p><strong>示例代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Load B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Create B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Load B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Load A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Create A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>程序运行结果是：</strong>Load B    Load B    Load A    Create B    Create A</p><hr><h3 id="Java中的作用域"><a href="#Java中的作用域" class="headerlink" title="Java中的作用域"></a>Java中的作用域</h3><table><thead><tr><th align="center">作用域与可见性</th><th align="center">当前类</th><th align="center">同一package</th><th align="center">子类</th><th align="center">其他package</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">protected</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">default</td><td align="center">√</td><td align="center">√</td><td align="center">×</td><td align="center">×</td></tr><tr><td align="center">private</td><td align="center">√</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><p>注意：private 和 protected 不能用来修饰类</p><hr><h3 id="Java中的标识接口"><a href="#Java中的标识接口" class="headerlink" title="Java中的标识接口"></a>Java中的标识接口</h3><p>标识接口：没有任何方法声明的接口</p><p>作用：仅仅充当一个标识作用，用来表明实现它的类属于一个特定的类型</p><hr><h3 id="Java中的clone方法"><a href="#Java中的clone方法" class="headerlink" title="Java中的clone方法"></a>Java中的clone方法</h3><p>实际编程中，需要从某个已有的对象 A 创建处另外一个与 A 具有相同状态的对象 B，</p><p>并且对 B 的修改不会影响到 A 的自身状态，因此提供了 clone 方法返回一个新的对象。</p><p><strong>使用clone方法的步骤：</strong></p><ol><li>实现clone的类首先需要继承 Cloneable 接口</li><li>在类中重写 Object 类中的 clone() 方法</li><li>在 clone() 方法章调用 super.clone() <strong>（浅复制）</strong></li><li>对对象中的非基本类型的属性也调用 clone() 方法 <strong>（深复制）</strong></li><li>把复制的引用指向原型对象新的克隆体</li></ol><p><strong>示例代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date birth = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getBirth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birth.setMonth(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Obj o = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 实现浅复制</span></span><br><span class="line">            o = (Obj) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现深复制</span></span><br><span class="line">        o.birth = (Date) <span class="keyword">this</span>.getBirth().clone();</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Obj a = <span class="keyword">new</span> Obj();</span><br><span class="line">        Obj b = (Obj)a.clone();</span><br><span class="line">        b.changeDate();</span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span> + a.getBirth());</span><br><span class="line">        System.out.println(<span class="string">&quot;b = &quot;</span> + b.getBirth());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>程序运行结果是：</strong></p><p>a = Mon Nov 29 19:05:03 CST 2021<br>b = Sat May 29 19:05:03 CST 2021</p><hr><h3 id="Java创建对象的四种方式"><a href="#Java创建对象的四种方式" class="headerlink" title="Java创建对象的四种方式"></a>Java创建对象的四种方式</h3><ol><li>通过 new 语句实例化一个对象</li><li>通过反射机制创建对象</li><li>通过 clone() 方法创建一个对象</li><li>通过反序列化的方式船舰一个对象</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Next的基础搭建</title>
      <link href="/2021/11/27/Hexo%E7%9A%84%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/"/>
      <url>/2021/11/27/Hexo%E7%9A%84%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="Hexo-Next的基础搭建"><a href="#Hexo-Next的基础搭建" class="headerlink" title="Hexo Next的基础搭建"></a>Hexo Next的基础搭建</h3><span id="more"></span><h3 id="如何通过GitHub搭建Hexo博客？"><a href="#如何通过GitHub搭建Hexo博客？" class="headerlink" title="如何通过GitHub搭建Hexo博客？"></a>如何通过GitHub搭建Hexo博客？</h3><p>推荐UP主 CodeSheep 的这期视频：<a><a href="https://www.bilibili.com/video/BV1Yb411a7ty?from=search&seid=12143109252670934815&spm_id_from=333.337.0.0">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo_哔哩哔哩_bilibili</a></a></p><p><em>（讲的很详细，并且其他视频对于初学者都很有帮助）</em></p><p><strong>补充：这里如果windows下的cmd操作不适配，推荐下载使用Git，仿照视频操作。</strong></p><hr><h3 id="如何添加-分类-标签-模块？"><a href="#如何添加-分类-标签-模块？" class="headerlink" title="如何添加 分类 | 标签 模块？"></a>如何添加 分类 | 标签 模块？</h3><p>推荐文章：<a><a href="https://juejin.cn/post/6921750181297782798">Hexo添加分类及标签（在Next主题下） - 掘金 (juejin.cn)</a></a></p><p><strong>补充：文章只能属于一个分类，但是可以属于多个标签。</strong></p><hr><h3 id="如何在文章内部署图片？"><a href="#如何在文章内部署图片？" class="headerlink" title="如何在文章内部署图片？"></a>如何在文章内部署图片？</h3><p>推荐文章：<a><a href="https://www.jianshu.com/p/f72aaad7b852">HEXO插入图片（详细版） - 简书 (jianshu.com)</a></a></p><p><strong>补充：</strong></p><ol><li><p>此方法插入图片时，typora或者其他markdown软件中，不可见图片，但是网页部署会出现，</p><p>这里推荐文章：<a>hexo博客如何插入图片 - 知乎 (zhihu.com)](<a href="https://zhuanlan.zhihu.com/p/265077468">https://zhuanlan.zhihu.com/p/265077468</a>)</a>的第三点说明。</p></li><li><p>在执行npm的时候可能会报错，参考下面文章依据情况解决：</p><p><a><a href="https://blog.csdn.net/zzq00zzj/article/details/120826520?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link">(13条消息) npm install报错 npm ERR! 的四种解决办法_zzq00zzj的博客-CSDN博客</a></a></p></li></ol><hr><h3 id="如何添加访客统计和文章阅读次数？"><a href="#如何添加访客统计和文章阅读次数？" class="headerlink" title="如何添加访客统计和文章阅读次数？"></a>如何添加访客统计和文章阅读次数？</h3><p>推荐文章：<a><a href="https://blog.csdn.net/baidu_34310405/article/details/102665373">(13条消息) Hexo Next主题添加访客统计、访问次数统计、文章阅读次数统计_AcLings的博客-CSDN博客</a></a></p><hr><h3 id="如何美化代码块以-Mac-Pane的风格？"><a href="#如何美化代码块以-Mac-Pane的风格？" class="headerlink" title="如何美化代码块以 Mac Pane的风格？"></a>如何美化代码块以 Mac Pane的风格？</h3><p>推荐文章：<a><a href="https://miaosakurai.com/2020/04/20/Hexo-NexT%E7%BE%8E%E5%8C%96%F0%9F%8D%95Mac-Panel%E9%A3%8E%E6%A0%BC%E4%BB%A3%E7%A0%81%E5%9D%97%E9%85%8D%E7%BD%AE/">Hexo+NexT美化🍕Mac Panel风格代码块配置 | 樱井喵 (miaosakurai.com)</a></a></p><hr><h3 id="如何添加-标签云模块-博客背景-搜索功能-模块？"><a href="#如何添加-标签云模块-博客背景-搜索功能-模块？" class="headerlink" title="如何添加 标签云模块 |博客背景 |搜索功能 模块？"></a>如何添加 标签云模块 |博客背景 |搜索功能 模块？</h3><p>推荐博主：<a><a href="https://vic.kim/">归档 | Vicの博客</a></a></p><p><strong>补充：标签云至少存在两个标签才会生效显示</strong></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>祖玛游戏</title>
      <link href="/2021/11/25/%E7%A5%96%E7%8E%9B%E6%B8%B8%E6%88%8F/"/>
      <url>/2021/11/25/%E7%A5%96%E7%8E%9B%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="祖玛游戏（-搜索剪枝-记忆化搜索）"><a href="#祖玛游戏（-搜索剪枝-记忆化搜索）" class="headerlink" title="祖玛游戏（ 搜索剪枝 | 记忆化搜索）"></a>祖玛游戏（ 搜索剪枝 | 记忆化搜索）</h3><span id="more"></span><blockquote><blockquote><p>祖玛游戏的最小步数求解</p><p>题目详情参见：<a><a href="https://leetcode-cn.com/problems/zuma-game/">488. 祖玛游戏 - 力扣（LeetCode） (leetcode-cn.com)</a></a></p></blockquote></blockquote><h3 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h3><ol><li><p>因为插入球的选择和颜色情况太多，并且所带来的影响可能是在多次操作后才能体现出来，</p><p>因此倘若使用贪心算法，很难建立起全局最优的决策，故而不采用贪心；</p></li><li><p>因此需要对状态空间进行枚举，通过穷尽所有的可能来找到最优解，</p><p>并使用剪枝的方法来优化搜索过程；</p></li><li><p>如果使用深度优先搜索，则需要使用记忆化搜索，以避免重复计算相同的状态；</p></li><li><p>该题目只需要得到回合数最少的方案，因此广度优先搜索即可;</p></li><li><p>设当前桌面上有 n 个球，手中持有 m 个球，<br>  $$<br>  则此时一共有C^m_{m+n} * m! = A^m_{m+n}种插入方法<br>  $$</p></li></ol><h3 id="解法一：BFS-剪枝"><a href="#解法一：BFS-剪枝" class="headerlink" title="解法一：BFS + 剪枝"></a>解法一：BFS + 剪枝</h3><p>思路：不妨规定，每一种不同的桌面上球的情况和手中球的情况的组合都是一种不同的状态，</p><p>​            然后对状态空间进行枚举，即可得解答；</p><p><strong>在搜索过程中，需要剪枝来简化算法的复杂性:</strong></p><ul><li>手中颜色相同的球每次选择时只需要考虑其中一个即可；</li><li>只在连续相同颜色的球的开头位置或者结尾位置插入新的颜色相同的球；</li><li>只考虑放置新球后有可能得到更优解的位置，以下三种情况：<ol><li>插入新球与插入位置右侧的球颜色相同</li><li>插入新球与插入位置两侧的球颜色均不相同，且插入位置两侧的球的颜色不同</li><li>插入新球与插入位置两侧的球颜色均不相同，且插入位置两侧的球的颜色相同</li><li>对于如果手中的球全部插入也无法满足新的消除，则直接进行中止</li></ol></li></ul><p><strong>当然还可以有更多的剪枝技巧。</strong></p><p>具体实现的细节处理：</p><ol><li><p>消除操作后，如果导致出现了新的连续三个以上颜色相同的球，</p><p>则继续消除这些球，直到不再满足消除条件；</p></li><li><p>消除时利用栈的特性，每次遇到连续可以消除的球时，将其从栈中弹出；</p></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinStep</span><span class="params">(String board, String hand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] arr = hand.toCharArray();</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        hand = <span class="keyword">new</span> String(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化用队列维护的状态队列：其中的三个元素分别为桌面球状态、手中球状态和回合数</span></span><br><span class="line">        Queue&lt;State&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;State&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> State(board, hand, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化用哈希集合维护的已访问过的状态</span></span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        visited.add(board + <span class="string">&quot; &quot;</span> + hand);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            State state = queue.poll();</span><br><span class="line">            String curBoard = state.board;</span><br><span class="line">            String curHand = state.hand;</span><br><span class="line">            <span class="keyword">int</span> step = state.step;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= curBoard.length(); ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; curHand.length(); ++j) &#123;</span><br><span class="line">                    <span class="comment">// 第 1 个剪枝条件: 当前球的颜色和上一个球的颜色相同</span></span><br><span class="line">                    <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; curHand.charAt(j) == curHand.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 第 2 个剪枝条件: 只在连续相同颜色的球的开头位置插入新球</span></span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; curBoard.charAt(i - <span class="number">1</span>) == curHand.charAt(j)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 第 3 个剪枝条件: 只在以下两种情况放置新球</span></span><br><span class="line">                    <span class="keyword">boolean</span> choose = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">//  - 第 1 种情况 : 当前球颜色与后面的球的颜色相同</span></span><br><span class="line">                    <span class="keyword">if</span> (i &lt; curBoard.length() &amp;&amp; curBoard.charAt(i) == curHand.charAt(j)) &#123;</span><br><span class="line">                        choose = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//  - 第 2 种情况 : 当前后颜色相同且与当前颜色不同时候放置球</span></span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; i &lt; curBoard.length() &amp;&amp; </span><br><span class="line">                        curBoard.charAt(i - <span class="number">1</span>) == curBoard.charAt(i) &amp;&amp; </span><br><span class="line">                        curBoard.charAt(i - <span class="number">1</span>) != curHand.charAt(j)) &#123;</span><br><span class="line">                        choose = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (choose) &#123;</span><br><span class="line">                        String newBoard = clean(curBoard.substring(<span class="number">0</span>, i) + </span><br><span class="line">                                                curHand.charAt(j) + curBoard.substring(i));</span><br><span class="line">                        String newHand = curHand.substring(<span class="number">0</span>, j) + curHand.substring(j + <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">if</span> (newBoard.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        String str = newBoard + <span class="string">&quot; &quot;</span> + newHand;</span><br><span class="line">                        <span class="keyword">if</span> (visited.add(str)) &#123;</span><br><span class="line">                            queue.offer(<span class="keyword">new</span> State(newBoard, newHand, step + <span class="number">1</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">clean</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        Deque&lt;Character&gt; letterStack = <span class="keyword">new</span> ArrayDeque&lt;Character&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; countStack = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">while</span> (!letterStack.isEmpty() &amp;&amp; c != letterStack.peek() &amp;&amp; countStack.peek() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                letterStack.pop();</span><br><span class="line">                countStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (letterStack.isEmpty() || c != letterStack.peek()) &#123;</span><br><span class="line">                letterStack.push(c);</span><br><span class="line">                countStack.push(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                countStack.push(countStack.pop() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!countStack.isEmpty() &amp;&amp; countStack.peek() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">            letterStack.pop();</span><br><span class="line">            countStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!letterStack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">char</span> letter = letterStack.pop();</span><br><span class="line">            <span class="keyword">int</span> count = countStack.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">                sb.append(letter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.reverse();</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    String board;</span><br><span class="line">    String hand;</span><br><span class="line">    <span class="keyword">int</span> step;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">State</span><span class="params">(String board, String hand, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.board = board;</span><br><span class="line">        <span class="keyword">this</span>.hand = hand;</span><br><span class="line">        <span class="keyword">this</span>.step = step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(m×n×A^n_{m+n})\<br>&amp;空间复杂度:O((m+n)×A^m_{m+n})<br>\end{align}<br>$$</p><hr><h3 id="解法二：记忆化搜索（AStar算法）"><a href="#解法二：记忆化搜索（AStar算法）" class="headerlink" title="解法二：记忆化搜索（AStar算法）"></a>解法二：记忆化搜索（AStar算法）</h3><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Integer&gt; dp = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinStep</span><span class="params">(String board, String hand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] arr = hand.toCharArray();</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        hand = <span class="keyword">new</span> String(arr);</span><br><span class="line">        <span class="keyword">int</span> ans = dfs(board, hand);</span><br><span class="line">        <span class="keyword">return</span> ans &lt;= <span class="number">5</span> ? ans : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(String board, String hand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String key = board + <span class="string">&quot; &quot;</span> + hand;</span><br><span class="line">        <span class="keyword">if</span> (!dp.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">6</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; hand.length(); ++j) &#123;</span><br><span class="line">                <span class="comment">// 第 1 个剪枝条件: 当前球的颜色和上一个球的颜色相同</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; hand.charAt(j) == hand.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= board.length(); ++i) &#123;</span><br><span class="line">                    <span class="comment">// 第 2 个剪枝条件: 只在连续相同颜色的球的开头位置插入新球</span></span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; board.charAt(i - <span class="number">1</span>) == hand.charAt(j)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 第 3 个剪枝条件: 只在以下两种情况放置新球</span></span><br><span class="line">                    <span class="keyword">boolean</span> choose = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">//  - 第 1 种情况 : 当前球颜色与后面的球的颜色相同</span></span><br><span class="line">                    <span class="keyword">if</span> (i &lt; board.length() &amp;&amp; board.charAt(i) == hand.charAt(j)) &#123;</span><br><span class="line">                        choose = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//  - 第 2 种情况 : 当前后颜色相同且与当前颜色不同时候放置球</span></span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; i &lt; board.length() &amp;&amp; </span><br><span class="line">                        board.charAt(i - <span class="number">1</span>) == board.charAt(i) &amp;&amp; </span><br><span class="line">                        board.charAt(i - <span class="number">1</span>) != hand.charAt(j)) &#123;</span><br><span class="line">                        choose = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (choose) &#123;</span><br><span class="line">                        String newBoard = clean(board.substring(<span class="number">0</span>, i) + </span><br><span class="line">                                                hand.charAt(j) + board.substring(i));</span><br><span class="line">                        String newHand = hand.substring(<span class="number">0</span>, j) + hand.substring(j + <span class="number">1</span>);</span><br><span class="line">                        res = Math.min(res, dfs(newBoard, newHand) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp.put(key, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">clean</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        Deque&lt;Character&gt; letterStack = <span class="keyword">new</span> ArrayDeque&lt;Character&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; countStack = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">while</span> (!letterStack.isEmpty() &amp;&amp; c != letterStack.peek() &amp;&amp; countStack.peek() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                letterStack.pop();</span><br><span class="line">                countStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (letterStack.isEmpty() || c != letterStack.peek()) &#123;</span><br><span class="line">                letterStack.push(c);</span><br><span class="line">                countStack.push(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                countStack.push(countStack.pop() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!countStack.isEmpty() &amp;&amp; countStack.peek() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">            letterStack.pop();</span><br><span class="line">            countStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!letterStack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">char</span> letter = letterStack.pop();</span><br><span class="line">            <span class="keyword">int</span> count = countStack.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">                sb.append(letter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.reverse();</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    String board;</span><br><span class="line">    String hand;</span><br><span class="line">    <span class="keyword">int</span> step;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">State</span><span class="params">(String board, String hand, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.board = board;</span><br><span class="line">        <span class="keyword">this</span>.hand = hand;</span><br><span class="line">        <span class="keyword">this</span>.step = step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(m×n×A^n_{m+n})\<br>&amp;空间复杂度:O((m+n)×A^m_{m+n})<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 广度优先搜索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维 接雨水</title>
      <link href="/2021/11/25/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E2%85%A1/"/>
      <url>/2021/11/25/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E2%85%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="二维-接雨水（-最小堆-广度优先搜索-）"><a href="#二维-接雨水（-最小堆-广度优先搜索-）" class="headerlink" title="二维 接雨水（ 最小堆 | 广度优先搜索 ）"></a>二维 接雨水（ 最小堆 | 广度优先搜索 ）</h3><span id="more"></span><blockquote><blockquote><p>给你一个 <code>m x n</code> 的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: heightMap = <span class="string">[[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]</span></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure><p>题目详情参见: <a><a href="https://leetcode-cn.com/problems/trapping-rain-water-ii/">407. 接雨水 II - 力扣（LeetCode） (leetcode-cn.com)</a></a></p></blockquote></blockquote><h3 id="解法一：模拟遍历（参照接雨水Ⅰ）"><a href="#解法一：模拟遍历（参照接雨水Ⅰ）" class="headerlink" title="解法一：模拟遍历（参照接雨水Ⅰ）"></a>解法一：模拟遍历（参照接雨水Ⅰ）</h3><p>思路：一维转化为二维，那么是否可以同样的思路去解答？</p><ol><li>对于每个点，寻找所在行左右最大值的最小值，寻找所在列上下最大值的最小值；</li><li>然后取这两个值的最小值，减去当前位置的高度，即为此位置接雨水量。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trapRainWater</span><span class="params">(<span class="keyword">int</span>[][] heightMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = heightMap.length;</span><br><span class="line">        <span class="keyword">int</span> col = heightMap[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> curr = heightMap[i][j];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> minRow = getMinRow(heightMap,i,j,col);</span><br><span class="line">                <span class="keyword">int</span> minCol = getMinCol(heightMap,i,j,row);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果均大于当前位置，那么可以接雨水</span></span><br><span class="line">                <span class="keyword">if</span>(minCol &gt; curr &amp;&amp; minRow &gt; curr) &#123;</span><br><span class="line">                    ans += Math.min(minRow,minCol);</span><br><span class="line">                    ans -= heightMap[i][j];</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找所在行的左右最大值的最小值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMinRow</span><span class="params">(<span class="keyword">int</span>[][] heightMap,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftMax = heightMap[x][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> rightMax = heightMap[x][col - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; y; k++) &#123;</span><br><span class="line">            leftMax = Math.max(leftMax,heightMap[x][k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = y; k &lt; col; k++) &#123;</span><br><span class="line">            rightMax = Math.max(rightMax,heightMap[x][k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(leftMax,rightMax);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找所在列的上下最大值的最小值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMinCol</span><span class="params">(<span class="keyword">int</span>[][] heightMap,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> upMax = heightMap[<span class="number">0</span>][y];</span><br><span class="line">        <span class="keyword">int</span> downMax = heightMap[row - <span class="number">1</span>][y];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; x; k++) &#123;</span><br><span class="line">            upMax = Math.max(upMax,heightMap[k][y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = x; k &lt; row; k++) &#123;</span><br><span class="line">             downMax = Math.max(downMax,heightMap[k][y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(upMax,downMax);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个思路解答是错误的，因为当前位置可能会溢出流向其他区域！</p><p>比如：<code>[[12,13,1,12],[13,4,13,12],[13,8,10,12],[12,13,12,12],[13,13,13,13]]</code></p><p>按照上述做法的答案<code>15</code>，正确答案<code>14</code>。</p><p><strong>因此该方块自身的高度比其上下左右四个相邻的方块接水后的高度都要低。</strong></p><hr><h3 id="解法二：最小堆"><a href="#解法二：最小堆" class="headerlink" title="解法二：最小堆"></a>解法二：最小堆</h3><p>思路：反思解法一的过程，思考总结什么样的方块能接水?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 该方块不为最外层的方块；</span><br><span class="line">- 该方块自身的高度比其上下左右四个相邻的方块接水后的高度都要低；</span><br></pre></td></tr></table></figure><ol><li><p>假设方块的索引为 <em>(i,j)</em>，方块的高度为 <em>heightMap[i][j]</em>，方块接水后的高度为 <em>water[i][j]</em>；</p></li><li><p>并且 <em>water[i][j] = max(heightMap[i][j], min(water[i−1][j], water[i+1][j], water[i][j−1], water[i][j+1]))</em>；</p></li><li><p>因此方块 <em>(i,j)</em> 实际接水的容量计算公式为 <em>water[i][j] − heightMap[i][j]</em>;</p></li><li><p>因为最外层的方块无法接水，因此最外层的方块 <em>water[i][j] = heightMap[i][j]</em>;</p></li><li><p>根据木桶原理，接到的雨水的高度由这个容器周围最短的木板来确定的,</p><p>因此容器内水的高度取决于最外层高度最低的方块；</p></li><li><p>确定最小高度方块的相邻方块的接水高度，我们同时更新最外层的方块标记，</p><p>在新的最外层的方块再次找到接水后的高度的最小值，同时确定与其相邻的方块的接水高度；</p></li><li><p>依次迭代求出所有方块的接水，即可得解。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trapRainWater</span><span class="params">(<span class="keyword">int</span>[][] heightMap)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方块数小于4，无法接水</span></span><br><span class="line">        <span class="keyword">if</span> (heightMap.length &lt;= <span class="number">2</span> || heightMap[<span class="number">0</span>].length &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = heightMap.length;</span><br><span class="line">        <span class="keyword">int</span> n = heightMap[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 访问过的结点</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] visit = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o1[<span class="number">1</span>] - o2[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || i == m - <span class="number">1</span> || j == <span class="number">0</span> || j == n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// i * n + j代表第几个</span></span><br><span class="line">                    pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i * n + j, heightMap[i][j]&#125;);</span><br><span class="line">                    visit[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dirs = &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] curr = pq.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                <span class="comment">// 第几个取位置，/n是行数，%n是列数</span></span><br><span class="line">                <span class="keyword">int</span> nx = curr[<span class="number">0</span>] / n + dirs[k];</span><br><span class="line">                <span class="keyword">int</span> ny = curr[<span class="number">0</span>] % n + dirs[k + <span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 不越界并且没有被访问过</span></span><br><span class="line">                <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; n &amp;&amp; !visit[nx][ny]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (curr[<span class="number">1</span>] &gt; heightMap[nx][ny]) &#123;</span><br><span class="line">                        res += curr[<span class="number">1</span>] - heightMap[nx][ny];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 更新边界</span></span><br><span class="line">                    pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nx * n + ny, Math.max(heightMap[nx][ny], curr[<span class="number">1</span>])&#125;);</span><br><span class="line">                    <span class="comment">// 将访问过的位置设置为true</span></span><br><span class="line">                    visit[nx][ny] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(MNlog(M+N))\<br>&amp;空间复杂度:O(MN)<br>\end{align}<br>$$</p><hr><h3 id="解法三：广度优先搜索"><a href="#解法三：广度优先搜索" class="headerlink" title="解法三：广度优先搜索"></a>解法三：广度优先搜索</h3><p>思路:    让区域都接满水，因此此时每一块的高度都是 <code>maxHeight</code>，为区域中最高值，</p><p>​             然后让其顺着低处自然流出，因此需要广度优先搜索；</p><ol><li><p>假设初始时矩阵的每个格子都接满了水，且高度均为 <em>maxHeight</em>，区域中的最高值；</p></li><li><p>同解法二：<em>water[i][j] = max(heightMap[i][j], min(water[i−1][j], water[i+1][j], water[i][j−1], water[i][j+1]))</em>；</p></li><li><p>方块 <em>(i,j)</em> 实际接水的容量计算公式为 <em>water[i][j] − heightMap[i][j]</em>;</p></li><li><p>每次发现当前方块 <em>(i,j)</em> 的接水高度 <em>water[i][j]</em> 小于与它相邻的 4 个模块的接水高度时，</p><p>则我们将进行调整接水高度，将其相邻的四个方块的接水高度调整与 (<em>i</em>,<em>j</em>) 的高度保持一致；</p></li><li><p>不断重复的进行调整，直到所有的方块的接水高度不再有调整时即为满足要求。</p></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trapRainWater</span><span class="params">(<span class="keyword">int</span>[][] heightMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = heightMap.length;</span><br><span class="line">        <span class="keyword">int</span> n = heightMap[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] dirs = &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> maxHeight = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                maxHeight = Math.max(maxHeight, heightMap[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] water = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                water[i][j] = maxHeight;      </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; qu = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || i == m - <span class="number">1</span> || j == <span class="number">0</span> || j == n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (water[i][j] &gt; heightMap[i][j]) &#123;</span><br><span class="line">                        water[i][j] = heightMap[i][j];</span><br><span class="line">                        qu.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">while</span> (!qu.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] curr = qu.poll();</span><br><span class="line">            <span class="keyword">int</span> x = curr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = curr[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = x + dirs[i], ny = y + dirs[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= m || ny &lt; <span class="number">0</span> || ny &gt;= n) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (water[x][y] &lt; water[nx][ny] &amp;&amp; water[nx][ny] &gt; heightMap[nx][ny]) &#123;</span><br><span class="line">                    water[nx][ny] = Math.max(water[x][y], heightMap[nx][ny]);</span><br><span class="line">                    qu.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nx, ny&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                res += water[i][j] - heightMap[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(M^2N^2)\<br>&amp;空间复杂度:O(MN)<br>\end{align}<br>$$</p><hr><h3 id="广度优先搜索模板"><a href="#广度优先搜索模板" class="headerlink" title="广度优先搜索模板"></a>广度优先搜索模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 搜索过程中的累计最大值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 搜索过程中的标记值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果满足 则入队 同时改值</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == value) &#123;</span><br><span class="line">                matrix[i][j] = -<span class="number">1</span>;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">                bfs(queue, matrix);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.maxValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Queue&lt;<span class="keyword">int</span>[]&gt; queue, <span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 方向数组</span></span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] index = queue.poll();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = index[<span class="number">0</span>] + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = index[<span class="number">1</span>] + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 不超出边界</span></span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; matrix.length &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; matrix[<span class="number">0</span>].length) &#123;</span><br><span class="line">                <span class="comment">// 如果符合要求</span></span><br><span class="line">                <span class="keyword">if</span> (matrix[x][y] == value) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    matrix[x][y] = -<span class="number">1</span>;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x, y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.maxValue = Math.max(count, <span class="keyword">this</span>.maxValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 优先队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一维 接雨水</title>
      <link href="/2021/11/24/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E2%85%A0/"/>
      <url>/2021/11/24/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E2%85%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="一维-接雨水（-模拟-动态规划-双指针-单调栈-）"><a href="#一维-接雨水（-模拟-动态规划-双指针-单调栈-）" class="headerlink" title="一维 接雨水（ 模拟 | 动态规划 | 双指针 | 单调栈 ）"></a>一维 接雨水（ 模拟 | 动态规划 | 双指针 | 单调栈 ）</h3><span id="more"></span><blockquote><blockquote><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p>示例：输入 <code>height = [0,1,0,2,1,0,1,3,2,1,2,1]</code> ，输出 <code>6</code></p><p>题目详情参见 <a><a href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水 - 力扣（LeetCode） (leetcode-cn.com)</a></a></p></blockquote></blockquote><h3 id="解法一：模拟遍历"><a href="#解法一：模拟遍历" class="headerlink" title="解法一：模拟遍历"></a>解法一：模拟遍历</h3><p>思路：</p><ol><li>不妨设数组的长度为 <code>n</code> ，那么从下标 <code>1</code> 到 <code>n - 1</code> 进行遍历；</li><li>对于每个下标 <code>i</code> ，分别向左向右搜索最大值，然后取二者的最小值；</li><li>将此最小值减去 <code>height[i]</code>，即为此下标所能接的雨水数；</li><li>遍历求和，即可得到正确的解答。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> size = height.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> max_left = <span class="number">0</span>, max_right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123; <span class="comment">// 寻找左部最大值</span></span><br><span class="line">            max_left = Math.max(max_left, height[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; size; j++) &#123; <span class="comment">// 寻找右部最大值</span></span><br><span class="line">            max_right = Math.max(max_right, height[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans += Math.min(max_left, max_right) - height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度: O(n^2)\<br>&amp;空间复杂度: O(1)<br>\end{align}<br>$$</p><hr><h3 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h3><p>思路：在解法一（模拟遍历）的时候，每次都需要向左向右进行搜寻，不妨简化这个搜寻过程，从而降低时间复杂度。</p><ol><li>开辟两个数组 <em>leftMax、rightMax</em>，分别记录左边的最大值和右边的最大值；</li><li>因为两个数组记录的值意义不同，所以进行不同的遍历，得到两个数组的值；</li><li><strong>正向遍历得到 <em>leftMax</em>, 反向遍历得到 <em>rightMax</em> ;</strong></li><li>然后从下标 <code>1</code> 到 <code>n - 1</code> 进行遍历求解。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = height.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正向遍历得到左边最大值</span></span><br><span class="line">        <span class="keyword">int</span>[] leftMax = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        leftMax[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            leftMax[i] = Math.max(leftMax[i - <span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反向遍历得到右边最大值</span></span><br><span class="line">        <span class="keyword">int</span>[] rightMax = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        rightMax[n - <span class="number">1</span>] = height[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            rightMax[i] = Math.max(rightMax[i + <span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求和得解</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans += Math.min(leftMax[i], rightMax[i]) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度: O(n)\<br>&amp;空间复杂度: O(n)<br>\end{align}<br>$$</p><hr><h3 id="解法三：双指针"><a href="#解法三：双指针" class="headerlink" title="解法三：双指针"></a>解法三：双指针</h3><p>思路：解法二（动态规划）优化了模拟遍历，但是额外了开辟了空间，那么如何减少空间开辟？</p><ol><li><p><strong>使用双指针和两个变量代替正反遍历得到的两个数组；</strong></p></li><li><p>双指针 <em>left、right</em>, 两个变量 <em>leftMax，rightMax</em>;</p></li><li><p>当两个指针在移动的过程中，进行以下操作：</p><ol><li><p>使用 <em>height[left]，height[right]</em> 更新 <em>leftMax，rightMax</em> 的值；</p></li><li><p>如果 <em>height[left] &lt; height[right]</em>, 那么一定有 <em>leftMax &lt; rightMax</em>，</p><p>下标 <em>left</em> 处的接水量就等于 <em>leftMax - height[left]</em>，然后 <em>left</em> 右移一位；</p><p><a href="#1">（原因解释）</a></p></li><li><p>如果 <em>height[left] ≥ height[right]</em>, 那么一定有 <em>leftMax ≥ rightMax</em>，</p><p>下标 <em>right</em> 处的接水量就等于 <em>rightMax - height[right]</em>，然后 <em>right</em> 左移一位；</p></li></ol></li><li><p>当两个指针相遇时，即可得到接雨水的总量。</p></li></ol><p><strong><a id="1">为什么”一定有”的解释说明：</a></strong></p><blockquote><p>左指针右移的终止条件是找到比 <em>rightMax</em> 大的 <em>leftMax</em>，</p><p>也就是说一旦左指针终止左移，此时的<em>height[left]</em> 一定是 <em>leftMax</em>，且大于 <em>rightMax</em>。</p><p>同理，右指针左移的终止条件是找到比 <em>leftMax</em> 大的 <em>rightMax</em>，</p><p>而此时的 <em>height[right]</em> 就是 <em>rightMax</em>。</p><p>所以这里 <em>height[left] &lt; height[right]</em> 中的 <em>height[right]</em> 就是当前的 <em>rightMax</em>，</p><p>而 <em>height[left] &lt; height[right]</em> 意味着还没找到大于 <em>rightMax 的 leftMax</em>，</p><p>所以 <em>leftMax &lt; rightMax</em></p></blockquote><p>如果 <em>height[left] < height[right]</em>, 那么一定有 <em>leftMax < rightMax</em>，是一个充要条件,</p><p><strong>因此将此判断条件改为：如果 <em>leftMax &lt; rightMax</em>, 依然正确，</strong>可看代码部分注释。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> leftMax = <span class="number">0</span>, rightMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            leftMax = Math.max(leftMax, height[left]);</span><br><span class="line">            rightMax = Math.max(rightMax, height[right]);</span><br><span class="line">            <span class="comment">// if(leftMax &lt; rightMax) 依然正确</span></span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">                ans += leftMax - height[left];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += rightMax - height[right];</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度: O(n)\<br>&amp;空间复杂度: O(1)<br>\end{align}<br>$$</p><hr><h3 id="解法四：单调栈"><a href="#解法四：单调栈" class="headerlink" title="解法四：单调栈"></a>解法四：单调栈</h3><p>思路：上面几种做法都可以理解成<strong>垂直处理</strong>，单调栈的方式为<strong>水平处理</strong>。</p><ol><li>维护一个单调栈存储数组下标，满足从栈底到栈顶的下标对应的数组 <em>height</em> 中的元素<strong>非严格递减</strong>；</li><li>从左到右遍历数组，遍历到下标 <em>i</em> 时，如果栈内至少有两个元素，记栈顶元素为 <em>top</em>，<em>top</em> 的下面一个元素是 <em>left</em>；</li><li>则一定有 <em>height[left] ≥ height[top]</em>，如果 <em>height[i] &gt; height[top]</em>，则得到一个接雨水的区域；</li><li>该区域的宽度是 <em>i−left−1</em>，高度是 <em>min( height[left] , height[i] ) − height[top]</em>，根据宽度和高度即可计算得到该区域能接的雨水量；</li><li>为了得到  <em>left</em>，需要将 <em>top</em> 出栈。在对 <em>top</em> 计算能接的雨水量之后，<em>left</em> 变成新的 <em>top</em>；</li><li>重复上述操作，直到栈变为空，或者栈顶下标对应的 <em>height</em> 中的元素大于或等于 <em>height[i]</em>；</li><li>遍历结束之后即可得到能接的雨水总量。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = height.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> top = stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> left = stack.peek();</span><br><span class="line">                <span class="keyword">int</span> currWidth = i - left - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> currHeight = Math.min(height[left], height[i]) - height[top];</span><br><span class="line">                ans += currWidth * currHeight;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度: O(n)\<br>&amp;空间复杂度: O(n)<br>\end{align}<br>$$</p><hr><h3 id="补充说明：为什么使用-Deque-而不是-Stack-？"><a href="#补充说明：为什么使用-Deque-而不是-Stack-？" class="headerlink" title="补充说明：为什么使用 Deque 而不是 Stack ？"></a><strong>补充说明：为什么使用 Deque 而不是 Stack ？</strong></h3><ol><li><p><code>Deque</code> 是 <code>double ended queue</code> 的简称，习惯上称之为<strong>双端队列</strong></p></li><li><p>由于<code>Vector</code>因效率问题已经被弃用，因此继承<code>Vector</code>的<code>Stack</code>也存在效率问题，故不推荐。</p></li></ol><p>详情可参考文章：</p><p><a>深入理解Java集合之—Deque - 简书 (jianshu.com)](<a href="https://www.jianshu.com/p/d78a7c982edb">https://www.jianshu.com/p/d78a7c982edb</a>)</a></p><p><a><a href="https://www.cnblogs.com/code-duck/p/13569388.html">为什么使用Deque而不使用Stack构造栈 - codeduck - 博客园 (cnblogs.com)</a></a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洗牌算法</title>
      <link href="/2021/11/23/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"/>
      <url>/2021/11/23/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="洗牌算法-模拟洗牌-Fisher-Yates算法"><a href="#洗牌算法-模拟洗牌-Fisher-Yates算法" class="headerlink" title="洗牌算法( 模拟洗牌 | Fisher-Yates算法 )"></a>洗牌算法( 模拟洗牌 | Fisher-Yates算法 )</h3><span id="more"></span><blockquote><blockquote><p>设计算法打乱一个没有重复元素的给定整数数组 nums</p></blockquote></blockquote><h3 id="解法一：模拟洗牌"><a href="#解法一：模拟洗牌" class="headerlink" title="解法一：模拟洗牌"></a>解法一：模拟洗牌</h3><p>思路：首先不妨设数组 <em>nums</em> 的长度为 <em>n</em>，</p><ol><li>不妨用数据结构 <em>waiting</em> 来存放 <em>nums</em> 中的所有元素，并初始化打乱后的数组 <em>shuffled</em></li><li>从数组 <em>shuttle</em> 的 <em>0</em> 下标开始，每次从 <em>waiting</em> 中随机选取一个数据放置到 <em>shuffled</em>，并且从 <em>waiting</em> 中移除该数据</li></ol><p><em>（整体来说：模拟洗牌，每次的选择概率均相等，可以理解成抽签模拟）</em></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] shuffle() &#123;</span><br><span class="line"><span class="keyword">int</span>[] shuffled = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        list.add(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = random.nextInt(list.size());</span><br><span class="line">        shuffled[i] = list.remove(j);</span><br><span class="line">    &#125;</span><br><span class="line">    System.arraycopy(shuffled, <span class="number">0</span>, nums, <span class="number">0</span>, nums.length);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度：O(n^2)<br>&amp;空间复杂度：O(n)<br>\end{align}<br>$$</p><hr><h3 id="解法二：Fisher-Yates洗牌算法"><a href="#解法二：Fisher-Yates洗牌算法" class="headerlink" title="解法二：Fisher-Yates洗牌算法"></a>解法二：Fisher-Yates洗牌算法</h3><p>首先需要理解为什么上面介绍的模拟洗牌算法的时间复杂度为 O(n<sup>2</sup>)，</p><p><code>list.remove(int index)的时间复杂度是O(n - index)</code>, 因此改进算法：</p><ol><li>如果每次的 <em>index</em> 是最后一位，那么时间复杂度就降为 O(1)；</li><li>那么在放入 <em>shuffled</em> 之前, 先将 当前的 index 和 最后一位进行交换；</li><li>将最后一位移除的同时放入 <em>shuffled</em> 的指定位置即可。</li></ol><p>那么在此基础上，我们可以再进行改进，实现<strong>数组的原地乱序</strong></p><ol><li>不再使用数据结构 <em>waiting</em>，仅在原数组上操作；</li><li><strong>不再从数组中移除元素，每次将第 <em>k</em> 个元素与第 <em>1</em> 个元素交换</strong> </li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] shuffle() &#123;</span><br><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i + random.nextInt(nums.length - i);</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度：O(n)<br>&amp;空间复杂度：O(n)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>范围内查询质数</title>
      <link href="/2021/11/23/%E8%8C%83%E5%9B%B4%E5%86%85%E6%9F%A5%E8%AF%A2%E8%B4%A8%E6%95%B0/"/>
      <url>/2021/11/23/%E8%8C%83%E5%9B%B4%E5%86%85%E6%9F%A5%E8%AF%A2%E8%B4%A8%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="查询质数-枚举-埃氏筛-线性筛"><a href="#查询质数-枚举-埃氏筛-线性筛" class="headerlink" title="查询质数( 枚举 | 埃氏筛 | 线性筛 )"></a>查询质数( 枚举 | 埃氏筛 | 线性筛 )</h3><span id="more"></span><blockquote><blockquote><p>统计所有小于非负整数 <em><code>n</code></em> 的质数的数量。</p></blockquote></blockquote><h4 id="解法一：枚举求解"><a href="#解法一：枚举求解" class="headerlink" title="解法一：枚举求解"></a><strong>解法一：枚举求解</strong></h4><p>思路：从 1 ~ n 遍历，统计其中为质数的个数即可。</p><p><em><strong>一些常用的技巧：</strong></em></p><ol><li>在判断循环终止条件时，采用 <code>i * i &lt;= n</code>而不要采用 <code>i &lt;= Math.sqrt(n)</code>,可以降低程序运行时间；</li><li>在循环进行时，循环的变化条件增值，可以改成 <code>i = i + 2</code>而不是 <code>i = i + 1</code>，可以降低程序运行时间；</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans += isPrime(i) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i * i &lt;= x; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度：O(n\sqrt(n))\<br>&amp;空间复杂度：O(1)<br>\end{align}<br>$$</p><hr><h4 id="解法二：厄拉多塞筛法（埃氏筛）"><a href="#解法二：厄拉多塞筛法（埃氏筛）" class="headerlink" title="解法二：厄拉多塞筛法（埃氏筛）"></a><strong>解法二：厄拉多塞筛法（埃氏筛）</strong></h4><blockquote><blockquote><p>枚举没有考虑到数与数的关联性，因此难以再继续优化时间复杂度。</p><p>介绍一个常见的算法，该算法由希腊数学家厄拉多塞（Eratosthenes）提出，称为厄拉多塞筛法，简称埃氏筛。</p></blockquote></blockquote><p><strong>首先确定一个基准：如果 x 是一个质数，那么 2x、3x , ... 一定不是质数。</strong></p><p>那么依然从 2 开始遍历，如果 <code>x</code>是质数，那么标记它的整数倍为合数，最后统计多少质数即可：</p><ol><li>如果<code>x</code>是合数：说明必定存在一个小于<code>x</code>的<code>y</code>，使得其为合数，推断正确；</li><li>如果<code>x</code>是质数：说明不存在比<code>x</code>小的数，是其因子，推断正确。</li></ol><p><em><strong>对于基准的优化：不必从<code>2x</code>、<code>3x</code>这样开始标记，直接从<code>x * x</code>开始标记即可。</strong></em></p><p>不妨声明数组 <code>isPrime[]</code>来记录上述过程，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] isPrime = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(isPrime, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                ans += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">long</span>) i * i &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; n; j += i) &#123;</span><br><span class="line">                        isPrime[j] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度：O(nloglogn)\<br>&amp;空间复杂度：O(n)<br>\end{align}<br>$$</p><hr><h4 id="解法三：线性筛"><a href="#解法三：线性筛" class="headerlink" title="解法三：线性筛"></a>解法三：线性筛</h4><blockquote><blockquote><p>埃氏筛其实存在冗余的标记操作，比如对于<code>45</code>这个数，它会同时被 <code>3</code>,<code>5</code>两个数标记为合数，</p><p>因此我们优化的目标是让每个合数只被标记一次，这样时间复杂度即能保证为 O(n)</p></blockquote></blockquote><p><strong>优化方法：</strong></p><ol><li><p>额外维护一个 primes 数组表示当前得到的质数集合；</p></li><li><p>从小到大遍历，如果当前的数 x 是质数，就将其加入 primes 数组；</p></li><li><p>「标记过程」不再仅当 x 为质数时才进行，而是对每个整数 x 都进行,</p><p>​    对于整数 x，我们不再标记其所有的倍数 <code>x·x</code>,<code>x·(x+1)</code>, … ,</p><p>​    而是只标记质数集合中的数与 x 相乘的数，即 x · primes<sub>0</sub> , x · primes<sub>1</sub> , x⋅primes <sub>2</sub> , … ，</p><p>​    且在发现 x mod primes<sub>i</sub> = 0 时结束当前标记过程 (<strong>这一步确保了不会重复标记</strong>)。</p></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; primes = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] isPrime = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(isPrime, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                primes.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; primes.size() &amp;&amp; i * primes.get(j) &lt; n; ++j) &#123;</span><br><span class="line">                isPrime[i * primes.get(j)] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i % primes.get(j) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> primes.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度：O(n)\<br>&amp;空间复杂度：O(n)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java课设总结</title>
      <link href="/2021/11/18/JavaFX/"/>
      <url>/2021/11/18/JavaFX/</url>
      
        <content type="html"><![CDATA[<h3 id="简易PPT实现"><a href="#简易PPT实现" class="headerlink" title="简易PPT实现"></a>简易PPT实现</h3><span id="more"></span><h3 id="内容要求"><a href="#内容要求" class="headerlink" title="内容要求"></a>内容要求</h3><ol><li><strong>内容：开发一个简易的幻灯片制作与播放软件</strong></li><li><strong>基本功能：</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">新建幻灯片，幻灯片由不少于一个页面组成</span><br><span class="line">新建一个空白的幻灯片页面</span><br><span class="line">打开或保存整个幻灯片</span><br><span class="line">在幻灯片页面上绘制基本图形</span><br><span class="line">在幻灯片页面上绘制任意直线</span><br><span class="line">添加文字</span><br><span class="line">设定颜色与文字风格</span><br><span class="line">对幻灯片页面上已有的基本图形、线形、文字进行选取和移动</span><br><span class="line">通过鼠标拖动完成上述绘制和添加文字等操作</span><br></pre></td></tr></table></figure><ol><li><strong>选作功能：</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">幻灯片的全屏播放、翻页</span><br><span class="line">设定画笔、插入图像、修改图像（使用橡皮擦）</span><br><span class="line">图形填充、线型设置</span><br><span class="line">对幻灯片页面上已有的基本图形、线性、文字进行修改</span><br><span class="line">操作的撤销与重组</span><br><span class="line">菜单</span><br><span class="line">简易的JDBC连接MySQL数据库实现用户登录</span><br></pre></td></tr></table></figure><hr><h3 id="帮助文档"><a href="#帮助文档" class="headerlink" title="帮助文档"></a>帮助文档</h3><ol><li><p><strong>开发环境和插件选择</strong>：</p><p><code>Gradle + JavaFx + JPoneiX + JDK 1.8 + Spire.Presentation + IDEA </code></p><p>说明：</p><ol><li>按照 <code>non-modular + idea</code> 使用 JavaFx，会带来配置修改问题</li><li>使用 <code>JPoneiX</code> 开源项目优化 UI 界面，更加美观和方便</li><li>使用<code>Gradle</code>管理项目更加方便，兼容性更好</li></ol></li><li><p><strong>本人项目地址：</strong></p><p>GitHub：<a><a href="https://github.com/Eminem-x/JFoenix">https://github.com/Eminem-x/JFoenix</a></a></p></li></ol><ol start="2"><li><p><strong>JavaFX的基本操作指南：</strong></p><ol><li>官方文档: <a><a href="https://openjfx.io/">https://openjfx.io/</a></a><ul><li>基本内容以及示例说明</li><li>JavaFX的doc文档说明 </li></ul></li><li>WiKi教程: <a><a href="https://iowiki.com/javafx/javafx_images.html">https://iowiki.com/javafx/javafx_images.html</a></a></li><li>JavaFX和FXML的关系阐述： <a><a href="https://blog.csdn.net/theonegis/article/details/50181339">https://blog.csdn.net/theonegis/article/details/50181339</a></a></li></ol></li><li><p><strong>Java操作PPT的免费非开源组件:</strong></p><ol><li><p>官方网址：<a>冰蓝科技 PowerPoint 组件<a href="https://www.e-iceblue.cn/">https://www.e-iceblue.cn/</a></a></p></li><li><p>说明：</p><ol><li><p>此组件目前没有免费开源，会带有水印，不过不影响整体的实现，</p><p>可以通过适当操作，去掉水印的显示；</p></li><li><p>另外官方没有Gradle方式添加到工程，附上Gradle如何添加本地外包的方法：<br> <a href="https://blog.csdn.net/m1213642578/article/details/52763130?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link">Gradle添加本地外包</a></p></li></ol></li></ol></li><li><p><strong>JavaFX实现绘图功能的项目：</strong></p><ol><li>GitHub链接：<a><a href="https://github.com/FlyuZ/FYDrawing-JAVAFX">https://github.com/FlyuZ/FYDrawing-JAVAFX</a></a></li><li>可以参考实现方法，按照需求更改</li></ol></li><li><p><strong>JPoneiX开源项目：</strong></p><ol><li>GitHub链接：<a href="https://github.com/sshahine/JFoenix">https://github.com/sshahine/JFoenix</a></li><li>官方doc文档：<a><a href="https://javadoc.io/doc/com.jfoenix/jfoenix/latest/overview-summary.html">https://javadoc.io/doc/com.jfoenix/jfoenix/latest/overview-summary.html</a></a></li><li>此开源项目美化了JavaFx的组件UI，并且提供了许多便于使用和操作的组件</li></ol></li><li><p><strong>可用 Icon 的选取：</strong></p><ol><li>样式链接：<a><a href="https://fontawesome.com/v5.15/icons?d=gallery&amp;p=4&amp;s=solid&amp;m=free">https://fontawesome.com/v5.15/icons?d=gallery&amp;p=4&amp;s=solid&amp;m=free</a></a></li><li>使用时在 <code>Extern Libraries</code>下寻找此插件的 <code>solid</code>样式，然后相应位置替换即可</li><li>其他图片可能会失效，尝试即可，推荐使用 <code>solid</code></li></ol></li></ol><hr><h3 id="项目演示"><a href="#项目演示" class="headerlink" title="项目演示"></a>项目演示</h3><ol><li><p>文件结构：</p><p><img src="/2021/11/18/JavaFX/java%E8%AF%BE%E8%AE%BE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="文件结构"></p></li><li><p>项目运行效果：</p><p><img src="/2021/11/18/JavaFX/java%E8%AF%BE%E8%AE%BE%E6%95%88%E6%9E%9C%E5%9B%BE1.png" alt="主界面"></p><p><img src="/2021/11/18/JavaFX/java%E8%AF%BE%E8%AE%BE%E6%95%88%E6%9E%9C%E5%9B%BE2.png" alt="画图"></p><p><img src="/2021/11/18/JavaFX/java%E8%AF%BE%E8%AE%BE%E6%95%88%E6%9E%9C%E5%9B%BE3.png" alt="放映"></p></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 课程设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
