<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>祖玛游戏</title>
      <link href="/2021/11/25/%E7%A5%96%E7%8E%9B%E6%B8%B8%E6%88%8F/"/>
      <url>/2021/11/25/%E7%A5%96%E7%8E%9B%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="祖玛游戏（-搜索剪枝-记忆化搜索）"><a href="#祖玛游戏（-搜索剪枝-记忆化搜索）" class="headerlink" title="祖玛游戏（ 搜索剪枝 | 记忆化搜索）"></a>祖玛游戏（ 搜索剪枝 | 记忆化搜索）</h3><span id="more"></span><blockquote><blockquote><p>祖玛游戏的最小步数求解</p><p>题目详情参见：<a><a href="https://leetcode-cn.com/problems/zuma-game/">488. 祖玛游戏 - 力扣（LeetCode） (leetcode-cn.com)</a></a></p></blockquote></blockquote><h3 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h3><ol><li><p>因为插入球的选择和颜色情况太多，并且所带来的影响可能是在多次操作后才能体现出来，</p><p>因此倘若使用贪心算法，很难建立起全局最优的决策，故而不采用贪心；</p></li><li><p>因此需要对状态空间进行枚举，通过穷尽所有的可能来找到最优解，</p><p>并使用剪枝的方法来优化搜索过程；</p></li><li><p>如果使用深度优先搜索，则需要使用记忆化搜索，以避免重复计算相同的状态；</p></li><li><p>该题目只需要得到回合数最少的方案，因此广度优先搜索即可;</p></li><li><p>设当前桌面上有 n 个球，手中持有 m 个球，<br>  $$<br>  则此时一共有C^m_{m+n} * m! = A^m_{m+n}种插入方法<br>  $$</p></li></ol><h3 id="解法一：BFS-剪枝"><a href="#解法一：BFS-剪枝" class="headerlink" title="解法一：BFS + 剪枝"></a>解法一：BFS + 剪枝</h3><p>思路：不妨规定，每一种不同的桌面上球的情况和手中球的情况的组合都是一种不同的状态，</p><p>​            然后对状态空间进行枚举，即可得解答；</p><p><strong>在搜索过程中，需要剪枝来简化算法的复杂性:</strong></p><ul><li>手中颜色相同的球每次选择时只需要考虑其中一个即可；</li><li>只在连续相同颜色的球的开头位置或者结尾位置插入新的颜色相同的球；</li><li>只考虑放置新球后有可能得到更优解的位置，以下三种情况：<ol><li>插入新球与插入位置右侧的球颜色相同</li><li>插入新球与插入位置两侧的球颜色均不相同，且插入位置两侧的球的颜色不同</li><li>插入新球与插入位置两侧的球颜色均不相同，且插入位置两侧的球的颜色相同</li><li>对于如果手中的球全部插入也无法满足新的消除，则直接进行中止</li></ol></li></ul><p><strong>当然还可以有更多的剪枝技巧。</strong></p><p>具体实现的细节处理：</p><ol><li><p>消除操作后，如果导致出现了新的连续三个以上颜色相同的球，</p><p>则继续消除这些球，直到不再满足消除条件；</p></li><li><p>消除时利用栈的特性，每次遇到连续可以消除的球时，将其从栈中弹出；</p></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinStep</span><span class="params">(String board, String hand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] arr = hand.toCharArray();</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        hand = <span class="keyword">new</span> String(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化用队列维护的状态队列：其中的三个元素分别为桌面球状态、手中球状态和回合数</span></span><br><span class="line">        Queue&lt;State&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;State&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> State(board, hand, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化用哈希集合维护的已访问过的状态</span></span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        visited.add(board + <span class="string">&quot; &quot;</span> + hand);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            State state = queue.poll();</span><br><span class="line">            String curBoard = state.board;</span><br><span class="line">            String curHand = state.hand;</span><br><span class="line">            <span class="keyword">int</span> step = state.step;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= curBoard.length(); ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; curHand.length(); ++j) &#123;</span><br><span class="line">                    <span class="comment">// 第 1 个剪枝条件: 当前球的颜色和上一个球的颜色相同</span></span><br><span class="line">                    <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; curHand.charAt(j) == curHand.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 第 2 个剪枝条件: 只在连续相同颜色的球的开头位置插入新球</span></span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; curBoard.charAt(i - <span class="number">1</span>) == curHand.charAt(j)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 第 3 个剪枝条件: 只在以下两种情况放置新球</span></span><br><span class="line">                    <span class="keyword">boolean</span> choose = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">//  - 第 1 种情况 : 当前球颜色与后面的球的颜色相同</span></span><br><span class="line">                    <span class="keyword">if</span> (i &lt; curBoard.length() &amp;&amp; curBoard.charAt(i) == curHand.charAt(j)) &#123;</span><br><span class="line">                        choose = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//  - 第 2 种情况 : 当前后颜色相同且与当前颜色不同时候放置球</span></span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; i &lt; curBoard.length() &amp;&amp; </span><br><span class="line">                        curBoard.charAt(i - <span class="number">1</span>) == curBoard.charAt(i) &amp;&amp; </span><br><span class="line">                        curBoard.charAt(i - <span class="number">1</span>) != curHand.charAt(j)) &#123;</span><br><span class="line">                        choose = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (choose) &#123;</span><br><span class="line">                        String newBoard = clean(curBoard.substring(<span class="number">0</span>, i) + </span><br><span class="line">                                                curHand.charAt(j) + curBoard.substring(i));</span><br><span class="line">                        String newHand = curHand.substring(<span class="number">0</span>, j) + curHand.substring(j + <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">if</span> (newBoard.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        String str = newBoard + <span class="string">&quot; &quot;</span> + newHand;</span><br><span class="line">                        <span class="keyword">if</span> (visited.add(str)) &#123;</span><br><span class="line">                            queue.offer(<span class="keyword">new</span> State(newBoard, newHand, step + <span class="number">1</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">clean</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        Deque&lt;Character&gt; letterStack = <span class="keyword">new</span> ArrayDeque&lt;Character&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; countStack = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">while</span> (!letterStack.isEmpty() &amp;&amp; c != letterStack.peek() &amp;&amp; countStack.peek() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                letterStack.pop();</span><br><span class="line">                countStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (letterStack.isEmpty() || c != letterStack.peek()) &#123;</span><br><span class="line">                letterStack.push(c);</span><br><span class="line">                countStack.push(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                countStack.push(countStack.pop() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!countStack.isEmpty() &amp;&amp; countStack.peek() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">            letterStack.pop();</span><br><span class="line">            countStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!letterStack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">char</span> letter = letterStack.pop();</span><br><span class="line">            <span class="keyword">int</span> count = countStack.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">                sb.append(letter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.reverse();</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    String board;</span><br><span class="line">    String hand;</span><br><span class="line">    <span class="keyword">int</span> step;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">State</span><span class="params">(String board, String hand, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.board = board;</span><br><span class="line">        <span class="keyword">this</span>.hand = hand;</span><br><span class="line">        <span class="keyword">this</span>.step = step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(m×n×A^n_{m+n})\<br>&amp;空间复杂度:O((m+n)×A^m_{m+n})<br>\end{align}<br>$$</p><hr><h3 id="解法二：记忆化搜索（AStar算法）"><a href="#解法二：记忆化搜索（AStar算法）" class="headerlink" title="解法二：记忆化搜索（AStar算法）"></a>解法二：记忆化搜索（AStar算法）</h3><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Integer&gt; dp = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinStep</span><span class="params">(String board, String hand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] arr = hand.toCharArray();</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        hand = <span class="keyword">new</span> String(arr);</span><br><span class="line">        <span class="keyword">int</span> ans = dfs(board, hand);</span><br><span class="line">        <span class="keyword">return</span> ans &lt;= <span class="number">5</span> ? ans : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(String board, String hand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String key = board + <span class="string">&quot; &quot;</span> + hand;</span><br><span class="line">        <span class="keyword">if</span> (!dp.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">6</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; hand.length(); ++j) &#123;</span><br><span class="line">                <span class="comment">// 第 1 个剪枝条件: 当前球的颜色和上一个球的颜色相同</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; hand.charAt(j) == hand.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= board.length(); ++i) &#123;</span><br><span class="line">                    <span class="comment">// 第 2 个剪枝条件: 只在连续相同颜色的球的开头位置插入新球</span></span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; board.charAt(i - <span class="number">1</span>) == hand.charAt(j)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 第 3 个剪枝条件: 只在以下两种情况放置新球</span></span><br><span class="line">                    <span class="keyword">boolean</span> choose = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">//  - 第 1 种情况 : 当前球颜色与后面的球的颜色相同</span></span><br><span class="line">                    <span class="keyword">if</span> (i &lt; board.length() &amp;&amp; board.charAt(i) == hand.charAt(j)) &#123;</span><br><span class="line">                        choose = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//  - 第 2 种情况 : 当前后颜色相同且与当前颜色不同时候放置球</span></span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; i &lt; board.length() &amp;&amp; </span><br><span class="line">                        board.charAt(i - <span class="number">1</span>) == board.charAt(i) &amp;&amp; </span><br><span class="line">                        board.charAt(i - <span class="number">1</span>) != hand.charAt(j)) &#123;</span><br><span class="line">                        choose = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (choose) &#123;</span><br><span class="line">                        String newBoard = clean(board.substring(<span class="number">0</span>, i) + </span><br><span class="line">                                                hand.charAt(j) + board.substring(i));</span><br><span class="line">                        String newHand = hand.substring(<span class="number">0</span>, j) + hand.substring(j + <span class="number">1</span>);</span><br><span class="line">                        res = Math.min(res, dfs(newBoard, newHand) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp.put(key, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">clean</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        Deque&lt;Character&gt; letterStack = <span class="keyword">new</span> ArrayDeque&lt;Character&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; countStack = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">while</span> (!letterStack.isEmpty() &amp;&amp; c != letterStack.peek() &amp;&amp; countStack.peek() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                letterStack.pop();</span><br><span class="line">                countStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (letterStack.isEmpty() || c != letterStack.peek()) &#123;</span><br><span class="line">                letterStack.push(c);</span><br><span class="line">                countStack.push(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                countStack.push(countStack.pop() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!countStack.isEmpty() &amp;&amp; countStack.peek() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">            letterStack.pop();</span><br><span class="line">            countStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!letterStack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">char</span> letter = letterStack.pop();</span><br><span class="line">            <span class="keyword">int</span> count = countStack.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">                sb.append(letter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.reverse();</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    String board;</span><br><span class="line">    String hand;</span><br><span class="line">    <span class="keyword">int</span> step;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">State</span><span class="params">(String board, String hand, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.board = board;</span><br><span class="line">        <span class="keyword">this</span>.hand = hand;</span><br><span class="line">        <span class="keyword">this</span>.step = step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(m×n×A^n_{m+n})\<br>&amp;空间复杂度:O((m+n)×A^m_{m+n})<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 广度优先搜索 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二维 接雨水</title>
      <link href="/2021/11/25/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E2%85%A1/"/>
      <url>/2021/11/25/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E2%85%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="二维-接雨水（-最小堆-广度优先搜索-）"><a href="#二维-接雨水（-最小堆-广度优先搜索-）" class="headerlink" title="二维 接雨水（ 最小堆 | 广度优先搜索 ）"></a>二维 接雨水（ 最小堆 | 广度优先搜索 ）</h3><span id="more"></span><blockquote><blockquote><p>给你一个 <code>m x n</code> 的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>题目详情参见: <a><a href="https://leetcode-cn.com/problems/trapping-rain-water-ii/">407. 接雨水 II - 力扣（LeetCode） (leetcode-cn.com)</a></a></p></blockquote></blockquote><h3 id="解法一：模拟遍历（参照接雨水Ⅰ）"><a href="#解法一：模拟遍历（参照接雨水Ⅰ）" class="headerlink" title="解法一：模拟遍历（参照接雨水Ⅰ）"></a>解法一：模拟遍历（参照接雨水Ⅰ）</h3><p>思路：一维转化为二维，那么是否可以同样的思路去解答？</p><ol><li>对于每个点，寻找所在行左右最大值的最小值，寻找所在列上下最大值的最小值；</li><li>然后取这两个值的最小值，减去当前位置的高度，即为此位置接雨水量。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trapRainWater</span><span class="params">(<span class="keyword">int</span>[][] heightMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = heightMap.length;</span><br><span class="line">        <span class="keyword">int</span> col = heightMap[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> curr = heightMap[i][j];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> minRow = getMinRow(heightMap,i,j,col);</span><br><span class="line">                <span class="keyword">int</span> minCol = getMinCol(heightMap,i,j,row);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果均大于当前位置，那么可以接雨水</span></span><br><span class="line">                <span class="keyword">if</span>(minCol &gt; curr &amp;&amp; minRow &gt; curr) &#123;</span><br><span class="line">                    ans += Math.min(minRow,minCol);</span><br><span class="line">                    ans -= heightMap[i][j];</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找所在行的左右最大值的最小值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMinRow</span><span class="params">(<span class="keyword">int</span>[][] heightMap,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftMax = heightMap[x][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> rightMax = heightMap[x][col - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; y; k++) &#123;</span><br><span class="line">            leftMax = Math.max(leftMax,heightMap[x][k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = y; k &lt; col; k++) &#123;</span><br><span class="line">            rightMax = Math.max(rightMax,heightMap[x][k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(leftMax,rightMax);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找所在列的上下最大值的最小值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMinCol</span><span class="params">(<span class="keyword">int</span>[][] heightMap,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> upMax = heightMap[<span class="number">0</span>][y];</span><br><span class="line">        <span class="keyword">int</span> downMax = heightMap[row - <span class="number">1</span>][y];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; x; k++) &#123;</span><br><span class="line">            upMax = Math.max(upMax,heightMap[k][y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = x; k &lt; row; k++) &#123;</span><br><span class="line">             downMax = Math.max(downMax,heightMap[k][y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(upMax,downMax);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个思路解答是错误的，因为当前位置可能会溢出流向其他区域！</p><p>比如：<code>[[12,13,1,12],[13,4,13,12],[13,8,10,12],[12,13,12,12],[13,13,13,13]]</code></p><p>按照上述做法的答案<code>15</code>，正确答案<code>14</code>。</p><p><strong>因此该方块自身的高度比其上下左右四个相邻的方块接水后的高度都要低。</strong></p><hr><h3 id="解法二：最小堆"><a href="#解法二：最小堆" class="headerlink" title="解法二：最小堆"></a>解法二：最小堆</h3><p>思路：反思解法一的过程，思考总结什么样的方块能接水?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 该方块不为最外层的方块；</span><br><span class="line">- 该方块自身的高度比其上下左右四个相邻的方块接水后的高度都要低；</span><br></pre></td></tr></table></figure><ol><li><p>假设方块的索引为 <em>(i,j)</em>，方块的高度为 <em>heightMap[i][j]</em>，方块接水后的高度为 <em>water[i][j]</em>；</p></li><li><p>并且 <em>water[i][j] = max(heightMap[i][j], min(water[i−1][j], water[i+1][j], water[i][j−1], water[i][j+1]))</em>；</p></li><li><p>因此方块 <em>(i,j)</em> 实际接水的容量计算公式为 <em>water[i][j] − heightMap[i][j]</em>;</p></li><li><p>因为最外层的方块无法接水，因此最外层的方块 <em>water[i][j] = heightMap[i][j]</em>;</p></li><li><p>根据木桶原理，接到的雨水的高度由这个容器周围最短的木板来确定的,</p><p>因此容器内水的高度取决于最外层高度最低的方块；</p></li><li><p>确定最小高度方块的相邻方块的接水高度，我们同时更新最外层的方块标记，</p><p>在新的最外层的方块再次找到接水后的高度的最小值，同时确定与其相邻的方块的接水高度；</p></li><li><p>依次迭代求出所有方块的接水，即可得解。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trapRainWater</span><span class="params">(<span class="keyword">int</span>[][] heightMap)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方块数小于4，无法接水</span></span><br><span class="line">        <span class="keyword">if</span> (heightMap.length &lt;= <span class="number">2</span> || heightMap[<span class="number">0</span>].length &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = heightMap.length;</span><br><span class="line">        <span class="keyword">int</span> n = heightMap[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 访问过的结点</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] visit = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o1[<span class="number">1</span>] - o2[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || i == m - <span class="number">1</span> || j == <span class="number">0</span> || j == n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// i * n + j代表第几个</span></span><br><span class="line">                    pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i * n + j, heightMap[i][j]&#125;);</span><br><span class="line">                    visit[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dirs = &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] curr = pq.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                <span class="comment">// 第几个取位置，/n是行数，%n是列数</span></span><br><span class="line">                <span class="keyword">int</span> nx = curr[<span class="number">0</span>] / n + dirs[k];</span><br><span class="line">                <span class="keyword">int</span> ny = curr[<span class="number">0</span>] % n + dirs[k + <span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 不越界并且没有被访问过</span></span><br><span class="line">                <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; n &amp;&amp; !visit[nx][ny]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (curr[<span class="number">1</span>] &gt; heightMap[nx][ny]) &#123;</span><br><span class="line">                        res += curr[<span class="number">1</span>] - heightMap[nx][ny];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 更新边界</span></span><br><span class="line">                    pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nx * n + ny, Math.max(heightMap[nx][ny], curr[<span class="number">1</span>])&#125;);</span><br><span class="line">                    <span class="comment">// 将访问过的位置设置为true</span></span><br><span class="line">                    visit[nx][ny] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(MNlog(M+N))\<br>&amp;空间复杂度:O(MN)<br>\end{align}<br>$$</p><hr><h3 id="解法三：广度优先搜索"><a href="#解法三：广度优先搜索" class="headerlink" title="解法三：广度优先搜索"></a>解法三：广度优先搜索</h3><p>思路:    让区域都接满水，因此此时每一块的高度都是 <code>maxHeight</code>，为区域中最高值，</p><p>​             然后让其顺着低处自然流出，因此需要广度优先搜索；</p><ol><li><p>假设初始时矩阵的每个格子都接满了水，且高度均为 <em>maxHeight</em>，区域中的最高值；</p></li><li><p>同解法二：<em>water[i][j] = max(heightMap[i][j], min(water[i−1][j], water[i+1][j], water[i][j−1], water[i][j+1]))</em>；</p></li><li><p>方块 <em>(i,j)</em> 实际接水的容量计算公式为 <em>water[i][j] − heightMap[i][j]</em>;</p></li><li><p>每次发现当前方块 <em>(i,j)</em> 的接水高度 <em>water[i][j]</em> 小于与它相邻的 4 个模块的接水高度时，</p><p>则我们将进行调整接水高度，将其相邻的四个方块的接水高度调整与 (<em>i</em>,<em>j</em>) 的高度保持一致；</p></li><li><p>不断重复的进行调整，直到所有的方块的接水高度不再有调整时即为满足要求。</p></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trapRainWater</span><span class="params">(<span class="keyword">int</span>[][] heightMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = heightMap.length;</span><br><span class="line">        <span class="keyword">int</span> n = heightMap[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] dirs = &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> maxHeight = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                maxHeight = Math.max(maxHeight, heightMap[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] water = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                water[i][j] = maxHeight;      </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; qu = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || i == m - <span class="number">1</span> || j == <span class="number">0</span> || j == n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (water[i][j] &gt; heightMap[i][j]) &#123;</span><br><span class="line">                        water[i][j] = heightMap[i][j];</span><br><span class="line">                        qu.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">while</span> (!qu.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] curr = qu.poll();</span><br><span class="line">            <span class="keyword">int</span> x = curr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = curr[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = x + dirs[i], ny = y + dirs[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= m || ny &lt; <span class="number">0</span> || ny &gt;= n) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (water[x][y] &lt; water[nx][ny] &amp;&amp; water[nx][ny] &gt; heightMap[nx][ny]) &#123;</span><br><span class="line">                    water[nx][ny] = Math.max(water[x][y], heightMap[nx][ny]);</span><br><span class="line">                    qu.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nx, ny&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                res += water[i][j] - heightMap[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(M^2N^2)\<br>&amp;空间复杂度:O(MN)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 优先队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一维 接雨水</title>
      <link href="/2021/11/24/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E2%85%A0/"/>
      <url>/2021/11/24/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E2%85%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="一维-接雨水（-模拟-动态规划-双指针-单调栈-）"><a href="#一维-接雨水（-模拟-动态规划-双指针-单调栈-）" class="headerlink" title="一维 接雨水（ 模拟 | 动态规划 | 双指针 | 单调栈 ）"></a>一维 接雨水（ 模拟 | 动态规划 | 双指针 | 单调栈 ）</h3><span id="more"></span><blockquote><blockquote><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p>示例：输入 <code>height = [0,1,0,2,1,0,1,3,2,1,2,1]</code> ，输出 <code>6</code></p><p>题目详情参见 <a><a href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水 - 力扣（LeetCode） (leetcode-cn.com)</a></a></p></blockquote></blockquote><h3 id="解法一：模拟遍历"><a href="#解法一：模拟遍历" class="headerlink" title="解法一：模拟遍历"></a>解法一：模拟遍历</h3><p>思路：</p><ol><li>不妨设数组的长度为 <code>n</code> ，那么从下标 <code>1</code> 到 <code>n - 1</code> 进行遍历；</li><li>对于每个下标 <code>i</code> ，分别向左向右搜索最大值，然后取二者的最小值；</li><li>将此最小值减去 <code>height[i]</code>，即为此下标所能接的雨水数；</li><li>遍历求和，即可得到正确的解答。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> size = height.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> max_left = <span class="number">0</span>, max_right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123; <span class="comment">// 寻找左部最大值</span></span><br><span class="line">            max_left = Math.max(max_left, height[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; size; j++) &#123; <span class="comment">// 寻找右部最大值</span></span><br><span class="line">            max_right = Math.max(max_right, height[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans += Math.min(max_left, max_right) - height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度: O(n^2)\<br>&amp;空间复杂度: O(1)<br>\end{align}<br>$$</p><hr><h3 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h3><p>思路：在解法一（模拟遍历）的时候，每次都需要向左向右进行搜寻，不妨简化这个搜寻过程，从而降低时间复杂度。</p><ol><li>开辟两个数组 <em>leftMax、rightMax</em>，分别记录左边的最大值和右边的最大值；</li><li>因为两个数组记录的值意义不同，所以进行不同的遍历，得到两个数组的值；</li><li><strong>正向遍历得到 <em>leftMax</em>, 反向遍历得到 <em>rightMax</em> ;</strong></li><li>然后从下标 <code>1</code> 到 <code>n - 1</code> 进行遍历求解。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = height.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正向遍历得到左边最大值</span></span><br><span class="line">        <span class="keyword">int</span>[] leftMax = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        leftMax[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            leftMax[i] = Math.max(leftMax[i - <span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反向遍历得到右边最大值</span></span><br><span class="line">        <span class="keyword">int</span>[] rightMax = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        rightMax[n - <span class="number">1</span>] = height[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            rightMax[i] = Math.max(rightMax[i + <span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求和得解</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans += Math.min(leftMax[i], rightMax[i]) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度: O(n)\<br>&amp;空间复杂度: O(n)<br>\end{align}<br>$$</p><hr><h3 id="解法三：双指针"><a href="#解法三：双指针" class="headerlink" title="解法三：双指针"></a>解法三：双指针</h3><p>思路：解法二（动态规划）优化了模拟遍历，但是额外了开辟了空间，那么如何减少空间开辟？</p><ol><li><p><strong>使用双指针和两个变量代替正反遍历得到的两个数组；</strong></p></li><li><p>双指针 <em>left、right</em>, 两个变量 <em>leftMax，rightMax</em>;</p></li><li><p>当两个指针在移动的过程中，进行以下操作：</p><ol><li><p>使用 <em>height[left]，height[right]</em> 更新 <em>leftMax，rightMax</em> 的值；</p></li><li><p>如果 <em>height[left] &lt; height[right]</em>, 那么一定有 <em>leftMax &lt; rightMax</em>，</p><p>下标 <em>left</em> 处的接水量就等于 <em>leftMax - height[left]</em>，然后 <em>left</em> 右移一位；</p><p><a href="#1">（原因解释）</a></p></li><li><p>如果 <em>height[left] ≥ height[right]</em>, 那么一定有 <em>leftMax ≥ rightMax</em>，</p><p>下标 <em>right</em> 处的接水量就等于 <em>rightMax - height[right]</em>，然后 <em>right</em> 左移一位；</p></li></ol></li><li><p>当两个指针相遇时，即可得到接雨水的总量。</p></li></ol><p><strong><a id="1">为什么”一定有”的解释说明：</a></strong></p><blockquote><p>左指针右移的终止条件是找到比 <em>rightMax</em> 大的 <em>leftMax</em>，</p><p>也就是说一旦左指针终止左移，此时的<em>height[left]</em> 一定是 <em>leftMax</em>，且大于 <em>rightMax</em>。</p><p>同理，右指针左移的终止条件是找到比 <em>leftMax</em> 大的 <em>rightMax</em>，</p><p>而此时的 <em>height[right]</em> 就是 <em>rightMax</em>。</p><p>所以这里 <em>height[left] &lt; height[right]</em> 中的 <em>height[right]</em> 就是当前的 <em>rightMax</em>，</p><p>而 <em>height[left] &lt; height[right]</em> 意味着还没找到大于 <em>rightMax 的 leftMax</em>，</p><p>所以 <em>leftMax &lt; rightMax</em></p></blockquote><p>如果 <em>height[left] < height[right]</em>, 那么一定有 <em>leftMax < rightMax</em>，是一个充要条件,</p><p><strong>因此将此判断条件改为：如果 <em>leftMax &lt; rightMax</em>, 依然正确，</strong>可看代码部分注释。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> leftMax = <span class="number">0</span>, rightMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            leftMax = Math.max(leftMax, height[left]);</span><br><span class="line">            rightMax = Math.max(rightMax, height[right]);</span><br><span class="line">            <span class="comment">// if(leftMax &lt; rightMax) 依然正确</span></span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">                ans += leftMax - height[left];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += rightMax - height[right];</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度: O(n)\<br>&amp;空间复杂度: O(1)<br>\end{align}<br>$$</p><hr><h3 id="解法四：单调栈"><a href="#解法四：单调栈" class="headerlink" title="解法四：单调栈"></a>解法四：单调栈</h3><p>思路：上面几种做法都可以理解成<strong>垂直处理</strong>，单调栈的方式为<strong>水平处理</strong>。</p><ol><li>维护一个单调栈存储数组下标，满足从栈底到栈顶的下标对应的数组 <em>height</em> 中的元素<strong>非严格递减</strong>；</li><li>从左到右遍历数组，遍历到下标 <em>i</em> 时，如果栈内至少有两个元素，记栈顶元素为 <em>top</em>，<em>top</em> 的下面一个元素是 <em>left</em>；</li><li>则一定有 <em>height[left] ≥ height[top]</em>，如果 <em>height[i] &gt; height[top]</em>，则得到一个接雨水的区域；</li><li>该区域的宽度是 <em>i−left−1</em>，高度是 <em>min( height[left] , height[i] ) − height[top]</em>，根据宽度和高度即可计算得到该区域能接的雨水量；</li><li>为了得到  <em>left</em>，需要将 <em>top</em> 出栈。在对 <em>top</em> 计算能接的雨水量之后，<em>left</em> 变成新的 <em>top</em>；</li><li>重复上述操作，直到栈变为空，或者栈顶下标对应的 <em>height</em> 中的元素大于或等于 <em>height[i]</em>；</li><li>遍历结束之后即可得到能接的雨水总量。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = height.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> top = stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> left = stack.peek();</span><br><span class="line">                <span class="keyword">int</span> currWidth = i - left - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> currHeight = Math.min(height[left], height[i]) - height[top];</span><br><span class="line">                ans += currWidth * currHeight;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度: O(n)\<br>&amp;空间复杂度: O(n)<br>\end{align}<br>$$</p><hr><h3 id="补充说明：为什么使用-Deque-而不是-Stack-？"><a href="#补充说明：为什么使用-Deque-而不是-Stack-？" class="headerlink" title="补充说明：为什么使用 Deque 而不是 Stack ？"></a><strong>补充说明：为什么使用 Deque 而不是 Stack ？</strong></h3><ol><li><p><code>Deque</code> 是 <code>double ended queue</code> 的简称，习惯上称之为<strong>双端队列</strong></p></li><li><p>由于<code>Vector</code>因效率问题已经被弃用，因此继承<code>Vector</code>的<code>Stack</code>也存在效率问题，故不推荐。</p></li></ol><p>详情可参考文章：</p><p><a>深入理解Java集合之—Deque - 简书 (jianshu.com)](<a href="https://www.jianshu.com/p/d78a7c982edb">https://www.jianshu.com/p/d78a7c982edb</a>)</a></p><p><a><a href="https://www.cnblogs.com/code-duck/p/13569388.html">为什么使用Deque而不使用Stack构造栈 - codeduck - 博客园 (cnblogs.com)</a></a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>洗牌算法</title>
      <link href="/2021/11/23/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"/>
      <url>/2021/11/23/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="洗牌算法-模拟洗牌-Fisher-Yates算法"><a href="#洗牌算法-模拟洗牌-Fisher-Yates算法" class="headerlink" title="洗牌算法( 模拟洗牌 | Fisher-Yates算法 )"></a>洗牌算法( 模拟洗牌 | Fisher-Yates算法 )</h3><span id="more"></span><blockquote><blockquote><p>设计算法打乱一个没有重复元素的给定整数数组 nums</p></blockquote></blockquote><h3 id="解法一：模拟洗牌"><a href="#解法一：模拟洗牌" class="headerlink" title="解法一：模拟洗牌"></a>解法一：模拟洗牌</h3><p>思路：首先不妨设数组 <em>nums</em> 的长度为 <em>n</em>，</p><ol><li>不妨用数据结构 <em>waiting</em> 来存放 <em>nums</em> 中的所有元素，并初始化打乱后的数组 <em>shuffled</em></li><li>从数组 <em>shuttle</em> 的 <em>0</em> 下标开始，每次从 <em>waiting</em> 中随机选取一个数据放置到 <em>shuffled</em>，并且从 <em>waiting</em> 中移除该数据</li></ol><p><em>（整体来说：模拟洗牌，每次的选择概率均相等，可以理解成抽签模拟）</em></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] shuffle() &#123;</span><br><span class="line"><span class="keyword">int</span>[] shuffled = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        list.add(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = random.nextInt(list.size());</span><br><span class="line">        shuffled[i] = list.remove(j);</span><br><span class="line">    &#125;</span><br><span class="line">    System.arraycopy(shuffled, <span class="number">0</span>, nums, <span class="number">0</span>, nums.length);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度：O(n^2)<br>&amp;空间复杂度：O(n)<br>\end{align}<br>$$</p><hr><h3 id="解法二：Fisher-Yates洗牌算法"><a href="#解法二：Fisher-Yates洗牌算法" class="headerlink" title="解法二：Fisher-Yates洗牌算法"></a>解法二：Fisher-Yates洗牌算法</h3><p>首先需要理解为什么上面介绍的模拟洗牌算法的时间复杂度为 O(n<sup>2</sup>)，</p><p><code>list.remove(int index)的时间复杂度是O(n - index)</code>, 因此改进算法：</p><ol><li>如果每次的 <em>index</em> 是最后一位，那么时间复杂度就降为 O(1)；</li><li>那么在放入 <em>shuffled</em> 之前, 先将 当前的 index 和 最后一位进行交换；</li><li>将最后一位移除的同时放入 <em>shuffled</em> 的指定位置即可。</li></ol><p>那么在此基础上，我们可以再进行改进，实现<strong>数组的原地乱序</strong></p><ol><li>不再使用数据结构 <em>waiting</em>，仅在原数组上操作；</li><li><strong>不再从数组中移除元素，每次将第 <em>k</em> 个元素与第 <em>1</em> 个元素交换</strong> </li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] shuffle() &#123;</span><br><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i + random.nextInt(nums.length - i);</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度：O(n)<br>&amp;空间复杂度：O(n)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>范围内查询质数</title>
      <link href="/2021/11/23/%E8%8C%83%E5%9B%B4%E5%86%85%E6%9F%A5%E8%AF%A2%E8%B4%A8%E6%95%B0/"/>
      <url>/2021/11/23/%E8%8C%83%E5%9B%B4%E5%86%85%E6%9F%A5%E8%AF%A2%E8%B4%A8%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="查询质数-枚举-埃氏筛-线性筛"><a href="#查询质数-枚举-埃氏筛-线性筛" class="headerlink" title="查询质数( 枚举 | 埃氏筛 | 线性筛 )"></a>查询质数( 枚举 | 埃氏筛 | 线性筛 )</h3><span id="more"></span><blockquote><blockquote><p>统计所有小于非负整数 <em><code>n</code></em> 的质数的数量。</p></blockquote></blockquote><h4 id="解法一：枚举求解"><a href="#解法一：枚举求解" class="headerlink" title="解法一：枚举求解"></a><strong>解法一：枚举求解</strong></h4><p>思路：从 1 ~ n 遍历，统计其中为质数的个数即可。</p><p><em><strong>一些常用的技巧：</strong></em></p><ol><li>在判断循环终止条件时，采用 <code>i * i &lt;= n</code>而不要采用 <code>i &lt;= Math.sqrt(n)</code>,可以降低程序运行时间；</li><li>在循环进行时，循环的变化条件增值，可以改成 <code>i = i + 2</code>而不是 <code>i = i + 1</code>，可以降低程序运行时间；</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans += isPrime(i) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i * i &lt;= x; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度：O(n\sqrt(n))\<br>&amp;空间复杂度：O(1)<br>\end{align}<br>$$</p><hr><h4 id="解法二：厄拉多塞筛法（埃氏筛）"><a href="#解法二：厄拉多塞筛法（埃氏筛）" class="headerlink" title="解法二：厄拉多塞筛法（埃氏筛）"></a><strong>解法二：厄拉多塞筛法（埃氏筛）</strong></h4><blockquote><blockquote><p>枚举没有考虑到数与数的关联性，因此难以再继续优化时间复杂度。</p><p>介绍一个常见的算法，该算法由希腊数学家厄拉多塞（Eratosthenes）提出，称为厄拉多塞筛法，简称埃氏筛。</p></blockquote></blockquote><p>首先确定一个基准：**如果 <code>x</code> 是一个质数，那么 <code>2x</code>、<code>3x</code>, … 一定不是质数。 **</p><p>那么依然从 2 开始遍历，如果 <code>x</code>是质数，那么标记它的整数倍为合数，最后统计多少质数即可：</p><ol><li>如果<code>x</code>是合数：说明必定存在一个小于<code>x</code>的<code>y</code>，使得其为合数，推断正确；</li><li>如果<code>x</code>是质数：说明不存在比<code>x</code>小的数，是其因子，推断正确。</li></ol><p><em><strong>对于基准的优化：不必从<code>2x</code>、<code>3x</code>这样开始标记，直接从<code>x * x</code>开始标记即可。</strong></em></p><p>不妨声明数组 <code>isPrime[]</code>来记录上述过程，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] isPrime = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(isPrime, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                ans += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">long</span>) i * i &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; n; j += i) &#123;</span><br><span class="line">                        isPrime[j] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度：O(nloglogn)\<br>&amp;空间复杂度：O(n)<br>\end{align}<br>$$</p><hr><h4 id="解法三：线性筛"><a href="#解法三：线性筛" class="headerlink" title="解法三：线性筛"></a>解法三：线性筛</h4><blockquote><blockquote><p>埃氏筛其实存在冗余的标记操作，比如对于<code>45</code>这个数，它会同时被 <code>3</code>,<code>5</code>两个数标记为合数，</p><p>因此我们优化的目标是让每个合数只被标记一次，这样时间复杂度即能保证为 O(n)</p></blockquote></blockquote><p><strong>优化方法：</strong></p><ol><li><p>额外维护一个 primes 数组表示当前得到的质数集合；</p></li><li><p>从小到大遍历，如果当前的数 x 是质数，就将其加入 primes 数组；</p></li><li><p>「标记过程」不再仅当 x 为质数时才进行，而是对每个整数 x 都进行,</p><p>​    对于整数 x，我们不再标记其所有的倍数 <code>x·x</code>,<code>x·(x+1)</code>, … ,</p><p>​    而是只标记质数集合中的数与 x 相乘的数，即 x · primes<sub>0</sub> , x · primes<sub>1</sub> , x⋅primes <sub>2</sub> , … ，</p><p>​    且在发现 x mod primes<sub>i</sub> = 0 时结束当前标记过程 (<strong>这一步确保了不会重复标记</strong>)。</p></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; primes = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] isPrime = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(isPrime, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                primes.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; primes.size() &amp;&amp; i * primes.get(j) &lt; n; ++j) &#123;</span><br><span class="line">                isPrime[i * primes.get(j)] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i % primes.get(j) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> primes.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度：O(n)\<br>&amp;空间复杂度：O(n)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java课设总结</title>
      <link href="/2021/11/18/JavaFX/"/>
      <url>/2021/11/18/JavaFX/</url>
      
        <content type="html"><![CDATA[<h3 id="简易PPT实现"><a href="#简易PPT实现" class="headerlink" title="简易PPT实现"></a>简易PPT实现</h3><span id="more"></span><h3 id="内容要求"><a href="#内容要求" class="headerlink" title="内容要求"></a>内容要求</h3><ol><li><strong>内容：开发一个简易的幻灯片制作与播放软件</strong></li><li><strong>基本功能：</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">新建幻灯片，幻灯片由不少于一个页面组成</span><br><span class="line">新建一个空白的幻灯片页面</span><br><span class="line">打开或保存整个幻灯片</span><br><span class="line">在幻灯片页面上绘制基本图形</span><br><span class="line">在幻灯片页面上绘制任意直线</span><br><span class="line">添加文字</span><br><span class="line">设定颜色与文字风格</span><br><span class="line">对幻灯片页面上已有的基本图形、线形、文字进行选取和移动</span><br><span class="line">通过鼠标拖动完成上述绘制和添加文字等操作</span><br></pre></td></tr></table></figure><ol><li><strong>选作功能：</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">幻灯片的全屏播放、翻页</span><br><span class="line">设定画笔、插入图像、修改图像（使用橡皮擦）</span><br><span class="line">图形填充、线型设置</span><br><span class="line">对幻灯片页面上已有的基本图形、线性、文字进行修改</span><br><span class="line">操作的撤销与重组</span><br><span class="line">菜单</span><br><span class="line">简易的JDBC连接MySQL数据库实现用户登录</span><br></pre></td></tr></table></figure><hr><h3 id="帮助文档"><a href="#帮助文档" class="headerlink" title="帮助文档"></a>帮助文档</h3><ol><li><p><strong>开发环境和插件选择</strong>：</p><p><code>Gradle + JavaFx + JPoneiX + JDK 1.8 + Spire.Presentation + IDEA </code></p><p>说明：</p><ol><li>按照 <code>non-modular + idea</code> 使用 JavaFx，会带来配置修改问题</li><li>使用 <code>JPoneiX</code> 开源项目优化 UI 界面，更加美观和方便</li><li>使用<code>Gradle</code>管理项目更加方便，兼容性更好</li></ol></li><li><p><strong>本人项目地址：</strong></p><p>GitHub：<a><a href="https://github.com/Eminem-x/JFoenix">https://github.com/Eminem-x/JFoenix</a></a></p></li></ol><ol start="2"><li><p><strong>JavaFX的基本操作指南：</strong></p><ol><li>官方文档: <a><a href="https://openjfx.io/">https://openjfx.io/</a></a><ul><li>基本内容以及示例说明</li><li>JavaFX的doc文档说明 </li></ul></li><li>WiKi教程: <a><a href="https://iowiki.com/javafx/javafx_images.html">https://iowiki.com/javafx/javafx_images.html</a></a></li><li>JavaFX和FXML的关系阐述： <a><a href="https://blog.csdn.net/theonegis/article/details/50181339">https://blog.csdn.net/theonegis/article/details/50181339</a></a></li></ol></li><li><p><strong>Java操作PPT的免费非开源组件:</strong></p><ol><li><p>官方网址：<a>冰蓝科技 PowerPoint 组件<a href="https://www.e-iceblue.cn/">https://www.e-iceblue.cn/</a></a></p></li><li><p>说明：</p><ol><li><p>此组件目前没有免费开源，会带有水印，不过不影响整体的实现，</p><p>可以通过适当操作，去掉水印的显示；</p></li><li><p>另外官方没有Gradle方式添加到工程，附上Gradle如何添加本地外包的方法：<br> <a href="https://blog.csdn.net/m1213642578/article/details/52763130?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link">Gradle添加本地外包</a></p></li></ol></li></ol></li><li><p><strong>JavaFX实现绘图功能的项目：</strong></p><ol><li>GitHub链接：<a><a href="https://github.com/FlyuZ/FYDrawing-JAVAFX">https://github.com/FlyuZ/FYDrawing-JAVAFX</a></a></li><li>可以参考实现方法，按照需求更改</li></ol></li><li><p><strong>JPoneiX开源项目：</strong></p><ol><li>GitHub链接：<a href="https://github.com/sshahine/JFoenix">https://github.com/sshahine/JFoenix</a></li><li>官方doc文档：<a><a href="https://javadoc.io/doc/com.jfoenix/jfoenix/latest/overview-summary.html">https://javadoc.io/doc/com.jfoenix/jfoenix/latest/overview-summary.html</a></a></li><li>此开源项目美化了JavaFx的组件UI，并且提供了许多便于使用和操作的组件</li></ol></li><li><p><strong>可用 Icon 的选取：</strong></p><ol><li>样式链接：<a><a href="https://fontawesome.com/v5.15/icons?d=gallery&amp;p=4&amp;s=solid&amp;m=free">https://fontawesome.com/v5.15/icons?d=gallery&amp;p=4&amp;s=solid&amp;m=free</a></a></li><li>使用时在 <code>Extern Libraries</code>下寻找此插件的 <code>solid</code>样式，然后相应位置替换即可</li><li>其他图片可能会失效，尝试即可，推荐使用 <code>solid</code></li></ol></li></ol><hr><h3 id="项目演示"><a href="#项目演示" class="headerlink" title="项目演示"></a>项目演示</h3><ol><li><p>文件结构：</p><p><img src="/2021/11/18/JavaFX/java%E8%AF%BE%E8%AE%BE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="文件结构"></p></li><li><p>项目运行效果：</p><p><img src="/2021/11/18/JavaFX/java%E8%AF%BE%E8%AE%BE%E6%95%88%E6%9E%9C%E5%9B%BE1.png" alt="主界面"></p><p><img src="/2021/11/18/JavaFX/java%E8%AF%BE%E8%AE%BE%E6%95%88%E6%9E%9C%E5%9B%BE2.png" alt="画图"></p><p><img src="/2021/11/18/JavaFX/java%E8%AF%BE%E8%AE%BE%E6%95%88%E6%9E%9C%E5%9B%BE3.png" alt="放映"></p></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 课程设计 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
