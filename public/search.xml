<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>正向代理和反向代理区别</title>
      <link href="/2023/01/21/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/01/21/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p>代理（Proxy）通常是指用户和服务器之间的中介，常见的主要有正向代理和反向代理，</p><p><strong>正向代理确保网站绝不与用户直接通信。而反向代理确保用户不会与后端服务器直接通信。</strong></p><img src="https://raw.githubusercontent.com/Eminem-x/Eminem-x.github.io/source/source/_posts/tool/proxy1.png" style="max-width: 70%"><img src="https://raw.githubusercontent.com/Eminem-x/Eminem-x.github.io/source/source/_posts/tool/proxy2.png" style="max-width: 70%"><h3 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h3><h4 id="正向代理（Forward-Proxy）"><a href="#正向代理（Forward-Proxy）" class="headerlink" title="正向代理（Forward Proxy）"></a>正向代理（Forward Proxy）</h4><p>大多数情况下，常说的代理服务器指的是最普通的代理，即正向代理。</p><p>这类代理位于用户之前，在用户与其访问的服务器之间充当中介，意味着用户的请求要通过正向代理后才能抵达网页，</p><p>从互联网检索数据后，数据就会被发送到代理服务器并将其重定向后返回请求者，</p><p>从互联网服务器的角度来看，这个请求是有代理服务器、而不是用户发送的，正向代理还可以用于缓存信息。</p><h5 id="正向代理的类型"><a href="#正向代理的类型" class="headerlink" title="正向代理的类型"></a>正向代理的类型</h5><p>现在有各种不同类型的正向代理，最常见的分类是按来源分：住宅代理、数据中心代理</p><p><strong>住宅代理</strong>：由互联网服务提供商（ISP）提供、绑定物理位置的 IP 地址</p><p><strong>数据中心代理：</strong>不属于 ISP，这些地址来自于二级来源，例如：数据中心</p><h5 id="正向代理的用途"><a href="#正向代理的用途" class="headerlink" title="正向代理的用途"></a>正向代理的用途</h5><p>个人用户或企业出于各种原因使用正向代理：</p><ol><li><p><strong>访问受限地理位置</strong>：用户浏览互联网时，能浏览的内容通常由所在的地理位置来决定，</p><p> 使用正向代理时，用户可以访问定位给其他国家/地区的各种内容。例如，对于提供广告验证服务的公司，</p><p> 这一特点尤其有用。无论这些公司处于任何地理位置，都可以自由监控广告投放，</p><p> 例如，您想要了解自己投放的广告在巴西是否可以显示，可以使用巴西代理；也可以用德国代理访问德国的内容。</p></li><li><p><strong>确保匿名性：</strong>可以用作额外的安全保护层，可以通过使用自己的 IP 地址来隐藏网页服务器的真实IP 地址，</p><p> 这就是使用正向代理服务器来确保更高级别的匿名性和安全性的原因。</p></li><li><p><strong>网络抓取：</strong>公司通常采集数据来帮助改进营销、定价和其他策略。可通过网络抓取有助于在市场上保持竞争力。</p></li></ol><p>正向代理也可以用于控制和监控互联网的使用、创建和管理社交媒体帐户等。</p><h4 id="反向代理（Reverse-Proxy）"><a href="#反向代理（Reverse-Proxy）" class="headerlink" title="反向代理（Reverse Proxy）"></a>反向代理（Reverse Proxy）</h4><p><strong>反向代理</strong>服务器位于后端服务器之前，将客户端请求转发至这些服务器。<strong>反向代理</strong>通常用于提高防护、速度和可靠度。</p><p>反向代理从客户端获取请求，将请求传递到其他服务器，然后将其转发回相关客户端，使它看起来像是初始代理服务器在处理请求。</p><p>这类代理可以确保用户不会直接访问原始服务器，因此可为这类网页服务器提供匿名性。</p><p>尽管对普通消费者和普通人不会特别有用，但反向代理服务器非常适合服务提供商和<strong>每天访问量大的网站</strong>。</p><p>这些代理可以保护网页服务器，增强网站性能并帮助避免过载，反向代理也可用于负载平衡、缓存和 SSL 加密。</p><h5 id="反向代理的类型"><a href="#反向代理的类型" class="headerlink" title="反向代理的类型"></a>反向代理的类型</h5><p>可以根据特性来区别两款主要反向代理：普通反向代理、负载均衡器：</p><p><strong> 普通反向代理</strong>：从客户端拦截请求，将请求定向到服务器进行处理，然后再将它返回至客户端，主要用于安全方面。 </p><p><strong>负载均衡器</strong>：可以在多个其他服务器中间分配流量，并管理所有服务器之间的客户端-服务器通信，</p><p>这种类型更适合在不同的服务器之间均匀分配负载，从而提高速度和性能。</p><h5 id="反向代理的用途"><a href="#反向代理的用途" class="headerlink" title="反向代理的用途"></a>反向代理的用途</h5><p>网站和服务提供商可能出于各种原因使用反向代理，部分用途如下：</p><ol><li><p><strong>负载均衡</strong>：高流量的网站有时可能需要反向代理服务器来处理传入流量。一个热门站点不会自行处理流量，</p><p> 而可能在多个后端服务器之间分配流量，从而提高容量以处理大量请求。</p><p> 如果其中一台服务器过载并出现故障，可以将流量重定向至其它在线服务器，以确保网页正常运行，</p><p> 网站工程师甚至可以添加更多后端服务器到此负载均衡器，以增加容量，满足不断提高的性能要求。</p></li><li><p><strong>缓存</strong>：可以缓存请求的数据。需要存储大量图片可以通过缓存内容，降低网站服务器的负载来提高网站性能。 </p></li><li><p><strong>匿名信和安全性</strong>：由于反向代理拦截所有传入请求，它们会为后端服务器带来更高层级的保护，</p><p> 它可以阻止来自特定 IP 地址的可疑流量，从而有助于防止恶意访问者滥用网页服务器。</p></li></ol><h3 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h3><blockquote><p><a href="https://oxylabs.cn/blog/reverse-proxy-vs-forward-proxy">https://oxylabs.cn/blog/reverse-proxy-vs-forward-proxy</a></p></blockquote><h4 id="正向代理和反向代理的区别"><a href="#正向代理和反向代理的区别" class="headerlink" title="正向代理和反向代理的区别"></a>正向代理和反向代理的区别</h4><p><strong>正向代理</strong>和<strong>反向代理</strong>之间的关键区别在于，前者由客户端使用，例如专用网络内的用户；而后者由互联网服务器使用。</p><p><strong>正向代理</strong>可以与用户定位于专用网络中，也可以用于在线。</p><p>正向代理确保网站绝不与用户直接通信。而反向代理确保用户不会与后端服务器直接通信。</p><p>这两类代理之间的另一个区别在于它们的用途。我们已经讨论过各种代理的一些常见用例。</p><p>出于隐私原因使用正向代理访问受限制的内容、进行网络抓取等。</p><p>而网页服务器使用反向代理来避免过载、加强对恶意用户的安全防范、缓存、SSL 加密等。</p><p>因此，这些代理可用于完全不同的任务，这就是它们之间的主要区别。</p><h4 id="正向代理是否可以充当反向代理？"><a href="#正向代理是否可以充当反向代理？" class="headerlink" title="正向代理是否可以充当反向代理？"></a>正向代理是否可以充当反向代理？</h4><p>简而言之，<strong>正向代理服务器无法用作反向代理服务器</strong>。尽管这些代理概念相近，它们的用途完全不同。</p><p>代理本身不只是一个 IP 地址。代理由 IP 地址和能够以预期方式运行的专用软件组成。</p><p>由于正向代理和反向代理分别用于截然不同的任务，它们各自都有不同的软件来确保顺利运转。</p><p>因此，无法将正向代理用作反向代理。</p>]]></content>
      
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>年度总结</title>
      <link href="/2022/12/31/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
      <url>/2022/12/31/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p>2022 年结束了，今年对我来说是一个转折点，发生了很多事情，但是最终结果走向是好的，</p><p>以前没有这样整理记录过，回顾过去的二十多年，经历了很多，但是似乎没有办法追溯到根源，</p><p>所以便有了这篇 annual summary，悟已往之不谏，知来者之可追。</p><h3 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h3><p>年初的时候个人压力比较大，因为不准备读研，所以需要准备春招，但很多知识都不会，也没有一个明确的方向，</p><p>完全凭着自己去搜集资料，甄别信息，磕磕绊绊的学习，也时常怀疑自己是否走在正确的道路上，也担心失败，</p><p>整体的就业环境不太好，寒假在家的时候时常学习到深夜，也经常不出门，和女朋友之间也有了矛盾，为日后埋下了种子，</p><p>后来稀里糊涂的通过了字节的面试，运气确实比较好，也记录过这个经历：「<a href="https://eminem-x.github.io/2022/03/15/%E9%9D%A2%E8%AF%95%E6%84%9F%E6%82%9F/">面试感悟</a>」，居然已经过去九个月了，</p><p>因为异地加上生活节奏的不同，和玥玥在拿到录取结果之前分手了，当时还是挺无奈的，无力感涌上全身，</p><p>最后在五月份的时候从学校前往广州实习，当时我也不知道以后会如何走向，但现在回头看看，我是无比幸运的，</p><p>关于实习的一些经历，我也有过记录：「<a href="https://eminem-x.github.io/2022/05/15/%E5%AE%9E%E4%B9%A0%E9%97%AE%E9%A2%98/">实习问题</a>」、「<a href="https://eminem-x.github.io/2022/08/14/%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/">实习总结</a>」，也很感谢同事和领导对于我的包容以及鼓励，</p><p>九月份的转正答辩是残酷的，有人成功有人失败，我幸运地通过了，也逃过了残酷的秋招，并且过程中也学习到很多知识，</p><p>在这个过程中，我和玥玥复合了，再见面的时候，用一见如故形容或许不恰当，但是确实一扫阴霾，虽然依然有分歧，</p><p>尽管生活节奏依然不同，但周末假期可以见面：「<a href="https://eminem-x.github.io/2022/09/26/%E5%91%A8%E6%9C%AB(9.24-9.25)/">周末记录</a>」、「<a href="https://eminem-x.github.io/2022/10/08/%E5%9B%BD%E5%BA%86%E5%81%87%E6%9C%9F/">国庆假期</a>」，后来因为疫情封校，也没办法再见面了，</p><p>在公司上班和在学校读书对我来说其实区别不大，个人也比较宅吧，不过有时候确实感觉非常疲惫，慢慢适应吧，</p><p>这一年的学习，很感激大学同学以及同事的指引和分享，自己有了清晰的认知：「<a href="https://eminem-x.github.io/2022/12/31/%E8%AF%BB%E4%B9%A6%E6%B8%85%E5%8D%95/">读书清单</a>」，</p><p>家里面也发生了很多事情，让我意识到自己也到了经历老人因病困扰的阶段了，或者说生死离别，</p><p>回顾过去，一眨眼已经过完三个七年了，时间越来越快，留下的人和事却越来越少，希望未来会更好吧。</p><h3 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h3><ol><li>计算机学习的路上发生了质的变化，从懵懵懂懂到有了自己前进的方向</li><li>家庭发生一些事情，学会去面对和经历，尽到自己的责任和义务</li><li>完成了去年的三个新年愿望：找到实习、在广州找到工作、和玥玥依然在一起</li></ol><p>对于工作和学习过程，通过 Github 和 Gitlab 的 contributions 来记录：</p><img src="https://raw.githubusercontent.com/Eminem-x/Eminem-x.github.io/source/source/_posts/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/2022github.jpg" style="max-width: 70%"><img src="https://raw.githubusercontent.com/Eminem-x/Eminem-x.github.io/source/source/_posts/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/2022gitlab.jpg" style="max-width: 70%">]]></content>
      
      
      <categories>
          
          <category> Thinking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thinking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书清单</title>
      <link href="/2022/12/31/%E8%AF%BB%E4%B9%A6%E6%B8%85%E5%8D%95/"/>
      <url>/2022/12/31/%E8%AF%BB%E4%B9%A6%E6%B8%85%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p>2022 年买了很多书，但是却没有读完多少，更多的是由于自身惰性导致的，希望明年能够坚持读下去书籍，</p><p>不过 2022 年对我来说发生了很多事情，而源源不断的力量除了周围人帮助，还有来源于书籍的力量，</p><p>并且看过很多其他人的建议，整理读书笔记也是重要的事情，所以也整理一下读书清单，</p><p>当然这里的读书清单不仅仅包括书籍，还会有一些不错的课程和博客推荐。</p><h3 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h3><h4 id="Acwing-系列课程"><a href="#Acwing-系列课程" class="headerlink" title="Acwing 系列课程"></a>Acwing 系列课程</h4><ol><li><p><strong>算法基础课、Linux 基础课</strong></p><p> 这两门课程我是跟着走完的，强烈推荐给想要学习算法、了解 Linux 基础命令的同学，内容短小精悍，</p><p> 能够比较系统的去学习算法以及入门算法流程，Linux 部分则是在日常开发工作中比较常见实用。</p></li><li><p><strong>LeetCode 究极班、Django 框架课</strong></p><p> 这两门课程我跟着走完一半，后来因为时间原因就没再跟进，不过其中学到的知识方法依然实用，</p><p> 跟着一起刷完 LeetCode 前 1500 所有非会员题目，与自己刷不同的点在于，更加优雅和奇妙的解法，</p><p> Django 框架课个人觉得不在于讲授 python 的框架，而是在于把控如何起一个前后端服务，</p><p> 从 python 到 Django，再到前端三大件，部署时的 docker、nginx，以及 thrift 的使用都非常实用，</p><p> 如果时间精力比较充裕的话，我还是比较推荐学习的。</p></li><li><p><strong>Web 应用课、SpringBoot 框架课</strong></p><p> 这两门课程我还没开始，不过打算有时间去学学 Web 应用课，前后端都尽量涉足，但是有所偏向。</p></li></ol><h4 id="极客时间"><a href="#极客时间" class="headerlink" title="极客时间"></a>极客时间</h4><ol><li><p><strong>MySQL 实战 45 讲</strong></p><p> 比较出名了，个人觉得后端开发同学都应该花时间去学习，对于整体把握数据库非常有帮助。</p></li><li><p><strong>趣谈网络协议</strong></p><p> 如果对于计算机网络仍然有些迷糊，这门课程会按照日常生活实际来逐步介绍网络的组成以及流程。</p></li></ol><h4 id="黑马程序员系列"><a href="#黑马程序员系列" class="headerlink" title="黑马程序员系列"></a>黑马程序员系列</h4><p>B站上有免费资源，Spring、SpringBoot、Redis、Java Web、Maven 等等课程，</p><p>尽管从实际来说讲的很琐碎，但是个人学习下来，对于小白来说还是非常有帮助的，这个看个人偏向。</p><h4 id="代码整洁之道"><a href="#代码整洁之道" class="headerlink" title="代码整洁之道"></a>代码整洁之道</h4><p>书籍本身也说到了，没有几年开发经验无法完全做到，读完之后对于日常代码还是有影响的，不过很难完全做到。</p><h4 id="Go-语言程序设计语言"><a href="#Go-语言程序设计语言" class="headerlink" title="Go 语言程序设计语言"></a>Go 语言程序设计语言</h4><p>黑皮书出品，网上评价褒贬不一，个人觉得如果在没有接触过其他语言的情况下，可能有些晦涩难懂，</p><p>可以去通过 Go 官网学习基础语法，或者其他入门书籍，这本书更加偏向实战以及大量的实例，推荐阅读。</p><h4 id="Go-语言高级编程"><a href="#Go-语言高级编程" class="headerlink" title="Go 语言高级编程"></a>Go 语言高级编程</h4><p>更多的是对于 Go 整体性能设计的 overview，书的后半部分也涵盖了开发过程中常见的设计模式以及思想，</p><p>整体读下来，觉得还不错，对于日常开发过程中的语法糖、以及组件运用都会有帮助。</p><h4 id="C-程序设计语言"><a href="#C-程序设计语言" class="headerlink" title="C 程序设计语言"></a>C 程序设计语言</h4><p>慕名而来 K&amp;R，大致浏览了书的前半部分，除了 C 语言语法，还会有很多例题以及源码的示例。</p><h4 id="深入理解-Java-虚拟机"><a href="#深入理解-Java-虚拟机" class="headerlink" title="深入理解 Java 虚拟机"></a>深入理解 Java 虚拟机</h4><p>当时走马观花跟着走了一遍，其中很多地方不仅仅是 special for Java，很多地方都适用，</p><p>如果有时间和精力更推荐跟着书中安装 JDK 源码学习，不然可能会无法理解其中细节。</p><h4 id="数据结构与算法（Java版）"><a href="#数据结构与算法（Java版）" class="headerlink" title="数据结构与算法（Java版）"></a>数据结构与算法（Java版）</h4><p>读完了大半，入门书籍，但是需要对 Java 语法比较熟悉，当然也有助于 Java 的学习。</p><h4 id="鸟哥的-Linux-私房菜"><a href="#鸟哥的-Linux-私房菜" class="headerlink" title="鸟哥的 Linux 私房菜"></a>鸟哥的 Linux 私房菜</h4><p>个人觉得内容太多了，比较琐碎，读者可能无法抓住重点，可以在日常开发学习中当作字典来用。</p><h4 id="图解-HTTP"><a href="#图解-HTTP" class="headerlink" title="图解 HTTP"></a>图解 HTTP</h4><p>快速跟着走了一遍，比较基础入门，可以在空闲时间阅读，后面可以当字典用。</p><h4 id="图解-TCP-IP"><a href="#图解-TCP-IP" class="headerlink" title="图解 TCP/IP"></a>图解 TCP/IP</h4><p>相较于 http，更加晦涩一些，不过整体比较通俗易懂，可以二者先后一起阅读。</p><h4 id="计算机网络-自顶向下方法"><a href="#计算机网络-自顶向下方法" class="headerlink" title="计算机网络 自顶向下方法"></a>计算机网络 自顶向下方法</h4><p>当时整体读下来，不知所云，随着工作学习更进一步，对其中的内容也有了更清晰的理解。</p><h4 id="七天用Go从零实现系列"><a href="#七天用Go从零实现系列" class="headerlink" title="七天用Go从零实现系列"></a>七天用Go从零实现系列</h4><p>网络博主：<a href="https://geektutu.com/post/gee.html">https://geektutu.com/post/gee.html</a></p><p>从零实现类似 gin、gorm、grpc、gcache 的框架，比较基础，代码示例以及讲解都很清晰，推荐 Go 新手学习，</p><p>并且我自己也打算在此基础上去完成毕业设计，也有助于日常后端开发工作的理解。</p><h4 id="未能坚持下去的书籍课程"><a href="#未能坚持下去的书籍课程" class="headerlink" title="未能坚持下去的书籍课程"></a>未能坚持下去的书籍课程</h4><p>最开始同学推荐给我的 CSAPP、OSTEP、MIT6.S081 这几门课程比较硬核，</p><p>以及 byteTech 内部的一些课程，自己没能坚持下去，希望明年能够完成。</p><h3 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h3><p>学习过程中整理的笔记基本也在这个仓库中：<a href="https://github.com/Eminem-x/Learning">https://github.com/Eminem-x/Learning</a></p><p>回顾一下，发现阅读的更多是基础书籍，当然很多工作中学习到的技巧以及工具使用，无法量化的用某本书来代替，</p><p>但是仍然需要努力，战胜自己的惰性，能够坚持学习下去，笨鸟先飞，慢慢提升自己的知识水平，</p><p>整体来说，今年对我是一个转折点，对于计算机的学习有了更清晰的目标和认知，希望明年能够进步。</p>]]></content>
      
      
      <categories>
          
          <category> Thinking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thinking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国庆假期</title>
      <link href="/2022/10/08/%E5%9B%BD%E5%BA%86%E5%81%87%E6%9C%9F/"/>
      <url>/2022/10/08/%E5%9B%BD%E5%BA%86%E5%81%87%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p>自高中和她相识，我们基本一直处于异地的状态，没有好好地在一起陪伴过，而我也因为个人原因，</p><p>没有抽出足够的时间和精力去照顾她的情绪，五年来我们之间的感情比电影里的桥段更加曲折和伤感，</p><p>这次国庆，从学校接她再到送她回学校，一切都像梦一样，记录下来，存储在这片属于自己的空间。</p><h3 id="Timeline"><a href="#Timeline" class="headerlink" title="Timeline"></a>Timeline</h3><p><img src="%E6%97%B6%E9%97%B4%E7%BA%BF.png"></p><p>主要我身体比较差，出去玩一会就累了，不过还是一起去了很多有意思的地方，吃了很多特色美食，</p><p>我们一致认为，这七天时间给五年的委屈画上了一个不太圆满的句号，我们仍需努力，一起走下去。</p><h3 id="Detail"><a href="#Detail" class="headerlink" title="Detail"></a>Detail</h3><h4 id="09-30"><a href="#09-30" class="headerlink" title="09/30"></a>09/30</h4><p>我提前下班从海珠区赶地铁到番禺区大学城去接她，也是第一次感受到挤地铁，心里还是蛮触动的，</p><p>到了学校，她还是老样子，让我在门口等着她出来，然后伴随着暮色，一起去吃提前约定好的大学城新疆菜，</p><p>吃完打算来局紧张刺激的桌球，但是人太多了，便一起回家，开启我们的第一次国庆假期生活。</p><img src="https://raw.githubusercontent.com/Eminem-x/Eminem-x.github.io/source/source/_posts/%E5%9B%BD%E5%BA%86%E5%81%87%E6%9C%9F/%E6%96%B0%E7%96%86%E8%8F%9C1.png" alt="疆楼兰" height=400><h4 id="10-01"><a href="#10-01" class="headerlink" title="10/01"></a>10/01</h4><p>两个大懒猪一觉睡到中午十二点，当然我也没想到未来七天我们都超越了这个时间，不过就当休息啦，</p><p>下午去小区门口吃的「如轩海鲜锅」，而后一起去看「新灰姑娘」电影，去「LEGO」买了很多积木，</p><table><tr><td><img src="https://raw.githubusercontent.com/Eminem-x/Eminem-x.github.io/source/source/_posts/%E5%9B%BD%E5%BA%86%E5%81%87%E6%9C%9F/%E7%81%B0%E5%A7%91%E5%A8%98.png"></td><td><img src="https://raw.githubusercontent.com/Eminem-x/Eminem-x.github.io/source/source/_posts/%E5%9B%BD%E5%BA%86%E5%81%87%E6%9C%9F/lego1.jpg"></td></tr></table><p>晚上一起去吃「海底捞」，难怪我以前一直觉得不好吃，原来启动方式不对，狠狠地学了一手，埋下伏笔。</p><img src="https://raw.githubusercontent.com/Eminem-x/Eminem-x.github.io/source/source/_posts/%E5%9B%BD%E5%BA%86%E5%81%87%E6%9C%9F/soup.jpg" alt="" height=400><blockquote><p>她还是蛮开心我陪她去看女孩子心动的电影的，但其实我一直愿意，只是以前有各种原因，也很无奈，</p><p>不过都还好啦，五年的感情就像沏茶，我们渐渐敞开心扉理解彼此，才会边回味无穷边喃喃自语。</p></blockquote><h4 id="10-02"><a href="#10-02" class="headerlink" title="10/02"></a>10/02</h4><p>她说不想吃湘菜，因为怕辣，但是还是抱着好奇心，尝了尝我常去的一家湘菜店「南村香」，只能说真香，</p><p>晚上我们在家拼积木，一起打会游戏，出发去吃「纸包鱼」，已经忘记菜是什么味道了，但是清晰记得泪水，</p><img src="https://raw.githubusercontent.com/Eminem-x/Eminem-x.github.io/source/source/_posts/%E5%9B%BD%E5%BA%86%E5%81%87%E6%9C%9F/%E7%BA%B8%E5%8C%85%E9%B1%BC.png" alt="" height=400><p>彼此之间坦露一些心结，争吵也罢，难受也罢，或者委屈也罢，但是我们都长大了，知晓彼此的意义。</p><h4 id="10-03"><a href="#10-03" class="headerlink" title="10/03"></a>10/03</h4><p>今天可算是给我累坏了，至少我是肉眼可见的疲惫，按照她的活说，我就是苹果电池，断崖式的体力消耗，</p><p>带她品尝了一波我自研的「杨国福麻辣烫」吃法，还算不错，本来打算去「海珠湿地公园」，结果需要 <code>72</code> 小时检测，</p><p>便更改目的地去了「沙面岛」，欣赏壮观的建筑群还有形形色色的路人，中间也因为拍照发生过一些争执，</p><img src="https://raw.githubusercontent.com/Eminem-x/Eminem-x.github.io/source/source/_posts/%E5%9B%BD%E5%BA%86%E5%81%87%E6%9C%9F/%E6%95%99%E5%A0%82n.jpg" alt="" height=400><p>临近夜色，本来打算一起去美食街，误打误撞来到「上下九步行街」，最后饿的不行点顿「麦当劳」，开启肥胖，</p><img src="https://raw.githubusercontent.com/Eminem-x/Eminem-x.github.io/source/source/_posts/%E5%9B%BD%E5%BA%86%E5%81%87%E6%9C%9F/%E9%BA%A6%E6%97%8B%E9%A3%8En.png" alt="" height=400><p>恋爱就是酸酸甜甜吧，本身就赋有意义，不必试图参透，享受在一起的日子就好，过程非常重要。</p><h4 id="10-04-—-10-05"><a href="#10-04-—-10-05" class="headerlink" title="10/04 — 10/05"></a>10/04 — 10/05</h4><p>或许前几天太劳累了，相对沉寂了两天，睡睡懒觉、拼拼积木、洗洗衣服、打打游戏、看看电影，</p><img src="https://raw.githubusercontent.com/Eminem-x/Eminem-x.github.io/source/source/_posts/%E5%9B%BD%E5%BA%86%E5%81%87%E6%9C%9F/%E6%A6%B4%E8%8E%B2%E6%8A%AB%E8%90%A8.JPG" alt="" height=400><p>「驴肉火烧」味道不如老家，「丘大叔」柠檬茶我俩都无感，「鲍师傅」味道正常，「蛙火锅」性价比较差，</p><img src="https://raw.githubusercontent.com/Eminem-x/Eminem-x.github.io/source/source/_posts/%E5%9B%BD%E5%BA%86%E5%81%87%E6%9C%9F/%E8%9B%99%E7%81%AB%E9%94%85.png" alt="" height=400><p>不过总体来说还是体验了很多不同的食物，嘴是没闲着，另外也互相走进对方私下的生活，更加了解彼此。</p><h4 id="10-06-—-10-07"><a href="#10-06-—-10-07" class="headerlink" title="10/06 — 10/07"></a>10/06 — 10/07</h4><p>因为三号公园被防住了，重新杀回去，景色真的很不错，话说确实很久没有将自己沉浸在自然之中了，</p><p>这几年一直是两点一线的生活，周围的事物还是很美好的，希望以后也有时间和精力和她一起去放松身心，</p><img src="https://raw.githubusercontent.com/Eminem-x/Eminem-x.github.io/source/source/_posts/%E5%9B%BD%E5%BA%86%E5%81%87%E6%9C%9F/%E5%B0%8F%E6%BA%AAn.png" alt="" height=400><p>并且上次发现「海底捞」启动方式不对，也重新杀回去了，体验感拉满，她不会做饭，但是很会吃饭。</p><img src="https://raw.githubusercontent.com/Eminem-x/Eminem-x.github.io/source/source/_posts/%E5%9B%BD%E5%BA%86%E5%81%87%E6%9C%9F/rice.jpg" alt="" height=400><p>时间过的还是很快的，我们就要分别了，不过离的近，「青年火炉」烤肉性价比一般，不过可以尝试，</p><img src="https://raw.githubusercontent.com/Eminem-x/Eminem-x.github.io/source/source/_posts/%E5%9B%BD%E5%BA%86%E5%81%87%E6%9C%9F/%E7%83%A4%E8%82%89n.png" alt="" height=400><p>送她回到大学城，白驹过隙，思绪一涌而上，也很难想象有一天送她回大学，时间是没有记忆的，但是有痕迹。</p><h3 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h3><p>我对她像家人一样，见了面就是愿意托付，兜兜转转，我们仍在一起，这真的是一件美好的事情，</p><p>她问我为什么不愿意发朋友圈或者空间，我渐渐不喜欢向别人透露我的生活，静静地做好自己的事情，</p><p>给自己留一片独立的空间，但是我会记录我们之间的故事，放在不会被打扰的地方，就像情感一样。</p><img src="https://raw.githubusercontent.com/Eminem-x/Eminem-x.github.io/source/source/_posts/%E5%9B%BD%E5%BA%86%E5%81%87%E6%9C%9F/%E5%85%AC%E4%B8%BB%E6%8A%B1.png" alt="" height=400>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周末(9.24-9.25)</title>
      <link href="/2022/09/26/%E5%91%A8%E6%9C%AB(9.24-9.25)/"/>
      <url>/2022/09/26/%E5%91%A8%E6%9C%AB(9.24-9.25)/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p>在确定实习，来沈阳之前，我们分手了，异地恋会让间隙逐渐放大，但是随后的时间会去弥补裂痕，</p><p>从沈阳来到广州，尽管两个人节奏不同，一个工作一个上学，但是周末可以一起见面，比以前还是好很多的，</p><p>便想到记录下周末生活，以后也有迹可循，方便回顾吧。</p><h3 id="Detail"><a href="#Detail" class="headerlink" title="Detail"></a>Detail</h3><p>早上在学校见面，然后去吃的泰菜，不过感觉味道一般，可能不会去喽，</p><img src="https://raw.githubusercontent.com/Eminem-x/Eminem-x.github.io/source/source/_posts/%E5%91%A8%E6%9C%AB/%E6%B3%B0%E8%8F%9C.jpg" style="max-width: 60%"> <p>下午一起去的猫咖，运气比较好，我进门相中的猫主动跳进我怀里，没有白来，</p> <img src="https://raw.githubusercontent.com/Eminem-x/Eminem-x.github.io/source/source/_posts/%E5%91%A8%E6%9C%AB/%E6%8A%B1%E7%8C%AB2.jpg" style="max-width: 60%"> <img src="https://raw.githubusercontent.com/Eminem-x/Eminem-x.github.io/source/source/_posts/%E5%91%A8%E6%9C%AB/%E6%8A%B1%E7%8C%AB1.jpg" style="max-width: 60%"><p>晚上来的美食街，吃了小吃，路上又遇到独角兽，不过是活动，轻松拿下，最后一起去打台球，</p> <img src="https://raw.githubusercontent.com/Eminem-x/Eminem-x.github.io/source/source/_posts/%E5%91%A8%E6%9C%AB/%E7%BE%8E%E9%A3%9F%E8%A1%97.jpg" style="max-width: 60%"> <img src="https://raw.githubusercontent.com/Eminem-x/Eminem-x.github.io/source/source/_posts/%E5%91%A8%E6%9C%AB/%E7%8B%AC%E8%A7%92%E5%85%BD.png" style="max-width: 60%"><p>生活还是很美好的，在一起的时候很多误会和不开心也都随之消散。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google Plugins</title>
      <link href="/2022/08/27/Google%20Plugins/"/>
      <url>/2022/08/27/Google%20Plugins/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><blockquote><p>在使用 Google 浏览器时，遇到了很多非常棒的插件，整理以便使用。</p></blockquote><h3 id="Google-Plugins"><a href="#Google-Plugins" class="headerlink" title="Google Plugins"></a>Google Plugins</h3><ol><li>侧边翻译</li><li>Pinterest 收藏按钮</li><li>lastpass：整理保存密码</li><li>Quick QR：快速操作二维码</li><li>adblock：拦截阻止网页广告</li><li>custom cursor：自定义鼠标样式</li><li>Dark Reader：所有网页 Dark 模式</li><li>Bookmark Sidebar：侧边书签管理器</li><li>Https Everwhere：开启 https 加密连接</li><li>onetab：一键整理 tab，并且便捷寻找 tab</li><li>Adobe Acrobat：PDF 编辑、转化、签名工具</li><li>chrono download manager：Google 下载管理器</li><li>vimium：以 Vim 的方式操作网页，具体使用可参考<a href="https://zhuanlan.zhihu.com/p/113316942">链接</a></li><li>Grammarly: Grammar Checker and Writing App：语法检查</li></ol>]]></content>
      
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后端参数检验</title>
      <link href="/2022/08/18/%E5%90%8E%E7%AB%AF%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"/>
      <url>/2022/08/18/%E5%90%8E%E7%AB%AF%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><blockquote><p>最近在工作中处理后端参数校验时，总结了一些工具和方法，整理以便以后使用。</p></blockquote><h3 id="普通参数校验"><a href="#普通参数校验" class="headerlink" title="普通参数校验"></a>普通参数校验</h3><p>如何在 Gin 框架中添加请求参数检验，在工作开发中，了解到一个开源工具：<code>gotagexpr</code>，</p><p><code>GitHub</code> 链接：<a href="https://github.com/bytedance/go-tagexpr">https://github.com/bytedance/go-tagexpr</a></p><p><code>Demo</code> 链接：<a href="https://github.com/Eminem-x/Learning/tree/main/Go/gin-doc-cn/gin-tagexpr">https://github.com/Eminem-x/Learning/tree/main/Go/gin-doc-cn/gin-tagexpr</a></p><p>在 <code>Request</code> 请求类型中增加 <code>tag</code>，通过正则表达式的方式，在绑定入参时，即可判断是否合法，</p><p>当然如果参数之间有限制关系的话，似乎仍需要 <code>if-else</code> 去解决，这里也只是推荐此工具。</p><p>更通用的是，可以对此抽取成通用方法，针对每个请求都无需关心如何处理，只需定义规则即可，</p><p>中间件抽取如下，只需要传入 <code>request</code> 的地址即可进行校验：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> middlewares</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/bytedance/go-tagexpr/v2/validator&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin/binding&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tagexpr = validator.New(<span class="string">&quot;tagexpr&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValidateArgs</span><span class="params">(c *gin.Context, request <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定request model</span></span><br><span class="line">err := c.ShouldBindBodyWith(request, binding.JSON)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> tagexpr.Validate(request) != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ErrInputInvalid <span class="comment">// 此处为自定义 error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图片校验"><a href="#图片校验" class="headerlink" title="图片校验"></a>图片校验</h3><p>实际业务场景中，用户上传图片后，前端传入 <code>tos</code>，而后将 <code>CDN</code> 地址传到后端，后端存入数据库，</p><p>因为未对 <code>uri</code> 校验，修改图片链接为任意，此时打开请求该图片的页面后，会发起请求，造成损失，</p><p>由于请求是本地浏览器发起的，也可以做到类似于肉鸡的行为，解决方法如下：</p><ol><li><p>后端下载传入链接的图片，判断是否为合法图片，具体实现，参考 <a href="https://github.com/Eminem-x/Learning/tree/main/middleware/Auth/img_validate">GitHub 链接</a></p><p>但是该方法并不可取，因为如果去请求传入的链接，所带来的影响更是不可控的，但可以用来判断是否为合法图片</p></li><li><p>根据 <code>CDN</code> 的 <code>Host</code> 特征，进行简易的匹配判断即可</p></li></ol><p>但是最好的方式还是整个流程托付给后端去做处理，可以保证整个过程的原子性和一致性。</p><h3 id="CSRF-校验"><a href="#CSRF-校验" class="headerlink" title="CSRF 校验"></a>CSRF 校验</h3><p>跨站点请求伪造攻击是指攻击者通过设置好的陷阱，属于被动攻击，</p><p>强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，</p><p>有可能造成以下影响：</p><ul><li>利用已通过认证的用户权限更新设定信息</li><li>利用已通过认证的用户权限购买商品</li><li>利用已通过认证的用户权限在留言板上发表评论</li></ul><p>比如攻击者在留言板部下陷阱：<code>&lt;img src=&quot;http://example.com/msg?q=hello&quot;&gt;</code>，就可以影响其他用户。</p><p>在实际业务场景中，也需要防止其他站点对项目站点进行恶意请求，例如下面的 <code>html</code> 文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- CSRF PoC --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">history.pushState(<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;https://examplle.com/xxx&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit request&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>只需要添加 <code>Header</code> 即可，具体的开源代码参考：<a href="https://github.com/utrack/gin-csrf">https://github.com/utrack/gin-csrf</a></p>]]></content>
      
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实习总结</title>
      <link href="/2022/08/14/%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2022/08/14/%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p>转眼间距离实习已经过去三个月了，期间跟随开发的项目也于本周六正式上线，我也随之前往下一个阶段：秋招，</p><p>本身我也很愿意留在这个部门，但是 HR 不给予稳定的答复，Leader 也不能确定我能否留下，所以需要投递简历，</p><p>并且听周围同学说，转正相对于校招工资会被压价，其实我对于这个蛮无奈的，觉得很不合理，但毕竟我只是普通员工，</p><p>尽管当下这个部门并不是核心部门，但我想留下沉淀自己的学习，就当读研了，一步一步提升自己，并且大家都很好，</p><p>并且广州的风土人情以及美食，我还想去体验一下，给自己时间和精力去思考过去和未来，放缓脚步，</p><p>接下来主要记录这段实习期间的工作内容，还有收获的东西吧，算是完成一个里程，回顾一下。</p><h3 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h3><h4 id="实习内容"><a href="#实习内容" class="headerlink" title="实习内容"></a>实习内容</h4><p>实习期间主要是负责资产配件助手项目，涉及客户端、前端、小程序端与后端的联调，我主要负责后端，</p><p>刚来的时候，我还不会 Go 语言，也不会其框架：Gin、Gorm，只留给我一星期的学习时间，</p><p>第一个需求是给前端与后端的联调中，增加 RBAC 权限管理，现在回头看看，当时设计的并不合理，</p><p>并且代码写的很糟糕，Gorm 中很多规范性约束没有合理应用，并且没有考虑到权限管理的三权分立以及越权，</p><p>磕磕绊绊地完成了这个需求之后，因为每周六我都去公司学习，结果恰好一天，后端负责人来公司了，</p><p>我才知道他要离职了，而这个项目就交给了我和另外一个实习生，这一交付就是两个月的加班和联调，</p><p>因为项目要于八月初上线，而以前的测试不够严谨，有很多 corner case 没有考虑到，而我主要负责业务部分，</p><p>疯狂看和前端、客户端、小程序端的交互模块，梳理流程，解决 OAT 验收出现的问题，并且重构核心代码，</p><p>学习了 Websocket、MQTT、RPC、Postman、EMQX、字节云等常用开发组件和工具的使用，</p><p>也学习到了很多前端、小程序端的知识细节以及网络防御，对于以前看过的基础知识有了更深的理解和应用，</p><p>从结果上来看，完成的还算可以，基本上帮助这个项目的成功上线，但是我也深深地意识到一个问题，</p><p>一定要考虑你工作内容的替代性，如果你做的事情随便找一个人培训一下就可以上任，那你就是码农，</p><p>之所以这样说，是因为转正得不到一个肯定的答复，回头看看这个项目，业务上不需要很深的技术，只需要逻辑，</p><p>但是如何将这样一个项目架构起来，才是困难的，我想这是我应该去学习的部分，应该去提升的部分。</p><h4 id="实习感受"><a href="#实习感受" class="headerlink" title="实习感受"></a>实习感受</h4><p>周围有很多同学当听到部门里没有转正希望后，就开始无心工作，不去做好自己手上的业务，开始搪塞，</p><p>和另外一个正式员工交流后，得到的答复是：「他们想要 offer，而你是想学习」，我不知道该如何评价，</p><p>毕竟当下学习的目的就是为了得到工作，但是我觉得更重要的应该是提升自己，汲取当下项目值得学习的模块，</p><p>做好每一个需求，然后总结复盘，再去结合经验学习，而不是投身于面试，为了面试去背很多没有用过的知识。</p><p>另外在部门里，结识遇到了很多程序员、产品经理，大家一起负责各个模块，感觉真的很棒，我喜欢这种氛围，</p><p>大家都是在思考，互帮互助，遇到问题愿意帮助你，愿意一起想办法去解决，愿意分享自己的知识，</p><p>我觉得这种氛围很适合学习，远大于我在学校里学到的知识，或许是因为从事业务部门的原因。</p><h3 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h3><p>秋招也开始了，希望能够留在这个部门，并且工资在我理想范围之内，我不希望被过分压榨，</p><p>这周末也完成了美团和大疆的笔试，前者 5 题完成 4.6，后者 AK，还算顺利，希望给面试机会吧，减缓焦虑，</p><p>最重要的还是提升自己，提升自己的不可替代性，保持学习的节奏，也不要骄傲自满，希望越来越好。</p>]]></content>
      
      
      <categories>
          
          <category> Thinking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thinking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mqtt机制问题</title>
      <link href="/2022/08/08/mqtt%E9%97%AE%E9%A2%98/"/>
      <url>/2022/08/08/mqtt%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p>最近在灰度测试过程中，业务侧报上来一个偶现问题，也是困扰了我一个周末，最终于周一解决：</p><blockquote><p>广州用户在自助柜前，没有点击扫码出货，但是出货了，并且后台中没有该用户的记录</p></blockquote><p>直觉告诉我，这绝不是偶现，并且我内心里很确定，这绝对是个漏洞，因为计算机不会骗人，所以苦想了很久，</p><p>功夫不负有心人，成功解决，并且由于新灰度测试城市增加，果然复现几率增加，过程中学到很多，记录如下。</p><hr><h3 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h3><h4 id="排查问题"><a href="#排查问题" class="headerlink" title="排查问题"></a><strong>排查问题</strong></h4><p>因为后端项目最初没有接入 <code>LogID</code>，所以排查困难，不过由于几周前我接入了流氏日志，</p><p>所以可以通过 <code>Log</code> 、数据库记录和当时的操作人员回忆流程，去判断和定位问题原因，</p><p>经过排查，发现一条特殊的数据，同时间下，西安某个用户借用了此物品，梳理流程后，觉得问题应该在这，</p><p><strong>但是后端通过 mqtt 推送的消息怎么会被两台机器同时消费呢？并且为什么其他地方没有出现这个问题呢？</strong></p><p>带着疑问，我先排查后端代码问题，确认无误后，联系客户端同学，进过讨论，得到了答案：</p><p><strong>客户端同学以为后端 mqtt 推送是指定了具体的 clientID，因此没有做检验，所以导致同时出货，</strong></p><p>那么为什么其他地方没有出现呢？原因是：<strong>客户端只有在显示出货那个界面时，才会接收 mqtt 推送消息。</strong></p><p>得到原因后，立刻和客户端同学模拟测试，果不其然就是因为这个原因造成的，但是对于如何解决出现了分歧。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h4><ul><li><p>后端指定具体的 <code>clientID</code> 推送 mqtt 消息</p></li><li><p>客户端在接收 mqtt 消息时，做一次判断比较，确定是否消费</p></li><li><p>对于每台客户端机器根据 <code>machine_code</code> 生成唯一的 <code>topic</code>，确保推送唯一</p></li></ul><h4 id="查询资料"><a href="#查询资料" class="headerlink" title="查询资料"></a><strong>查询资料</strong></h4><p>首先通过<a href="https://www.emqx.io/docs/en/v5.0/#benefits">官网</a>的介绍，可以得到以下内容，说明 mqtt 本身就是高性能的，一个实例足够撑起业务：</p><blockquote><blockquote><p><strong>Massive Scale</strong>: Scale to 100 million concurrent MQTT connections with a single EMQX 5.0 cluster.</p><p><strong>High Performance</strong>: Move and process millions of MQTT messages per second in a single broker.</p><p><strong>Low Latency</strong>: Guarantee sub-millisecond latency in message delivery with the soft real-time runtime.</p></blockquote></blockquote><p>其次我的同事，通过 <a href="https://stackoverflow.com/questions/42265001/how-to-publish-a-message-to-a-specific-client-in-mosquitto-mqtt">stackoverflow </a>获得了一个关于 mqtt 指定客户端推送非常棒的回答：</p><blockquote><p>There is no way to publish a message to a single subscriber at the MQTT protocol level.</p><p>One of the key tenets of a publish/subscribe system is to totally decouple the publisher from the subscribers, there is no way for a publisher to know if there are any subscribers to a given topic let alone target one specifically.</p><p>Using a topic for each device is not a problem as there is virtually no overhead in the broker for each topic. You can also use ACLs to ensure that each client can only subscribe their own topic (while still being able to publish to others if needed)</p><p>You could use a single topic that all clients subscribe to and encode the target device in the payload and have the device decide if the message is for it’s self. One downside to this is that you can’t apply ACLs to this model. Another downside is increased network traffic, since uninteresting messages will be sent to many subscribers.</p></blockquote><p><strong>通过以上资料可以确定当下最好的解决方案就是第二种：客户端根据自身的唯一标识判断是否消费当前指令，</strong></p><p>确定好方案后，经过测试，解决问题，也是在解决不久后，业务侧开始大量反馈此问题，所以不要放过漏洞。</p><hr><h3 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h3><p>我非常庆幸我自己对于这个偶现现象的坚持，因为最开始的反馈是在上周五，周六我夜不能寐，放弃秋招笔试，</p><p>查询 mqtt 资料，查询数据库记录、查询后端日志、下载客户端代码、回忆情景，直到凌晨三点多，</p><p>尽管当时没有解决，但是大量的资料数据收集，让我能够确定问题出在哪里，并且联系客户端同学进行排查出问题所在，</p><p>我也非常庆幸我的坚持，让这个问题在增加灰度测试站点时，得以快速解决，而不是简单地认为不关自己的事情，随它去吧，</p><p>尽管我不一定在这个部门转正，尽管我还有秋招，但是我觉得重要的事情是，做好当下手头的工作，提升自己，而不是追逐，</p><p>也是通过这个事情，我更加觉得基础的重要性，因为应用上都大体相似，但是基础知识的积累可以更好的定位问题，</p><p>并且对于业务代码而言，经验也是非常重要的，也算是肯定了我不去读研，投身于具体工作的决心吧，希望以后继续坚持。</p>]]></content>
      
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gin-Swagger</title>
      <link href="/2022/07/14/Gin-Swagger/"/>
      <url>/2022/07/14/Gin-Swagger/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p>在现如今前后端分离的模式下，前端如何快捷准确地确定接口类型、请求参数以及响应结构体，是开发中不可或缺的步骤，</p><p>与此同时，后端如何相应地即使反馈，也很重要，而 <code>swagger</code> 解决了这个问题，方便了前后端的联调测试，</p><p>接下来的内容主要是：在 <code>Go</code> 中使用 <code>Gin</code> 框架如何接入 <code>swagger</code> 服务，以及简易的代码包组织结构，</p><p>具体代码参考仓库：<a href="https://github.com/Eminem-x/Learning/tree/main/Go/gin-doc-cn/gin-swagger">https://github.com/Eminem-x/Learning/tree/main/Go/gin-doc-cn/gin-swagger</a></p><h3 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h3><h4 id="安装-swag"><a href="#安装-swag" class="headerlink" title="安装 swag"></a>安装 <code>swag</code></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/swaggo/swag/cmd/swag</span><br></pre></td></tr></table></figure><h4 id="校验是否安装成功"><a href="#校验是否安装成功" class="headerlink" title="校验是否安装成功"></a>校验是否安装成功</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swag -v</span><br></pre></td></tr></table></figure><h4 id="在项目中安装-gin-swagger-依赖"><a href="#在项目中安装-gin-swagger-依赖" class="headerlink" title="在项目中安装 gin-swagger 依赖"></a>在项目中安装 <code>gin-swagger</code> 依赖</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/swaggo/gin-swagger</span><br><span class="line">go get -u github.com.swaggo/gin-swagger/swaggerFiles // 如果报错，不影响使用</span><br></pre></td></tr></table></figure><h4 id="添加配置注解"><a href="#添加配置注解" class="headerlink" title="添加配置注解"></a>添加配置注解</h4><p>具体路径，参考仓库代码即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> router</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;gin-swagger/services&quot;</span></span><br><span class="line">_ <span class="string">&quot;gin-swagger/swagger/docs&quot;</span> <span class="comment">// swagger 生成成功后, 添加进来</span></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">swaggerFiles <span class="string">&quot;github.com/swaggo/files&quot;</span></span><br><span class="line">ginSwagger <span class="string">&quot;github.com/swaggo/gin-swagger&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitRouter</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line">setRouter(r)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run the server</span></span><br><span class="line"><span class="keyword">if</span> err := r.Run(<span class="string">&quot;:8000&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panicf(<span class="string">&quot;startup service failed, err:%v\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test swagger</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @title Swagger API</span></span><br><span class="line"><span class="comment">// @version 1.0</span></span><br><span class="line"><span class="comment">// @description This is a api server for test.</span></span><br><span class="line"><span class="comment">// @termsOfService http://swagger.io/terms/</span></span><br><span class="line"><span class="comment">// @contact.name API Support</span></span><br><span class="line"><span class="comment">// @contact.url http://www.swagger.io/support</span></span><br><span class="line"><span class="comment">// @contact.email support@swagger.io</span></span><br><span class="line"><span class="comment">// @license.name Apache 2.0</span></span><br><span class="line"><span class="comment">// @license.url http://www.apache.org/licenses/LICENSE-2.0.html</span></span><br><span class="line"><span class="comment">// @host localhost:8000</span></span><br><span class="line"><span class="comment">// @BasePath /</span></span><br><span class="line"><span class="comment">// @query.collection.format multi</span></span><br><span class="line"><span class="comment">// @securityDefinitions.basic BasicAuth</span></span><br><span class="line"><span class="comment">// @securityDefinitions.apikey ApiKeyAuth</span></span><br><span class="line"><span class="comment">// @in header</span></span><br><span class="line"><span class="comment">// @name Authorization</span></span><br><span class="line"><span class="comment">// @securitydefinitions.oauth2.application OAuth2Application</span></span><br><span class="line"><span class="comment">// @tokenUrl https://example.com/oauth/token</span></span><br><span class="line"><span class="comment">// @scope.write Grants write access</span></span><br><span class="line"><span class="comment">// @scope.admin Grants read and write access to administrative information</span></span><br><span class="line"><span class="comment">// @securitydefinitions.oauth2.implicit OAuth2Implicit</span></span><br><span class="line"><span class="comment">// @authorizationurl https://example.com/oauth/authorize</span></span><br><span class="line"><span class="comment">// @scope.write Grants write access</span></span><br><span class="line"><span class="comment">// @scope.admin Grants read and write access to administrative information</span></span><br><span class="line"><span class="comment">// @securitydefinitions.oauth2.password OAuth2Password</span></span><br><span class="line"><span class="comment">// @tokenUrl https://example.com/oauth/token</span></span><br><span class="line"><span class="comment">// @scope.read Grants read access</span></span><br><span class="line"><span class="comment">// @scope.write Grants write access</span></span><br><span class="line"><span class="comment">// @scope.admin Grants read and write access to administrative information</span></span><br><span class="line"><span class="comment">// @securitydefinitions.oauth2.accessCode OAuth2AccessCode</span></span><br><span class="line"><span class="comment">// @tokenUrl https://example.com/oauth/token</span></span><br><span class="line"><span class="comment">// @authorizationurl https://example.com/oauth/authorize</span></span><br><span class="line"><span class="comment">// @scope.admin Grants read and write access to administrative information</span></span><br><span class="line"><span class="comment">// @x-extension-openapi &#123;&quot;example&quot;: &quot;value on a json format&quot;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setRouter</span><span class="params">(r *gin.Engine)</span></span> &#123;</span><br><span class="line"><span class="comment">// 必须在 router 中引入, 不然访问 swagger 会报 404 错误</span></span><br><span class="line">r.GET(<span class="string">&quot;/swagger/*any&quot;</span>, ginSwagger.WrapHandler(swaggerFiles.Handler))</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">&quot;/login&quot;</span>, services.Login)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意以下的代码必须在 <code>router</code> 中引入，不然访问 <code>swagger</code> 会报 404</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/swagger/*any&quot;</span>, ginSwagger.WrapHandler(swaggerFiles.Handler))</span><br></pre></td></tr></table></figure><h4 id="注释接口"><a href="#注释接口" class="headerlink" title="注释接口"></a>注释接口</h4><p>详细的参数配置参考：<a href="https://github.com/swaggo/swag#general-api-info">https://github.com/swaggo/swag#general-api-info</a></p><p>示例代码（封装请求体、响应体、序列化）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Login</span></span><br><span class="line"><span class="comment">// @Summary Login</span></span><br><span class="line"><span class="comment">// @Tags Admin</span></span><br><span class="line"><span class="comment">// @Produce json</span></span><br><span class="line"><span class="comment">// @Success 200 &#123;object&#125; pkg.SuccessResponse&#123;data=serializers.LoginResponse&#123;login=serializers.Login&#125;&#125;</span></span><br><span class="line"><span class="comment">// @Failure 404,500 &#123;object&#125; pkg.ErrorResponse</span></span><br><span class="line"><span class="comment">// @Router /login [get]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Login</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">_, _ = c.Writer.WriteString(<span class="string">&quot;Login!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通常需要封装好 response 和 serializer</span></span><br><span class="line">c.JSON(http.StatusOK, pkg.SuccessResponse&#123;</span><br><span class="line">Status: <span class="string">&quot;200 OK&quot;</span>,</span><br><span class="line">Data:   serializers.SerializeLogin(),</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="生成-swagger-文档"><a href="#生成-swagger-文档" class="headerlink" title="生成 swagger 文档"></a>生成 <code>swagger</code> 文档</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-o 指定文档生成目录</span><br><span class="line">-g 指定 swagger-info 所在的目录 默认 main.go</span><br><span class="line">--parseDependency 解析外部依赖文件夹中的 go 文件，默认禁用，一般是在 init 生成文件时提示无法识别 struct 时添加</span><br><span class="line"></span><br><span class="line">swag init -g router/router.go -o swagger/docs --parseDependency</span><br><span class="line">rm -rf swagger &amp;&amp; swag init -g router/router.go -o swagger/docs --parseDependency</span><br></pre></td></tr></table></figure><p>生成 <code>swagger</code> 文档之后再在 <code>router.go</code> 文件中引入，引入下面内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_ <span class="string">&quot;gin-swagger/swagger/docs&quot;</span> <span class="comment">// swagger 生成成功后, 添加进来</span></span><br></pre></td></tr></table></figure><h4 id="访问-swagger-界面"><a href="#访问-swagger-界面" class="headerlink" title="访问 swagger 界面"></a>访问 <code>swagger</code> 界面</h4><p>完成上述步骤之后启动项目，然后通过 <code>http://localhost:port/swagger/index.html</code> 访问即可</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>珂朵莉树</title>
      <link href="/2022/06/23/%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91/"/>
      <url>/2022/06/23/%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p><strong>珂朵莉树</strong>（Chtholly Tree）起源于<a href="https://link.zhihu.com/?target=https://codeforces.com/problemset/problem/896/C">CF896C</a>，那道题要求我们实现一种数据结构，可以较快地实现：</p><blockquote><p>区间加、区间赋值、求区间第k大值、求区间n次方和</p></blockquote><p>就此需求来说，普通的树状数组、线段树等显然难以胜任，看上去需要一种相当复杂的数据结构。</p><p>然而，在出题人的题解中，实现的数据结构却很简单，最初用自己的 ID 把这种数据结构命名为 ODT，后又改名为珂朵莉树。</p><p>珂朵莉树的适用范围是有<strong>区间赋值</strong>操作且<strong>数据随机</strong>的题目。其实珂朵莉树看上去并不像是树状数据结构，</p><p>但因为一般要用到有序集合，而有序集合是用红黑树实现的，所以也不算名不副实。</p><p>在随机数据下，珂朵莉树可以达到 <em>O(nloglogn)</em> 的复杂度，参见<a href="https://zhuanlan.zhihu.com/p/102786071">这篇文章</a>（这篇文章博主也是非常厉害的)。</p><p>而我接触这个特殊的数据结构是因为同学推荐力扣<a href="https://leetcode.cn/problems/range-module/submissions/">每日一题</a>用这种方法实现，起到一个抛砖引玉的效果。</p><ul><li>C++ 实现参考：<a href="https://zhuanlan.zhihu.com/p/106353082">https://zhuanlan.zhihu.com/p/106353082</a></li><li>Rust 实现参考：<a href="http://heavensheep.xyz/?p=276">http://heavensheep.xyz/?p=276</a></li></ul><p>本篇后续实现方式为 Java，利用的数据结构是 TreeSet，底层实现也是红黑树。</p><h3 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h3><h4 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h4><p>在介绍 ODT 之前，先按照朴素做法取实现，采用有序集合，去判断各种情况的发生以及如何处理，</p><p>并且利用底层插入寻找结点的时间复杂度为 O(logn) 来解决这道问题，但是实现起来非常复杂，细节很多，</p><p>我在按照这种方法去实现时，一直在调试，详情参考：<a href="https://leetcode.cn/problems/range-module/solution/range-mo-kuai-by-leetcode-solution-4utf/"> LeetCode 官方题解</a></p><p>我在具体实现时候也优化了一些代码逻辑并且添加了 comment，便于理解，参考代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangeModule</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 利用 TreeMap, 表示 intervals, 注意是半开区间</span></span><br><span class="line">    TreeMap&lt;Integer, Integer&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RangeModule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 利用 TreeMap 性质找到第一个严格大于 left 的 entry</span></span><br><span class="line">        Map.Entry&lt;Integer, Integer&gt; entry = map.higherEntry(left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果存在 entry, 寻找小于 left 的 entry; 反之, 取最后一个 entry</span></span><br><span class="line">        Map.Entry&lt;Integer, Integer&gt; start = (entry != <span class="keyword">null</span> ? map.lowerEntry(entry.getKey()) : map.lastEntry());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前区间包含 [left, right), 不需再操作</span></span><br><span class="line">        <span class="keyword">if</span> (start != <span class="keyword">null</span> &amp;&amp; start.getValue() &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前区间的右值小于 right, 更新 [left, right) 为 [l, right), 并移除 [l, r]</span></span><br><span class="line">        <span class="keyword">if</span> (start != <span class="keyword">null</span> &amp;&amp; start.getValue() &gt;= left) &#123;</span><br><span class="line">            left = start.getKey();</span><br><span class="line">            map.remove(start.getKey());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以上操作已经处理好最大小于 left 的 entry, 现在更新其后的区间</span></span><br><span class="line">        <span class="keyword">while</span> (entry != <span class="keyword">null</span> &amp;&amp; entry.getKey() &lt;= right) &#123;</span><br><span class="line">            right = Math.max(right, entry.getValue());</span><br><span class="line">            map.remove(entry.getKey());</span><br><span class="line">            entry = map.higherEntry(entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">queryRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        Map.Entry&lt;Integer, Integer&gt; entry = map.higherEntry(left);</span><br><span class="line">        Map.Entry&lt;Integer, Integer&gt; start = (entry != <span class="keyword">null</span> ? map.lowerEntry(entry.getKey()) : map.lastEntry());</span><br><span class="line">        <span class="comment">// 存在并且区间满足即返回 true</span></span><br><span class="line">        <span class="keyword">return</span> start != <span class="keyword">null</span> &amp;&amp; (start.getValue() &gt;= right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        Map.Entry&lt;Integer, Integer&gt; entry = map.higherEntry(left);</span><br><span class="line">        Map.Entry&lt;Integer, Integer&gt; start = (entry != <span class="keyword">null</span> ? map.lowerEntry(entry.getKey()) : map.lastEntry());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果当前区间重叠 [left, right)</span></span><br><span class="line">        <span class="keyword">if</span> (start != <span class="keyword">null</span> &amp;&amp; start.getValue() &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (start.getKey() == left) &#123;</span><br><span class="line">                map.remove(start.getKey());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(start.getKey(), left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (start.getValue() != right) &#123;</span><br><span class="line">                map.put(right, start.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start != <span class="keyword">null</span> &amp;&amp; start.getValue() &gt; left) &#123;</span><br><span class="line">            map.put(start.getKey(), left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除后续区间</span></span><br><span class="line">        <span class="keyword">while</span> (entry != <span class="keyword">null</span> &amp;&amp; entry.getKey() &lt; right) &#123;</span><br><span class="line">            map.remove(entry.getKey());</span><br><span class="line">            <span class="keyword">if</span> (right &lt; entry.getValue()) &#123;</span><br><span class="line">                map.put(right, entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">            entry = map.higherEntry(entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="玛朵莉树"><a href="#玛朵莉树" class="headerlink" title="玛朵莉树"></a>玛朵莉树</h4><p>ODT 核心函数只有两个，<code>split()</code> 和 <code>assign()</code>，前者用于分割区间，后者用于区间赋值，也是其精髓。</p><p>思路如下：</p><ol><li>用一个结构体或者类存储区间信息：左端点，右端点以及区间值</li><li><code>split()</code> 函数用于分割区间，<strong>因此需要在开始初始化一个涵盖数据范围的区间</strong></li><li><code>assign()</code> 函数用于区间赋值以及<strong>区间合并</strong>，使得零散的区间变得整齐</li></ol><p>可以参考下图例子，加以理解具体操作：</p><p><img src="%E7%8E%9B%E6%9C%B5%E8%8E%89%E6%A0%91.png"></p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangeModule</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line">    TreeSet&lt;Node&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Node 需要实现比较器接口</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left, right, val;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span> <span class="params">(Node o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.left - o.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">split</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        Node node = set.ceiling(<span class="keyword">new</span> Node(pos, <span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// 获取大于等于 pos 的结点</span></span><br><span class="line">        <span class="comment">// 如果 node 左边界等于 pos</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; node.left == pos) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果不存在大于等于其的结点, 取最后一个结点</span></span><br><span class="line">            node = set.last();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 初始化时插入结点为 [0, N], 故存在 lower</span></span><br><span class="line">            node = set.lower(node);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 移除此结点 并新增分割后的结点</span></span><br><span class="line">        <span class="keyword">int</span> left = node.left, right = node.right, val = node.val;</span><br><span class="line">        set.remove(node);</span><br><span class="line">        set.add(<span class="keyword">new</span> Node(left, pos, val));</span><br><span class="line">        node = <span class="keyword">new</span> Node(pos, right, val);</span><br><span class="line">        set.add(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回分割后右侧结点</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assign</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果使用迭代器需要注意先 split right, 否则不需考虑顺序</span></span><br><span class="line">        Node end = split(right), begin = split(left);</span><br><span class="line">        <span class="comment">// 清空范围内的所有结点, 因为范围内区间可能已经被细分</span></span><br><span class="line">        <span class="keyword">while</span> (set.ceiling(<span class="keyword">new</span> Node(left, <span class="number">0</span>, <span class="number">0</span>)).left &lt; right) &#123;</span><br><span class="line">            set.remove(set.ceiling(<span class="keyword">new</span> Node(left, <span class="number">0</span>, <span class="number">0</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加入新结点</span></span><br><span class="line">        set.add(<span class="keyword">new</span> Node(left, right, val));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        Node rNode = split(right);</span><br><span class="line">        Node lNode = split(left);</span><br><span class="line">        <span class="comment">// 判断区间内是否均满足</span></span><br><span class="line">        <span class="keyword">while</span> (lNode.left &lt; rNode.left) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lNode.val != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lNode = set.higher(lNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RangeModule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化必不可少, 因为后续需要区间分割</span></span><br><span class="line">        set.add(<span class="keyword">new</span> Node(<span class="number">0</span>, N, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        assign(left, right, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">queryRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        assign(left, right, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h3><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ol><li><p><strong>保持算法高效的核心在于哪里？</strong></p><p>除了有序集合本身红黑树高效的插入查询之外，还在于 <code>assign</code> 函数清理掉细碎的小区间，合并成大区间，</p><p>这样提高了 <code>query</code> 也就是查询操作的效率，有点 GC 的感觉</p></li><li><p><strong>为什么 C++ 实现 <code>assign</code> 中需要先 <code>split right</code> ?</strong></p><p>这是因为迭代器的原因，先左再右可能会导致迭代器失效，因为修改了 <code>left iterator</code>，</p><p>上述 Java 代码中，就不需要考虑此问题，有兴趣可以自行更换下顺序，看看代码执行结果，</p><p>这里我本身理解也是浅尝则止，是以后需要学习跟进的地方，有关红黑树的实现</p></li><li><p><strong>最开始初始化一个区间是否必须？</strong></p><p>必须，因为后续操作需要操作区间，并且必须是涵盖所有测试数据范围的区间</p></li><li><p><strong>为什么和官方解法的运行时间差距很大？</strong></p><p>因为官方题解是遇到一个新区间或者删除时才会去处理结点，而玛朵莉树是相当于在分裂和合并，</p><p>随着操作的增加，结点数也在增加，固然时间就增加，并且后者有很多 <code>new()</code> 操作，</p><p>附上学到的一个术语：<code>ad-hoc</code>：指先用低成本实现一个简单易理解的算法，如果后续发现瓶颈再去优化</p><blockquote><p><strong>Ad hoc</strong> is a <a href="https://en.wikipedia.org/wiki/List_of_Latin_phrases">Latin phrase</a> meaning literally ‘to this’. In English, it typically signifies a solution for a specific purpose, problem, or task rather than a <a href="https://en.wikipedia.org/wiki/Generalization">generalized</a> solution adaptable to collateral instances</p></blockquote></li></ol><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>既然抛砖引玉入门了这道题目，再回到原本的出处<a href="https://link.zhihu.com/?target=https://codeforces.com/problemset/problem/896/C">CF896C</a>，还剩下三个操作没有实现，具体实现就是暴力，</p><p>附上 C++ 伪代码，实现步骤很简单，如果对于上述过程都理解了，自然也就明白了。</p><ol><li><p>区间加</p><blockquote><p><em>l</em> <em>r</em> <em>x</em> : For each <em>i</em> such that <em>l</em> ≤ <em>i</em> ≤ <em>r</em>, assign <em>ai</em> + <em>x</em> to <em>ai</em>.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll l, ll r, ll v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> end = <span class="built_in">split</span>(r + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = <span class="built_in">split</span>(l); it != end; it++)</span><br><span class="line">        it-&gt;v += v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>区间第 K 小值：</p><blockquote><p><em>l</em> <em>r</em> <em>x</em> : Print the <em>x</em>-th smallest number in the index range [<em>l</em>, <em>r</em>], i.e. </p><p>the element at the <em>x</em>-th position if all the elements <em>ai</em> such that <em>l</em> ≤ <em>i</em> ≤ <em>r</em> are taken </p><p>and sorted into an array of non-decreasing integers. It’s guaranteed that 1 ≤ <em>x</em> ≤ <em>r</em> - <em>l</em> + 1.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">kth</span><span class="params">(ll l, ll r, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> end = <span class="built_in">split</span>(r + <span class="number">1</span>);</span><br><span class="line">    vector&lt;pair&lt;ll, ll&gt;&gt; v; <span class="comment">// 这个pair里存节点的值和区间长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = <span class="built_in">split</span>(l); it != end; it++)</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(it-&gt;v, it-&gt;r - it-&gt;l + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()); <span class="comment">// 直接按节点的值的大小排下序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) <span class="comment">// 然后挨个丢出来，直到丢出k个元素为止</span></span><br><span class="line">    &#123;</span><br><span class="line">        k -= v[i].second;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> v[i].first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>区间值求幂的和</p><blockquote><p><em>l</em> <em>r</em> <em>x</em> <em>y</em> : Print the sum of the <em>x</em>-th power of <em>ai</em> such that <em>l</em> ≤ <em>i</em> ≤ <em>r</em>, modulo <em>y</em>, i.e. </p><p><img src="https://www.zhihu.com/equation?tex=%5Csum_%7Bi=l%7D%5E%7Br%7D%7Ba_i%5Ex%7D%5Cbmod+y" alt="[公式]"></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">sum_of_pow</span><span class="params">(ll l, ll r, ll x, ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> end = <span class="built_in">split</span>(r + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = <span class="built_in">split</span>(l); it != end; it++)</span><br><span class="line">        tot = (tot + <span class="built_in">qmi</span>(it-&gt;v, x, y) * (it-&gt;r - it-&gt;l + <span class="number">1</span>)) % y; <span class="comment">// qmi 快速幂</span></span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>在学习过程中，也接触到一对名词：<strong>在线算法（online algorithm）和离线算法（offline algorithm)</strong></p><p><a href="https://en.wikipedia.org/wiki/Online_algorithm">维基百科</a>举了这样一个例子，选择排序是离线算法，而插入排序是在线算法。</p><p>那就从这两个算法来看看在线算法和离线算法的区别：</p><p>选择排序是不断地从未排序的元素中找到最大（小）的元素放到排序序列的起始位置，</p><p>插入排序是不断将未排序的序列插入到有序的序列中，有序序列中的元素相对位置会在一定程度上被改变，</p><p>两种排序的本质区别在于，后面的操作对前面操作的结果是否有影响。</p><p><strong>更直观地讲，就是离线算法途中拿出来的结果就是最终结果的一部分，</strong></p><p><strong>而在线算法可能到了最后一步才能得到需要的结果，</strong></p><p><strong>而过程中产生中间结果都是为最后结果的输出而服务的。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人生七年</title>
      <link href="/2022/06/04/%E4%BA%BA%E7%94%9F%E4%B8%83%E5%B9%B4/"/>
      <url>/2022/06/04/%E4%BA%BA%E7%94%9F%E4%B8%83%E5%B9%B4/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><p>看完「人生七年」BBC 版其实已经过去半个月了，是我趁着从学校到公司实习闲暇之余看完的，</p><p>「UP 7 」是一部伟大的纪录片，带给我的思考和冲击，直到今天我才决定写下我的感悟和当下生活。</p><p>纪录片从上个世纪到现在这个时期，跨度很大，和他们生活在同一个时空，令人感慨，也令我动容，</p><p>恰好今年我也 21 岁了，也开始离开校园走向社会，去创造自己的生活，所以也会记录我的一些看法。</p><p>每个人的生活经历了几个沉浮的七年，相差很大，但是都有着自己的目的和感情寄托，物质或者精神，</p><p>28 岁之前带给我更多的是关于奋斗的思考，35 - 42 岁带给我关于生活的思考，而直到 63 岁则是生命。</p><p>不去讨论纪录片的内容，只讨论我看到的和我经历的：</p><ol><li><p>最大的共鸣之处在于：教育真的很重要，教育是在年轻的时候投入和收益最大转化比的选择，</p><p>教育是一个人无法被夺走的财富，伴随终生，并且带给你更多的选择和更高的收益，是受益终生的，</p><p>我很庆幸自己在过去的十几年中，成绩处于不错的水平，尽管贪玩，但是没有荒废学业，坚持到成年。</p></li><li><p>另外一个触动就是：好的婚姻是会提升彼此的，或许这个话题对于我而言不是很想提及，也不是现在面对的，</p><p>并且在我来到广州实习之前，也刚经历了分手，不过生活就是生活，感情也是生活的一部分，不能逃避，</p><p>现在我的状态不适合去约订终生，不过我也希望遇到合适的人，一直走下去，有一份寄托和依靠。</p></li><li><p>关于生命和家人，看着纪录片中的人不断表老，直到前阵子导演也去世，不得不感慨生命的短暂，</p><p>家人对于我而言也是很重要的，可是家庭的原因，让我也很难去处理应对，希望以后我能处理好，</p><p>对于生命，我希望我能做有意义的事，正如「钢铁是怎么炼成的」那样，不会因为碌碌无为而悔恨。</p></li><li><p>对于社会，我没什么想说的，我对政治不感兴趣，不喜欢勾心斗角，也不喜欢夸大其词，</p><p>要实干不要空谈，无论是外国还是中国，都存在一些问题，我希望我的国家越来越好，这是漫长的过程，</p><p>也有很多的言论说要去润往国外，能够让生活更轻松一些，事实可能是如此，但我更喜欢家的归属感，</p><p>当然世界那么大，我想去看看，有机会和时间也要出去走走，领略世界的差异和风情。</p></li><li><p>阶级差异，不用多说，是客观存在的，也是无可避免的，我的想法是这些不重要，重要的是做自己，</p><p>没有必要去抱怨，因为已经无法改变，但可以改变自己，尽管很累并且可能会失败，但需要迈出第一步。</p></li></ol><p>接下来我想记录的是，在 21 岁这个年龄，在六月这个时候，我所焦虑和感到迷茫的事情，但我已经有了抉择。</p><p>对于专业技能，是该侧重打好基础知识，还是去偏向工程知识，很显然目前来看如果为了工作肯定选择后者，</p><p>但是前者也很重要，这些不过多的赘述，在自己的思考以及同学朋友之间的讨论后，我的答案就是不能急于求成。</p><p>因为自打去年下定决心不读研之后，我就一直给自己压力，去学习知识，但是学的很粗糙，仅仅浮于表面，</p><p>重要的是享受过程，去做喜欢的事，不能带着太强的功利性，我觉得我自己在这里迷失了，脱离了学习的本质，</p><p>我还是按照前一阵子制定的计划按部就班的学下去，并且保持高效无论是在公司还是在自己的休闲时刻，</p><p>最后附上一句话：「talk is cheap, show me the code」</p>]]></content>
      
      
      <categories>
          
          <category> Thinking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thinking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实习问题</title>
      <link href="/2022/05/15/%E5%AE%9E%E4%B9%A0%E9%97%AE%E9%A2%98/"/>
      <url>/2022/05/15/%E5%AE%9E%E4%B9%A0%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><blockquote><p>暑期实习地点：广东省广州市海珠区赫基大厦 字节跳动 三个月</p></blockquote><h3 id="出行问题"><a href="#出行问题" class="headerlink" title="出行问题"></a>出行问题</h3><ol><li>暑期实习基本上都在学期结束之前，因此需要向学校说明情况，缓考或者线上考试，不要隐瞒出校；</li><li>广州可能梅雨季节，注意准备伞具以及多的干衣服，不过天气基本就是短袖短裤，可以考虑带长衣服；</li><li>如果飞机航班取消，可以考虑飞机 + 高铁或者高铁，因为也许因为暴雨导致航班不能正常出行；</li><li>到达广州火车高铁站或者飞机航站楼后，不要听信黄牛的言辞，比如：地铁不通或者维修路段，寻找打表出租；</li><li>一般第一天都会租宾馆，但是办公地点周围可能没有宾馆，需要提前扩大一下范围寻找合适的宾馆；</li><li>当然如果有疫情的话，一定要查看当地和广州的疫情政策，以免不必要的麻烦；</li><li>如果无法在原定日期到达实习地点，可以向 hr 说明情况，适当延缓日期，一般都很好沟通；</li></ol><h3 id="租房问题"><a href="#租房问题" class="headerlink" title="租房问题"></a>租房问题</h3><ol><li>字节跳动和「自如」有合作关系，不过影响不大，可以通过该平台寻找合适的公寓；</li><li>一般都是短租，如果推销长租一年，事后转租，尽量不要选择后者，以免不必要的麻烦；</li><li>短租房子数量一般比较少，可能需要合租，并且价格会上浮一点，不过应该都可以接受；</li><li>关于房补要求，可以向 hr 咨询具体的政策，然后扩大搜索范围，用地图校准即可；</li><li>当联系好相应的中介人后，可能会出现同行竞争的情况，一定要确保二者话语一致，避免上当受骗；</li><li>关于房子，建议实地考察，不要太相信照片，适合不适合自己，还是需要自己来看的；</li><li>租房交押金，不需要一次性付清，可以按月付，不过第一个月需要额外加上押金，另外水电费自费；</li><li>赫基大厦推荐两个小区：「佳信小区」和「泓景花园」距离最近，并且环境和周围设施可以；</li><li>一般而言房屋内设施都没什么问题，可以维修，不过还是推荐检查所有设施的状况；</li><li>房补需要自己申请，可以通过「自如」联系客服，让其提供有关房产的信息，合同里不包含这些图片；</li></ol><h3 id="生活用品"><a href="#生活用品" class="headerlink" title="生活用品"></a>生活用品</h3><ol><li>床上用品实习地点周围可能会比较贵，可以考虑从京东购买，发货比较快；</li><li>广州比较潮湿，购买干燥剂和香薰片放在衣柜里，避免衣服潮湿，散霉味；</li><li>广州虫子比较多，或者因为房子闲置很久，买驱虫剂和除螨剂喷洒，会好一点；</li><li>插座、烧水器、盆、扫把、晾衣杆、晾衣架、拖鞋、垃圾桶等都是需要的，可以一起下单；</li><li>房屋一般都配有厨房，做饭与否看个人时间，公司也一般都有餐食，不过周末可以考虑；</li><li>工资卡最初填写邮寄地址，建议直接填写公司所在地，因为需要到线下银行携带卡去激活办理；</li></ol>]]></content>
      
      
      <categories>
          
          <category> Thinking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thinking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「烟火」</title>
      <link href="/2022/05/11/%E3%80%8C%E7%83%9F%E7%81%AB%E3%80%8D/"/>
      <url>/2022/05/11/%E3%80%8C%E7%83%9F%E7%81%AB%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p><esacpe><span id="more"></span></escape></p><p>最近空闲时，接触了一款国产游戏「烟火」，游戏结束后，心情久久不能平复，游戏结束的背景音乐「送别」仍在回荡，</p><p>在写这篇感触时，耳机里播放的也正是这首曲子，将自己从现实拉回到游戏里，又从游戏里推回到现实中，</p><p>游戏的内容不需要去陈述，但是游戏带来的故事和思考，不亚于读了一本荡气回肠的名著，「more than game」，</p><p>从最开始恐怖情景的描述，到后来逐渐抽丝剥茧出一个悲惨的故事，或者说一个悲惨的现象，或者说很多人的故事，</p><p>烟火中故事的主要描述点似乎集中在封建迷信，但是带给我的感受不仅仅是封建迷信，而是每个人所背负的枷锁。</p><p>贯穿全文，我印象最深的就是那句诗：</p><blockquote><p>我的尸体，不会腐烂在泥土里，我会像鸟儿一样，死在天空中。</p></blockquote><p>母亲为了爱人，为了女儿，愿意牺牲自己，为自己附上了责任，承担着一切，走向悲剧，</p><p>女儿心疼母亲，知道母亲为了自己牺牲成熟了很多，「我希望母亲做自己开心的事情」，</p><p>医生因为身世，就困于大山，死去儿子的父母迷信于封建，又或者说无法接受儿子的去世，</p><p>不仅仅是一个人的悲剧，是一个社会，是一群人生活的缩影，带来的思考和触动直击人心。</p><p>无论是读书还是玩游戏或者做某些事情，很难不带入自己的心情沉浸其中，去思考自己的处境，</p><p>或许我没有被封建迷信残害，但何尝不是为自己了背上了枷锁呢？或者说责任和爱意。</p><p>从小到大，我知道家庭的难处，理解家里每个人的辛苦，也告诉自己要去分担这一切，</p><p>无论是我，还是我姐，我们都在为之奋斗，或许我们都无法从事自己喜欢的事情，像自由的风一样，</p><p>去做自己真正想做的事情，但是我们也甘愿去承担这份责任，去帮助家里。</p><p>与游戏中的母亲和医生，从本质上说，有什么区别呢？但我的母亲不也是这样吗？</p><p>为了他人，牺牲自己，奉献自己，尽管不能使自己逍遥自在，但可以让自己爱的人和事幸福，</p><p>对于自己而言，又何尝不是一种幸福呢？其实对我自己来说，我还是很喜欢现在的生活，</p><p>只不过很忙碌，丧失了很多情感，丧失了很多生活的色彩，有时候一点点的欣喜就可以让我开心许久。</p><p>每个人从小生活环境不一样，每个人的心态人生观也是不一样的，所以很难去让周围的人和你想的一样，</p><p>能做的就是对的起自己，最近也在重温「人生七年」这部纪录片，很多话都停留在脑海中，</p><p>相比于过错，错过更令人遗憾，但是自己的内心会告诉自己答案，「Blowin’ in the wind」。</p><p>每个人或许都对这款游戏有不同的理解，我也只是记录一下自己的感受，</p><p>马上就要前往新的城市去实习工作了，这何尝不是一种改变呢，像鸟儿一样，虽然但是，还算不错。</p>]]></content>
      
      
      <categories>
          
          <category> Thinking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thinking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表</title>
      <link href="/2022/04/28/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2022/04/28/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p>散列表的实现常常叫做散列（hashing），是一种用于以常数平均时间执行插入、删除和查找的技术。</p><p>通常又称其为哈希表，是一种非常有用的数据结构，有很多种实现方式，并且包含很多技巧，</p><p>整理这篇文章时，也重新阅读《数据结构与算法分析》的哈希部分，结合代码，更进一步了解一些概念。</p><p>哈希表与离散化相同点在于，都是将范围比较大的数据映射到范围较小的空间内，但是前者无序，后者有序，</p><p>哈希最重要的两个实现地方在于：如何构造一个好的散列函数和如何有效地解决冲突。</p><p>关于散列函数，在实际处理中或者算法中，分为整数和字符串两类，有不同的处理方式，</p><p>关于解决冲突，常见两种解决方式：分离链接法（拉链法）和开放定址法。</p><h3 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h3><h4 id="1-整数"><a href="#1-整数" class="headerlink" title="1. 整数"></a>1. 整数</h4><p>如果 <code>key</code> 为整数，那么常见的方式就是确定一个素数，而后对其取余，一般避免负数。</p><p>关于素数的选择是非常有必要的，能够使得关键字的分配均匀，提高整体的性能。</p><p>解决算法题中常用的技巧就是寻找比数据规模大的第一个素数（最好尽可能的离 <code>2</code> 的整数幂远）,</p><p>比如数据规模是 10<sup>5</sup> ，如果采用拉链法则声明为 <code>100003</code>，而开放寻址法则为 <code>200003</code>，经验值。</p><p>另外一个技巧就是，因为往往使用数组实现，<code>(x % N + N) % N</code> 可以避免负数的出现。</p><h4 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2. 字符串"></a>2. 字符串</h4><p>关于字符串的处理方式，其实是一个具体的算法，称为 <code>Rabin-Karp</code> 算法，相较于 <code>KMP</code> 更常用。</p><p>核心思想就是将字符串转为数字处理，将字符串用 <code>P</code> 进制表示，而后计算出每一位的哈希值，</p><p>通过比较哈希值，来确定二者是否相等，关于 <code>P</code> 的选择一般为：<code>131</code> 或者 <code>1331</code>，而模数选择 2<sup>64</sup> ，</p><p>在计算子序列时，利用类似前缀和的方法，就可以求出子序列对应的哈希值。</p><p>在 <code>Java</code> 中可以用 <code>long</code> 来代替，但是其最大值是 2<sup>63</sup> - 1，取模可能会出现负数溢出，但是并不需要处理，</p><p>至于原因，经过调试猜测，尽管会溢出，但是并不像整数一样作为数组下标，其是独立的所以不会影响。</p><p><em>（这里如果以后遇到了更好的解答，会再补充）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">solution</span><span class="params">(String s, <span class="keyword">int</span>[][] queries)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 也可以取为 1331</span></span><br><span class="line">    <span class="keyword">int</span> P = <span class="number">131</span>;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line">    <span class="keyword">long</span>[] h = <span class="keyword">new</span> <span class="keyword">long</span>[N];</span><br><span class="line">    <span class="keyword">long</span>[] p = <span class="keyword">new</span> <span class="keyword">long</span>[N];</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">      <span class="comment">// 尽管溢出，但是不需要处理</span></span><br><span class="line">        h[i + <span class="number">1</span>] = h[i] * P + s.charAt(i);</span><br><span class="line">        p[i + <span class="number">1</span>] = p[i] * P;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> left1 = queries[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> right1 = queries[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> left2 = queries[i][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> right2 = queries[i][<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">if</span> (get(h, p, left1, right1) == get(h, p, left2, right2)) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">(<span class="keyword">long</span>[] h, <span class="keyword">long</span>[] p, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[right] - h[left - <span class="number">1</span>] * p[right - left + <span class="number">1</span>]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-冲突处理"><a href="#3-冲突处理" class="headerlink" title="3. 冲突处理"></a>3. 冲突处理</h4><p>常见的有两种处理方式：分离链接法和开放定址法，还有一种双散列的方式。</p><h5 id="分离链接法"><a href="#分离链接法" class="headerlink" title="分离链接法"></a>分离链接法</h5><p>将散列到同一个位置的所有元素保留到一个表中，如果这个元素是新元素，那么采用头插法插入到链表前端，</p><p>这样处理不仅仅因为方便，还因为新插入的元素最有可能不久后被访问到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">100003</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] h = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] e = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] ne = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Arrays.fill(h, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = (x % N + N) % N;</span><br><span class="line">        e[idx] = x;</span><br><span class="line">        ne[idx] = h[k];</span><br><span class="line">        h[k] = idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = (x % N + N) % N;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[k]; i != -<span class="number">1</span>; i = ne[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e[i] == x) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h5><p>其又有三种处理方式：线性探测法、平方探测法和双散列，代码采用线性探测法实现。</p><p>思想比较简单，当前位置如果已经存在元素，那么就看下一个位置是否可取，直至结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 线性探测法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">200003</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] h = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> empty = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Arrays.fill(h, empty);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入和删除均使用此方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = (x % N + N) % N;</span><br><span class="line">        <span class="keyword">while</span> (h[k] != empty &amp;&amp; h[k] != x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (++k == N) &#123;</span><br><span class="line">                k = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，更具体的深入理解这三种处理方式的差异：</p><ol><li><p><strong>线性探测法</strong>糟糕的是，即使表相对较空，这样占据的单元也会开始形成一些区块，称为<strong>一次聚集</strong>，</p><p>也就意味着，该区块中的任何关键字都需要多次试选才能解决冲突，性能受到影响，</p><p>因此对于线性探测而言，让散列表填满元素并不是一个好主意，意味着大量的冲突出现。</p></li><li><p><strong>平方探测法</strong>是消除线性探测中一次聚集的问题，具体为如果遇到冲突，就平方级位置寻找，</p><p>虽然排除了一次聚集，但是散列到同一位置上的元素带来了<strong>二次聚集</strong>的麻烦。</p><p>除此之外，平方探测还有一个非常重要的结论：一旦表被填充超过一半，就不能保证插入成功了。</p><p>结论证明：当表一半是空的，并且表的大小是素数，就能保证插入一个新元素。</p></li><li><p><strong>双散列</strong>包含一个用于处理冲突的 <code>hash</code> 函数，但要保证不能计算得到 <code>0</code> 值。</p></li></ol><h3 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h3><p>前面介绍了如何散列以及处理冲突的方式，那么来到 <code>JDK</code> 源码中看看是如何实现的。</p><p><code>HashSet</code> 和 <code>HashMap</code> 通常是用分离链接散列实现的，并且有一个重要变量：<strong>装填因子</strong>。</p><p>装填因子（load factor）为散利表中的元素个数对该表大小的比，</p><p>在处理过程中，如果超过了默认的界限值，就会 <code>rehash</code> 扩大散列表的大小。</p><p>关于源码的具体实现，还有很多值得学习和研究的地方，在以后的学习过程中不断补充。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo的迁移</title>
      <link href="/2022/04/28/Hexo%E7%9A%84%E8%BF%81%E7%A7%BB/"/>
      <url>/2022/04/28/Hexo%E7%9A%84%E8%BF%81%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p>因为更换了电脑，从 Windows 迁移到了 MacOs，花费了将近两天的时间，才完整地将博客迁移。</p><p>在这个过程中，主要遇到了以下几个问题：</p><ol><li>如何将博客的所有资源以及配置迁移到新电脑：通过 <code>Git</code> 解决；</li><li>图片无法正常显示：通过修改 <code>node_modules</code> 下的包文件；</li><li>生成日期和修改日期被全部重置：通过添加头描述。</li></ol><p>上述问题，最开始我以为是 <code>OS</code> 不同导致的问题，后来通过深入，发现并不是其造成的，</p><p>而是一些基础的操作，以及对于 Hexo 部署和生成以及一些工具的熟练使用。</p><p>也借着这次经历，加深了对于 <code>Git</code> 的理解，也明白了 Hexo 的部署方式。</p><p><code>Git</code> 操作可以参考资源：<a href="http://iissnan.com/progit/">http://iissnan.com/progit/</a></p><p>关于 MacOs 的 <code>Git</code> 安装按照官网的指引操作即可，配置个人信息和密钥，可以参考其他博客。</p><h3 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h3><h4 id="1-如何迁移博客"><a href="#1-如何迁移博客" class="headerlink" title="1. 如何迁移博客"></a>1. 如何迁移博客</h4><p>因为我的 <code>Hexo</code> 博客是部署在 <code>GitHub</code> 上的，所以可以采用 <code>branch</code> 的方式，去分离资源和渲染。</p><p>在理解这个之前，先来大概了解一下 <code>Hexo</code> 的工作原理和其相关文件的作用，</p><p><code>Hexo</code> 本身是一个静态博客，在本地修改增加博客的时候，并不是将所有东西都部署在远端，</p><p>而是在本地渲染资源后，生成 <code>.deploy_git</code> 文件部署在 <code>Github</code> 上，而后渲染，显示站点内容。</p><p>因此资源和渲染结果是分离的，相当于资源在本地，而 <code>deploy</code> 的内容在 <code>GitHub</code> 上，</p><p>因此可以通过 <code>Git</code> 的 <code>branch</code> 功能将本地的资源也上传到远端，从而可以拉取在新电脑。</p><p><img src="%E6%96%87%E4%BB%B6%E4%BD%9C%E7%94%A8.png"></p><p>如上图所示，在原有的 <code>master</code> 分支上，新建 <code>source</code> 分支，用来存储资源文件。</p><p><strong>具体操作流程如下：</strong></p><ol><li><p>克隆远程仓库的项目：<code>git clone remote_url</code></p></li><li><p>和远程仓库建立关联：<code>git remote add origin remote_url</code></p></li><li><p>查看所有分支：<code>git branch -a</code> 和 <code>git branch -r</code></p></li><li><p>本地创建新的分支：<code>git checkout -b source</code></p></li><li><p>将新分支推送至 <code>GitHub</code>：<code>git push origin source</code></p></li><li><p>查看创建分支的结果：<code>git branch -r</code></p></li><li><p>在 <code>GitHub</code> 上更改博客仓库的默认分支为 <code>source</code></p></li><li><p>删除原仓库内文件，而后将资源文件复制到本地项目，注意 <code>.git</code> 文件</p></li><li><p>确保 <code>.gitignore</code> 文件为以下内容：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.DS_Store</span></span><br><span class="line">Thumbs<span class="number">.</span><span class="built_in">db</span></span><br><span class="line"><span class="built_in">db</span><span class="number">.</span>json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line"><span class="meta">public</span>/</span><br><span class="line"><span class="meta">.deploy</span>*/</span><br></pre></td></tr></table></figure></li><li><p>执行以下命令：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span> .</span><br><span class="line">git <span class="keyword">commit</span> -m <span class="string">&#x27;hexo source post&#x27;</span></span><br><span class="line">git push origin souce</span><br></pre></td></tr></table></figure></li><li><p>在新电脑中，参考我的其他相关 <code>Hexo</code> 博客配置，然后 <code>clone</code> 即可</p></li></ol><h4 id="2-图片显示问题"><a href="#2-图片显示问题" class="headerlink" title="2. 图片显示问题"></a>2. 图片显示问题</h4><p>在最开始的搭建中，图片并未采用图床或者上传到 <code>GitHub</code> ，而是 <code>![]()</code> 本地的形式，</p><p>所以需要安装 <code>npm install hexo-asset-image </code>，可以参考我的其他相关 Hexo 博客配置，</p><p>当然并不需要重新安装，因为 <code>package.json</code> 文件已经包含了相关的依赖，但是需要改代码，</p><p>打开 <code>/node_modules/hexo-asset-image/index.js</code>，将内容更换为如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.config;</span><br><span class="line">  <span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">        <span class="keyword">var</span> link = data.permalink;</span><br><span class="line">    <span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">       <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line">    <span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">        <span class="attr">ignoreWhitespace</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">xmlMode</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">lowerCaseTags</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">decodeEntities</span>: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">            <span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line">            <span class="keyword">var</span> src = $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">               !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">              <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">              <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">              <span class="keyword">var</span> linkArray = link.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">              <span class="keyword">var</span> srcArray = src.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">              <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">                srcArray.shift();</span><br><span class="line">              src = srcArray.join(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">              $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>, config.root + link + src);</span><br><span class="line">              <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="built_in">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="3-日期修改问题"><a href="#3-日期修改问题" class="headerlink" title="3. 日期修改问题"></a>3. 日期修改问题</h4><p>因为重新拉取和上传，导致博客的生成日期和修改日期都变成了一天，也就是拉取的这天，</p><p>经过查阅资料和不断尝试以及思考，找到了原因：文件的创建和修改日期即为此日期。</p><p><img src="%E6%97%A5%E6%9C%9F.png"></p><p>来到主题文件中 <code>themes/next/layout/_macro/post.swig</code>，可以看到如下代码：</p><p><img src="%E6%97%A5%E6%9C%9F%E4%BB%A3%E7%A0%81.png"></p><p>大概意思是，每个 <code>post</code> 也就是文章，有上传日期和修改日期，即 <code>date</code> 和 <code>updated</code>，</p><p>如果二者相同，那么只显示生成日期，如果不相同额外显示更改日期。</p><p>有了上面两个要素，就明白了如何去修改回原本的日期，但是以前并未在头部添加 <code>date</code>，</p><p>并且更改文件本身的生成日期是麻烦的，最开始考虑的是写一个脚本，批处理一下所有文件，</p><p>在原电脑上为每一个文章额外添加生成和修改日期，因为刚好最近在学习 <code>shell</code> 相关内容，</p><p>但是发现比较困难，并且因为以前写博客经验较少，很多内容和排版都有问题，</p><p>因此借着这个机会，将以前的内容进行精简和必要的重新排版，就采用最原始的方法，</p><p>在每个文件的 <code>YAML</code> 头部信息中添加 <code>date</code> 和 <code>updated</code> 内容，也希望以后注意此问题。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP</title>
      <link href="/2022/04/25/KMP/"/>
      <url>/2022/04/25/KMP/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><blockquote><p>给定一个模式串 S，以及一个模板串 P，所有字符串中只包含大小写英文字母以及阿拉伯数字。</p><p>模板串 P 在模式串 S 中多次作为子串出现，求出模板串 P 在模式串 S 中所有出现的位置的起始下标。</p></blockquote><p>字符串匹配算法，比较容易想到的是模拟匹配，一般会出现 <code>TLE</code>，因此不可取。</p><p>非常出名的 <code>KMP</code> 算法，一直认为比较难，经过学习，其实发现并不是特别难，只不过是纸老虎。</p><p>在学习 <code>KMP</code> 之前，也需要回顾是如何暴力匹配的，才能明白为何 <code>KMP</code> 缩短了时间复杂度。</p><p><strong>当然参考一些变量的定义，将 <code>s</code> 重名为 <code>haystack</code>，<code>p</code> 重名为 <code>needle</code>，也就是大海捞针。</strong></p><p>类似题目可以参考：<a href="https://leetcode-cn.com/problems/implement-strstr/submissions/">https://leetcode-cn.com/problems/implement-strstr/submissions/</a></p><h3 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h3><h4 id="暴力匹配"><a href="#暴力匹配" class="headerlink" title="暴力匹配"></a>暴力匹配</h4><p>遍历 <code>haystack</code>，匹配 <code>needle</code>，如果当前位置不满足，就移动至下一位，直至匹配成功。</p><p><img src="%E6%9A%B4%E5%8A%9B.png"></p><p>不难看出时间复杂度很高，那么造成其原因就在于，很多匹配其实是无效的，并且重复匹配。</p><p>举个例子：<code>abcbdefbcbdc</code> 和 <code>bcbd</code>，在暴力模拟匹配的过程中，可以看到以下两个问题：</p><ol><li>其实很多位置最开始都不满足，但还是遍历了；</li><li>每次遍历匹配的过程中，都对 <code>bcbd</code> 重头匹配。</li></ol><p>而 <code>KMP</code> 算法解决了这两个问题，当然这是我个人的理解，不得不说 <code>KMP</code> 真的精妙。</p><h4 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h4><p><strong>原论文地址：<a href="https://www.cs.jhu.edu/~misha/ReadingSeminar/Papers/Knuth77.pdf">Knuth77.pdf (jhu.edu)</a></strong></p><p><code>KMP</code> 的核心就在于其构造了一个 <code>next</code> 数组，其作用是返回每个位置的最长对应前缀。</p><p>个人觉得先理解这个数组，其实便于更好地去理解这个算法，如果先去理解算法，容易晕，</p><p>就好比学习树状数组的时候，先学习 <code>lowbit</code> 函数，对于后续整个处理都有益处。</p><p>举个例子说明 <code>next</code> 数组，如下图所示：</p><p><img src="next.png"></p><p>接下来介绍 <code>KMP</code> 是如何进行匹配的，还是回到 <code>needle</code> 和 <code>haystack</code> 中，</p><p>与暴力匹配不同的是，当在 <code>haystack</code> 中发现此时不匹配时，不是重新开始，</p><p>因为从前面已经知道，在匹配失败之前都是匹配成功的，不妨设最后成功的位置为 <code>j</code>，</p><p>那么下次就从 <code>next[j]</code> 开始进行匹配，重复此过程，直至相等。</p><p><strong><em>（这里就不画图模拟了，网上有很多，主要是记录自己的理解）</em></strong></p><p>这一步就避免了暴力所带来的时间开销，从而优化了时间复杂度。</p><p>那么如何构造 <code>next</code> 数组呢？其实和匹配过程是非常相似的，唯一不同的就在于最后的判断，</p><p>匹配过程中是寻找完全相等的情况，而构造 <code>next</code> 只是寻找前缀的过程，需要理解。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">kmp</span><span class="params">(String s, String p)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符串转为数组便于处理</span></span><br><span class="line">    <span class="keyword">char</span>[] needle = s.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] haystack = p.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> n = needle.length;</span><br><span class="line">    <span class="keyword">int</span> m = haystack.length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 避免增加数组的开销 从 -1 开始</span></span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建 next 数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = -<span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; needle[i] != needle[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needle[i] == needle[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// kmp 查询</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = -<span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; haystack[i] != needle[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (haystack[i] == needle[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果匹配成功</span></span><br><span class="line">        <span class="keyword">if</span> (j == n - <span class="number">1</span>) &#123;</span><br><span class="line">            bw.write(i - n + <span class="number">1</span> + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bw.flush();</span><br><span class="line">    bw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型机制和实现</title>
      <link href="/2022/04/21/%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/04/21/%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6%E5%92%8C%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p>最近在重新学习数据结构，因为以前总是停留在概念，只知道如何使用，但不清楚具体的实现机制，</p><p>于是想着借此机会阅读 <code>JDK</code> 源码，另外尝试自己实现一个简单的 <code>JDK</code> ，巩固基础并且深入学习。</p><p>学习过程中也捡起了放置了很久的一本书《数据结构与算法分析 Java 版》，因为以前基础比较薄弱，</p><p>并且缺少练习，导致对书中很多概念模糊不清，花费将近半天时间，重新阅读了<strong>泛型</strong>这一小节，</p><p>纸上得来终觉浅，绝知此事要躬行，因此在阅读过程中，也将一些地方，用代码实现了一遍。</p><p><em>（代码部分链接如下：<a href="https://github.com/Eminem-x/Learning/tree/main/Java/GenericMechanism/src/com/yuanhao">泛型机制和实现代码</a>)</em></p><p>重新学习，收获还是很多的，站在和以前不同的角度去学习，以前书上的一些笔记也得到了解答，</p><p>接下来的内容按照这本书的内容顺序，加上一些个人理解和代码实现来叙述，会忽略一些基础。</p><h3 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h3><h4 id="Object-接口-泛型特性"><a href="#Object-接口-泛型特性" class="headerlink" title="Object + 接口 / 泛型特性"></a>Object + 接口 / 泛型特性</h4><ol><li><p><strong>Object + 接口类型表示泛型</strong></p><p><code>Java</code> 中的基本思想就是可以通过使用像 <code>Object</code> 类这样的超类来实现泛型类，</p><p>不过只有在使用 <code>Object</code> 类中已有的方法能够表示所执行操作的时候，才能采用这种方式，</p><p>因此，可以使用接口类型表示泛型，比如 <code>Comparable</code>，为 <code>Object</code> 提供了一种能力比较对象大小。</p><p>那么不妨简单的构建以上情况，<code>MyInteger1</code> 类实现 <code>Comparable1</code> 接口，并且附上一个测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInteger1</span> <span class="keyword">implements</span> <span class="title">Comparable1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        MyInteger1 t = (MyInteger1) o;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.val - t.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testObjectAndAnyType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 利用 Object 超类实现泛型</span></span><br><span class="line">    MyInteger1 myInteger = <span class="keyword">new</span> MyInteger1();</span><br><span class="line">    MyInteger1 otherInteger = <span class="keyword">new</span> MyInteger1();</span><br><span class="line">    Shape shape1 = <span class="keyword">new</span> Shape();</span><br><span class="line">    System.out.println(myInteger.compareTo(otherInteger));</span><br><span class="line">    <span class="comment">// 运行时会抛出 ClassCastException</span></span><br><span class="line">    System.out.println(myInteger.compareTo(shape1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下图：</p><p><img src="object.png"></p></li><li><p><strong>泛型特性实现泛型</strong></p><p><code>Java 5</code> 支持泛型类，当指定一个泛型类时，类的声明则包含一个或多个类型参数，位于 <code>&lt;&gt;</code> 内，</p><p>与 <code>Object</code> 类不同的是，如果在给定一个参数类型以后，尝试传递其他参数，那么就会产生编译错误。</p><p>仍然简单构造上述情况，<code>MyInteger2</code> 类实现 <code>Comparable2</code> 接口，并附上一个测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInteger2</span> <span class="keyword">implements</span> <span class="title">Comparable2</span>&lt;<span class="title">MyInteger2</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(MyInteger2 o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.val - o.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testObjectAndAnyType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 利用泛型特性实现泛型</span></span><br><span class="line">    com.yuanhao.MyInteger2 integer2 = <span class="keyword">new</span> com.yuanhao.MyInteger2();</span><br><span class="line">    com.yuanhao.MyInteger2 otherInteger2 = <span class="keyword">new</span> com.yuanhao.MyInteger2();</span><br><span class="line">    com.yuanhao.Shape shape2 = <span class="keyword">new</span> com.yuanhao.Shape();</span><br><span class="line">    System.out.println(integer2.compareTo(otherInteger2));</span><br><span class="line">    <span class="comment">// 传递参数时产生一个编译错误</span></span><br><span class="line">    System.out.println(integer2.compareTo(shape2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译结果如下图：</p><p><img src="T.png"></p></li><li><p><strong>对比结果</strong></p><p>不难看出，利用 <code>Java 5</code> 的泛型特性去实现泛型构件，</p><p>避免了以前的运行时错误 <code>ClassCastException</code>，</p><p>通过使类变成泛型类，将运行时才能报告的许多错误，转变为现如今编译时的错误。</p></li></ol><h4 id="数组兼容性-通配符"><a href="#数组兼容性-通配符" class="headerlink" title="数组兼容性 / 通配符"></a>数组兼容性 / 通配符</h4><ol><li><p><strong>协变数组类型</strong></p><p>在介绍这个概念之前，不妨先看一段代码（可以先忽略注释），思考能否通过编译以及运行：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person[] arr = <span class="keyword">new</span> <span class="type">Employee</span>[<span class="number">5</span>]; <span class="comment">// 编译: arrays are compatible</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="type">Student</span>(...);<span class="comment">// 编译: Student IS-A Person</span></span><br></pre></td></tr></table></figure><p>上述代码中，<code>Employee</code> 和 <code>Student</code> 继承自 <code>Person</code>，先说结果：<strong>可编译但会运行错误。</strong></p><p>因为 <code>Employee IS-A Person</code>，因此 <code>Employee[] IS-A Person[]</code>，这似乎是没问题的，</p><p>但是 <code>Student IS-A Person</code>，而 <code>Student IS-NOT-A Employee</code>，这就会产生类型混乱。</p><p><strong>运行时系统不会抛出 <code>ClassCastException</code>，因为不存在类型转换。</strong></p><p>避免这种情况最容易的办法是指定这些数组不是类型兼容的，可是 <code>Java</code> 中数组是兼容的，</p><p>称为<strong>协变数组类型（covariant array type），</strong>其实从多态的角度挺容易理解这个问题的。</p><p>第二段代码中，编译时没有进行动态绑定，不清楚是 <code>Person</code> 还是 <code>Employee</code>，所以运行出错，</p><p><strong>如果将一个不兼容的类型插入到数组中，那么虚拟机将抛出 <code>ArrayStoreException</code> 异常。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Shape[] arr = <span class="keyword">new</span> Square[<span class="number">5</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="keyword">new</span> Circle();</span><br></pre></td></tr></table></figure><p><img src="ASE.PNG"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = <span class="keyword">new</span> Square[] &#123;<span class="keyword">new</span> Circle()&#125;; <span class="comment">// Incompatible types. Found: &#x27;Circle&#x27;, required: &#x27;Square&#x27;</span></span><br></pre></td></tr></table></figure><p>如果再深入思考一点，可以发现这样声明时，就会出现编译报错，恰恰验证了从多态角度考虑的正确性。</p></li><li><p><strong>带有限制的通配符</strong></p><p>因为使用泛型的全部原因就在于产生编译器错误而不是运行时异常，所以泛型集合是不可协变的，</p><p>因此不能传递类型不同的参数，但是这样一来，就使得代码失去了灵活性，对用户而言不太友好，</p><p><strong>因此，<code>Java 5 </code> 用通配符（wildcard） 来弥补这个不足，其用来表示参数类型的子类或超类。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCovariant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Shape&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Square&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    System.out.println(totalArea(list1));</span><br><span class="line">    System.out.println(totalArea(list2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Collection&lt;Shape&gt; 不加通配符就会产生编译错误</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">totalArea</span><span class="params">(Collection&lt;? extends Shape&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Shape s : arr) &#123;</span><br><span class="line">        total += s.test();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="类型限界"><a href="#类型限界" class="headerlink" title="类型限界"></a>类型限界</h4><p>类型限界的概念其实还是蛮好理解的，就是限制参数类型，但是比较难理解的地方是改进的做法。</p><p><code>findMax</code> 是一个泛型方法，需要对参数执行 <code>compareTo</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不合法 编译出错 不能运行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">findMax</span><span class="params">(T[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>].compareTo(arr[<span class="number">1</span>]) == <span class="number">0</span> ? arr[<span class="number">0</span>] : arr[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不对 <code>&lt;T&gt;</code> 添加类型限制，编译器不能证明 <code>arr[0]</code> 对 <code>compareTo</code> 方法调用是合法的，所以编译错误。</p><p><strong>因此需要类型限界（type bound）解决这个问题，类型限界在尖括号内指定，指定参数必须具有的性质。</strong></p><p>因此可以对代码进行修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以运行 但会 warning</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">T <span class="title">findMax</span><span class="params">(T[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>].compareTo(arr[<span class="number">1</span>]) == <span class="number">0</span> ? arr[<span class="number">0</span>] : arr[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法看起来很自然，但是在 <code>IDEA</code> 编译器下，会报出 <code>warning</code>，但不影响运行，</p><p>可以参考这篇回答：<a href="https://stackoverflow.com/questions/4830400/java-unchecked-call-to-comparetot-as-a-member-of-the-raw-type-java-lang-compa">关于 <code>&lt;T extends Comparable&gt;</code> warning</a>，其中有一个回答：</p><blockquote><blockquote><p>In essence, this warning says that <code>Comparable</code> object can’t be compared to arbitrary objects. <code>Comparable&lt;T&gt;</code> is a generic interface, where type parameter <code>T</code> specifies the type of the object this object can be compared to.</p><p>So, in order to use <code>Comparable&lt;T&gt;</code> correctly, you need to make your sorted list generic, to express a constraint that your list stores objects that can be compared to each other, something like this:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortedList</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;? <span class="title">super</span> <span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T obj)</span> </span>&#123; ... &#125;</span><br><span class="line">   ...</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote><p>这个回答和书上后续的补充是对应的，那么接着修改上述代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// warning 消失</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function">T <span class="title">findMax</span><span class="params">(T[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>].compareTo(arr[<span class="number">1</span>]) == <span class="number">0</span> ? arr[<span class="number">0</span>] : arr[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>那么为何还会出现 <code>&lt;T extends Comparable&lt;? super T&gt;&gt;</code> 这种形式的类型界限呢？</strong></p><p>为了看清楚这个问题，编写一段代码：</p><p>( <code>Square</code> 是 <code>Shape</code> 的子类，并且 <code>Shape</code> 实现 <code>Comparable&lt;Shape&gt;</code>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 这两段代码都可以通过编译并且正常运行</span></span><br><span class="line">    Shape[] arr1 = <span class="keyword">new</span> Square[<span class="number">5</span>];</span><br><span class="line">    arr1[<span class="number">0</span>] = <span class="keyword">new</span> Square();</span><br><span class="line">    arr1[<span class="number">1</span>] = <span class="keyword">new</span> Square();</span><br><span class="line">    System.out.println(findMax(arr1));</span><br><span class="line"></span><br><span class="line">    Square[] arr2 = <span class="keyword">new</span> Square[<span class="number">5</span>];</span><br><span class="line">    arr2[<span class="number">0</span>] = <span class="keyword">new</span> Square();</span><br><span class="line">    arr2[<span class="number">1</span>] = <span class="keyword">new</span> Square();</span><br><span class="line">    System.out.println(findMax(arr2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function">T <span class="title">findMax</span><span class="params">(T[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里可以打印类, 确认无误</span></span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>].compareTo(arr[<span class="number">1</span>]) == <span class="number">0</span> ? arr[<span class="number">0</span>] : arr[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>此时，我们所知道的只是 <code>Square</code> 实现 <code>Comparable&lt;Shape&gt;</code>，</strong></p><p><strong>于是 <code>Square IS-A Comparable&lt;Shape&gt;</code>，</strong>这在前面也解释过，</p><p><strong>但是 <code>Square IS-NOT-A Comparable&lt;Square&gt;</code>，这看起来合情合理，可放到代码里确实费解的。 </strong></p><p><strong>因此对类型界限再加修饰：<code>&lt;T extends Comparable&lt;? super T&gt;&gt;</code></strong>。</p><h4 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h4><p>泛型在很大程度上是 <code>Java</code> 语言中的成分而不是虚拟机中的结构。</p><p>泛型类可以由编译器通过所谓的<strong>类型擦除（type erase）</strong>过程而转变成非泛型类，</p><p>这样，编译器就生成一种与泛型类同名的<strong>原始类（raw object）</strong>，但是参数类型都被删去了。</p><p>类型变量由它们的类型界限来代替，当一个具有擦除返回类型的泛型方法被调用的时，一些特性被自动地插入。</p><p>类型擦除的一个重要结论是，所生成的代码与程序员在泛型之前所写的代码并没有太多的差异，</p><p>而且事实上运行的也并不快，优点在于，程序员不比类型转换，交给编译器类型检验。</p><p>更深层的细节参考博客：<a href="https://www.cnblogs.com/wuqinglong/p/9456193.html">https://www.cnblogs.com/wuqinglong/p/9456193.html</a></p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>除上述描述的一些概念以外，还有一些细枝末节，就不再赘述，比如泛型的使用或者方式等等，</p><p>当然也是重要的部分，不过这部分就不是细节方面的问题了，但是还是补充一点，关于 <code>static</code> 泛型。</p><p>个人感觉 <code>static</code> 所带来的问题，一律带到它是静态的，是类的属性而不是成员，就往往自洽了，</p><p>因为类的属性先加载而成员需要运行时，所以从这个角度分析问题，就不需要死记硬背了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树状数组</title>
      <link href="/2022/04/12/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
      <url>/2022/04/12/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p>树状数组用起来很简单，但是比较难理解，不过网上资源比较多，在此加上自身理解整合一下。</p><p><em>（具体参考的博客文章附在下文中）</em></p><h4 id="起源与介绍"><a href="#起源与介绍" class="headerlink" title="起源与介绍"></a>起源与介绍</h4><p>树状数组或二元索引树（Binary Indexed Tree），又以其发明者命为 Fenwick 树，</p><p>初衷是用来解决数据压缩里的累计频率（Cumulative Frequency）的计算问题，</p><p>现多用于高效计算数列的前缀和、区间和（下面附有一些相关题目），</p><p>时间复杂度为 O(logn)，二进制在算法中的使用，有时使得时间复杂度降到与 <code>n</code> 的二进制中的 <code>1</code> 相关。</p><p>具体内容参考 paper： <a href="https://static.aminer.org/pdf/PDF/001/073/976/a_new_data_structure_for_cumulative_frequency_tables.pdf">A New Data Structure for Cumulative Frequency Tables (aminer.org)</a></p><h4 id="使用情景"><a href="#使用情景" class="headerlink" title="使用情景"></a>使用情景</h4><p>可以解决大部分基于区间上的更新以及求和问题</p><p>相关题目：</p><p><a href="https://leetcode-cn.com/problems/range-sum-query-mutable/">307. 区域和检索 - 数组可修改 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p><a href="https://leetcode-cn.com/problems/range-sum-query-2d-mutable/">308. 二维区域和检索 - 可变 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>下面几题实质为偏序问题，树状数组是针对偏序问题的常用解法之一：</p><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51. 数组中的逆序对 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p><a href="https://leetcode-cn.com/problems/range-sum-query-2d-mutable/">308. 二维区域和检索 - 可变 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p><a href="https://leetcode-cn.com/problems/reverse-pairs/">493. 翻转对 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">315. 计算右侧小于当前元素的个数 - 力扣（LeetCode） (leetcode-cn.com)</a></p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>修改和查询的时间复杂度都是 O(logn)，而且相比线段树系数要少很多，比传统数组要快，而且容易写。</p><p>但是遇到复杂的区间问题还是不能解决，功能还是有限。</p><h4 id="参考博客："><a href="#参考博客：" class="headerlink" title="参考博客："></a>参考博客：</h4><p>推荐这一篇：<a href="https://blog.csdn.net/flushhip/article/details/79165701">(30条消息) 树状数组简单易懂的详解_FlushHip的博客-CSDN博客_树状数组</a></p><p>剩下两篇辅助理解：</p><p><a href="https://www.cnblogs.com/xenny/p/9739600.html">树状数组详解 - Xenny - 博客园 (cnblogs.com)</a></p><p><a href="https://www.cnblogs.com/Last--Whisper/p/13823614.html#bit-%E7%9A%84%E5%8E%9F%E7%90%86">树状数组（BIT）—— 一篇就够了 - Last_Whisper - 博客园 (cnblogs.com)</a></p><p>相关题目以及其他方法：</p><p><a href="https://leetcode-cn.com/circle/article/P92uug/">前缀和、差分、树状数组、块状数组 - 力扣（LeetCode） (leetcode-cn.com)</a></p><hr><h3 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h3><h4 id="lowbit-函数"><a href="#lowbit-函数" class="headerlink" title="lowbit 函数"></a>lowbit 函数</h4><p>树状数组需要用到的一个 function，作用是求某一个数的二进制表示中最低的一位 <code>1</code>。</p><p>举个例子，<code>x = 6</code>，它的二进制为 <code>110</code>，那么 <code>lowbit(x) </code>就返回<code>2</code>，因为最后一位 <code>1</code> 表示 <code>2</code>。</p><p><strong>具体的实现有两种写法：<code>x - (x &amp; (x - 1))</code> 或者 <code>x &amp; -x;</code>，</strong>根据数学知识简单论证即可。</p><h4 id="树状数组的思想"><a href="#树状数组的思想" class="headerlink" title="树状数组的思想"></a>树状数组的思想</h4><p>按照 Peter M.Fenwick 的说法，BIT 的产生源自整数与二进制的类比。</p><blockquote><p>Each integer can be represented as sum of powers of two. In the same way, cumulative frequency can be represented as sum of sets of subfrequencies. In our case, each set contains some successive number of non-overlapping frequencies.</p></blockquote><p>实际上，BIT 也是采用类似的想法，将序列和类比为整数的二进制拆分，举个例子：</p><p>一个数 <code>n = 6 </code>，它的二进制为 <code>110</code>，我们将其表示成累加的形式：<code>110 = 100 + 10</code>，</p><p>这种拆分的形式恰好可以借助前文提到的 <code>lowbit</code> 方法，那么如何映射到序列和呢？</p><br><p>假设序列以数组 <code>a</code> 表示，那么前六项的前缀和为： <code>sum[6] = a1 + a2 + a3 + a4 + a5 + a6</code>；</p><p>按照上述二进制拆分的形式去拆分可以得到：<code>sum[6] = (a1 + a2 + a3 + a4) + (a5 + a6)</code>；</p><br><p><strong>那么树状数组是怎么处理的呢？</strong>其定义了一个数组 <code>tree</code>，</p><p><code>tree[i]</code> 表示从第 <code>i</code> 个元素向前数 <code>lowbit(i)</code> 个元素，这一段的和。</p><p>那么上述的前缀和可以按照这种形式表示成：<code>sum[6] = tree[4] + tree[6]</code>。</p><p>按照这种形式，我们可以表示出来任意区间的前缀和，但是该如何更新呢？</p><br><p>在介绍如何更新之前，先结合树状数组的经典图，来具体了解其相关性质。</p><p><img src="%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84.png"></p><p>（简要陈述图片含义，横坐标表示具体的序列，纵坐标表示层数，矩形表示 <code>tree[i]</code> 包含元素）</p><p><strong>由这张图，可以得到树状数组的以下性质：</strong></p><ul><li><p>后缀和的长度是2的幂；</p></li><li><p>上一层后缀和的长度是下一层后缀和长度的两倍；</p></li><li><p>下一层后缀和只要补上自己后缀和的长度就可以得到上面层的后缀和(图中的虚框框)，</p><p>注意，是上面的后缀和，而不是上一层的后缀和，这个性质就是更新操作的依据；</p></li><li><p>最后一位 1 右边有多少个 0 (可以用 <code>log2(lowbit(x)</code> )，</p><p>就表示这一层有多少个直系子层(子层的意思就是这一层的和包含下面某一层的和)。</p></li></ul><br><p><strong>结合求区间和的方式以及性质，可以推出，更新时只要更新修改这个点会影响到的 <code>tree</code> 即可。</strong></p><p>那么如何得到影响的 <code>tree</code>，结合性质三显而易见，<code>x += lowbit(x)</code> 即可。</p><br><p><strong>既然已经陈述了其方法和思想，那么回到名字上，为什么命名为树状数组呢？</strong></p><p>让我们回到最开始介绍此数据结构的 paper 里，可以看到下面两张图：</p><p> <img src="paper1.png"></p><p> <img src="paper2.png"></p><p>由这两张图可以看到，数组转化为树形结构，只不过省略了一些结点，有兴趣可以钻研一下。</p><h4 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BIT</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BIT</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] tree;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BIT</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="keyword">int</span>[length + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt; tree.length; i += lowbit(i)) &#123;</span><br><span class="line">            tree[i] += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            sum += tree[x];</span><br><span class="line">            x -= lowbit(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 树状数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闫氏分析法</title>
      <link href="/2022/04/06/%E9%97%AB%E6%B0%8F%E5%88%86%E6%9E%90%E6%B3%95/"/>
      <url>/2022/04/06/%E9%97%AB%E6%B0%8F%E5%88%86%E6%9E%90%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span><escape></p><h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p>此方法由闫学灿推出，链接：<a href="https://www.bilibili.com/video/BV1X741127ZM?spm_id_from=333.337.search-card.all.click">闫氏DP分析法，从此再也不怕DP问题！_哔哩哔哩_bilibili</a> 观看学习。</p><p>为 dp 问题提供了可供按照惯例的方式去解决，采用集合划分的思想，</p><p>但是需要大量的练习和总结，才能去快速解决此类问题，此类问题也有很多变形，</p><p>包括：背包问题、线性DP、区间DP、计数类DP、数位统计DP、状态压缩DP、树形DP等。</p><p><img src="%E6%A6%82%E8%BF%B0.png"></p><p>主要思路：</p><ol><li>问题一般是求有限集合中的最优集合；</li><li>因此化零为整，抽象出状态表示，包括集合和属性，这一步需要大量的练习；</li><li>随后化整为零，寻找集合之间的最后一个不同点，求出状态转移方程；</li><li>不同类型的 dp 问题都可以以此来求解，但是细节有所不同；</li></ol><p>也是听了这节视频以及整个 AcWing 平台题目的紧凑性，尤其是对 LCS 的讲解，</p><p>使得我豁然开朗，也让我决定在此平台不断学习算法。</p><hr><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h4><p>问题详细描述：<a href="https://www.acwing.com/problem/content/2/">2. 01背包问题 - AcWing题库</a></p><p>按照上述思路进行分析：</p><p><img src="01%E8%83%8C%E5%8C%85.png"></p><p>代码如下（未优化）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.math.*; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">int</span> N = in.nextInt();</span><br><span class="line">            <span class="keyword">int</span> V = in.nextInt();</span><br><span class="line">            <span class="keyword">int</span>[][] objects = <span class="keyword">new</span> <span class="keyword">int</span>[N][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                objects[i][<span class="number">0</span>] = in.nextInt();</span><br><span class="line">                objects[i][<span class="number">1</span>] = in.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println((<span class="keyword">new</span> Main()).solution(N, V, objects));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> V, <span class="keyword">int</span>[][] objects)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][V + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= V; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = objects[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> w = objects[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (j - v &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - v] + w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N][V];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h4><p>问题详细描述：<a href="https://www.acwing.com/problem/content/3/">3. 完全背包问题 - AcWing题库</a></p><p>按照上述思路进行分析：</p><p><img src="%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.png"></p><p>代码如下（未优化）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.math.*; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">int</span> N = in.nextInt();</span><br><span class="line">            <span class="keyword">int</span> V = in.nextInt();</span><br><span class="line">            <span class="keyword">int</span>[][] objects = <span class="keyword">new</span> <span class="keyword">int</span>[N][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                objects[i][<span class="number">0</span>] = in.nextInt();</span><br><span class="line">                objects[i][<span class="number">1</span>] = in.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println((<span class="keyword">new</span> Main()).solution(N, V, objects));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> V, <span class="keyword">int</span>[][] objects)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][V + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= V; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = objects[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> w = objects[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (j - k * v &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - k * v] + w * k);</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N][V];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h4><p>问题详细描述：<a href="https://www.acwing.com/problem/content/3/"><a href="https://www.acwing.com/problem/content/284/">282. 石子合并 - AcWing题库</a></a></p><p><strong>该题是区间DP</strong>，依然按照上述思路进行分析：</p><p><img src="%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6.png"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.math.*; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">int</span> N = in.nextInt();</span><br><span class="line">            <span class="keyword">int</span>[] objects = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                objects[i] = in.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println((<span class="keyword">new</span> Main()).solution(N, objects));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span>[] objects)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] sum = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">            sum[i + <span class="number">1</span>] = sum[i] + objects[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][N + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= N; len++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= N; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = Integer.MAX_VALUE; </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; k++) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k + <span class="number">1</span>][j] + sum[j] - sum[i - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h4><p>问题详细描述：<a href="https://www.acwing.com/problem/content/3/"><a href="https://www.acwing.com/problem/content/899/">897. 最长公共子序列 - AcWing题库</a></a></p><p>按照上述思路进行分析：</p><p><img src="%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.png"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.math.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = in.nextInt();</span><br><span class="line">            <span class="keyword">int</span> m = in.nextInt();</span><br><span class="line">            String s1 = in.next();</span><br><span class="line">            String s2 = in.next();</span><br><span class="line">            System.out.println(<span class="keyword">new</span> Main().getLcs(s1, s2));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLcs</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s1.length();</span><br><span class="line">        <span class="keyword">int</span> m = s2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (s1.charAt(i - <span class="number">1</span>) == s2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀树</title>
      <link href="/2022/03/24/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
      <url>/2022/03/24/%E5%AD%97%E5%85%B8%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span><escape></p><h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p><strong><code>Trie</code> （发音类似 try）前缀树</strong>，一种树形数据结构，用于高效地存储和检索字符串数据集中的键，</p><p>有相当多地应用情景：自动补全和拼写检查，又称为<strong>字典树</strong>，实质上是 <strong>N叉树</strong> 的一种特殊形式。</p><p>相关题目推荐：</p><ul><li><p><a href="https://leetcode-cn.com/problems/concatenated-words/">472. 连接词 - 力扣（LeetCode） (leetcode-cn.com)</a></p></li><li><p><a href="https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/">440. 字典序的第K小数字 - 力扣（LeetCode） (leetcode-cn.com)</a></p></li></ul><p>还有一道比较经典的题目：求数组中的最大异或值。</p><hr><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p><strong>结点形式实现代码： </strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Trie[] children;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        children = <span class="keyword">new</span> Trie[<span class="number">26</span>];</span><br><span class="line">        isEnd = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Trie node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = word.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> index = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.children[index] = <span class="keyword">new</span> Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Trie node = searchPrefix(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="keyword">null</span> &amp;&amp; node.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> searchPrefix(prefix) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Trie <span class="title">searchPrefix</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        Trie node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = prefix.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> index = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数组形式实现代码： </strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[][] son = <span class="keyword">new</span> <span class="keyword">int</span>[N][<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (son[p][t] == <span class="number">0</span>) &#123;</span><br><span class="line">                son[p][t] = ++idx;</span><br><span class="line">            &#125;</span><br><span class="line">            p = son[p][t];</span><br><span class="line">        &#125;</span><br><span class="line">        cnt[p]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (son[p][t] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = son[p][t];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>文章开始处的两个链接，前者直接应用到字典树，而后者间接用到字典树，</p><p>都给出了非常巧妙地解法，<strong>尤其是后者如何层序遍历得出字典树结点数目，非常精彩。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RBAC</title>
      <link href="/2022/03/23/RBAC/"/>
      <url>/2022/03/23/RBAC/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p>在最近学习的一个项目中，涉及到了权限管理，其所采用的是主流的 RBAC 模型，</p><p>RBAC(Role-Based Access Control) 基于角色的访问控制，不过根据业务的需要会有不同的变形，</p><p>查阅了一些文章和项目文档，认真总结 RBAC 模型的相关知识，随着学习再不断补充完善。</p><p>在此之前，需要阐述一个问题：<strong>为什么需要权限管理或者说角色权限系统？</strong></p><p>最主要的原因是系统存在不同权限的用户，而根据业务要求的不同，</p><p>每个用户使用的功能、查看的内容是不同的，</p><p>在接下来的示例中，也会体现这一点。</p><hr><h3 id="1-什么是-RBAC-模型"><a href="#1-什么是-RBAC-模型" class="headerlink" title="1. 什么是 RBAC 模型"></a>1. 什么是 RBAC 模型</h3><p>Role-Based Access Control：基于角色的访问控制：</p><p>通过角色关联用户，角色关联权限的访问间接赋予用户权限。</p><p><img src="RBAC-basis.png"></p><p>在该项目中，一个用户拥有若干角色，每一个角色拥有若干个菜单，菜单中存在菜单权限与按钮权限。</p><p><img src="RBAC.png"></p><p>（从定义和业务中可以看出，该模型是灵活的，重要的是权限控制思想）</p><p><strong>那么为什么不直接给用户分配 permission，而是在二者之间增加 Role 这一环节？</strong></p><p>从逻辑上来说，可以直接给用户分配权限，但如果这样，Coupling 就太强了，降低了 Expansibility，</p><p>适合用户数量、角色类型少的平台，不具有 generality 和 expansibility。</p><p>对于通常的系统，如果对批量的 user permission 调整，只需要调整用户关联的 role permission，</p><p>无需对每一个用户都进行权限调整，既大幅提升权限调整的效率，又降低了漏调权限的概率。</p><hr><h3 id="2-RBAC-模型的分类"><a href="#2-RBAC-模型的分类" class="headerlink" title="2. RBAC 模型的分类"></a>2. RBAC 模型的分类</h3><p>RBAC模型可以分为：RBAC0、RBAC1、RBAC2、RBAC3 四种，</p><p>其中 RBAC0 是基础，相当于底层逻辑，另外三种是以其为基础的拓展，</p><p>一般情况下使用 RBAC0 模型就可以满足常规的权限管理系统设计。</p><ol><li><p><strong>RBAC0</strong></p><p>最简单的 User、Role、Permission 模型，而其又包含两种：</p><ul><li>用户和角色是多对一关系</li><li>用户和角色是多对多关系</li></ul></li><li><p><strong>RBAC1</strong></p><p>基于RBAC0，增加子角色，引入继承概念，即子角色可以继承父角色的所有权限。</p><p><img src="RBAC1.png"></p></li></ol><p>   使用场景：如某个业务部门有经理、主管、专员。权限等级依次降低，</p><p>   那么可以先创建完经理角色并配置权限后，主管角色继承经理，并删除某些权限。</p><ol start="3"><li><p><strong>RBAC2</strong></p><p>基于RBAC0，增加对 Role 的 restrictions：角色互斥、基数约束、先决条件角色等。</p><ul><li>角色互斥：同一用户不能分配到一组互斥角色集合中的多个角色</li><li>基数约束：一个角色被分配的用户数量有限</li><li>先决条件角色：若想获得更高的权限，首先需要拥有低一级的权限</li><li>运行时互斥：允许用户有多个角色，但在运行中不可同时激活</li></ul></li><li><p><strong>RBAC3</strong></p><p>统一模型：包含 RABC1 和 RABC2。</p></li></ol><hr><h3 id="3-什么是权限"><a href="#3-什么是权限" class="headerlink" title="3. 什么是权限"></a>3. 什么是权限</h3><p>Permission 可以看作是资源的集合，这里的资源指软件中的所有内容，</p><p>包括模块、菜单、页面、字段、操作功能（增删改查）等等，</p><p><strong>可以将权限分为：页面权限、操作权限和数据权限。</strong></p><ol><li><p><strong>Page Permission</strong></p><p>用户能否获取某些页面的菜单或者进入页面。</p></li><li><p><strong>Operation Permission</strong></p><p>用户凡是在操作系统中的任何动作、交互都是操作权限，如增删改查等。</p></li><li><p><strong>Data Permission</strong></p><p>一般业务管理系统，都有数据私密性的要求：哪些人可以看到哪些数据，不可以看到哪些数据</p></li></ol><p>以该项目为例，测试员 test 和 管理员 admin 登录后所拉取的菜单不同：</p><p><img src="admin.png"></p><p><img src="test.png"></p><p>而如果 test 想要访问其未拉取的菜单，就会报错，显示未拥有权限：</p><p><img src="error.png"></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试感悟</title>
      <link href="/2022/03/15/%E9%9D%A2%E8%AF%95%E6%84%9F%E6%82%9F/"/>
      <url>/2022/03/15/%E9%9D%A2%E8%AF%95%E6%84%9F%E6%82%9F/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p>不知道从哪里开始叙述我的感受，酝酿了片刻，觉得还是从头说起吧，</p><p>2019 年步入大学，那时候的我还什么都不会，对计算机怀有憧憬和热血，</p><p>当时也下定决心要去读研究生，可随着学习和生活的步调越来越大，</p><p>尤其是疫情，可以说疫情改变了我对最开始的计划，疫情那一年，</p><p>我和我女朋友分开了，并且控制力比较差，导致绩点猛滑，大概率无缘保研，</p><p>等到了开学，浑浑噩噩的我，每天只学习一些基础知识，就沉浸在打游戏的生活中，</p><p>但是也是在这漫长的时间里，我明白了我想要的生活是什么样的，于是决定工作，</p><p>破釜沉舟的决心吧，所以当真的做下这个决定后，每天都处于紧绷状态，</p><p>不愿意失败，也不甘心失败，也是在这个时候，我和我女朋友复合了，</p><p>仿佛一切都有了方向，于是我压制自己的惰性去学习，去准备工作，</p><p>2022年，我抱着试试的态度，投了字节的暑期实习后端开发岗位，</p><p>没想到过了笔试也过了三轮面试，写下这篇文章的明天就是 HR 面了，</p><p>但我并没有那种很开心的喜悦，反而更多的是沉默和思考，</p><p>这些就放到余下的篇幅里去描述吧，但我不打算去记录面试的问题，</p><p>而是去记录面试以及面试后带给我的思考。</p><hr><h3 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h3><ol><li><h4 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h4><p>最大的感触就是，自己对一些底层技术，仅仅只是了解，或者说只是记忆，</p><p>因为为了准备面试，不得已加快学习进度，去学习一些项目，走马观花，</p><p>不仅导致基础不牢，甚至项目框架部分也是摇摇欲坠，仅仅会用，</p><p>我感到不安，感到羞愧，所以在这一面结束后，我就下定决心要去花时间巩固，</p><p>重要的不是学了多久，而是如何学习，code less，code smart，</p><p>而最让我懊悔的是，在反问环节，<strong>我问面试官如何看待八股文</strong>，</p><p>尽管才过去不到一星期，但是每天我都饱受因为我的自以为是，</p><p>问出这种愚蠢的问题，不是说如何看待愚蠢，而是用八股文愚蠢，</p><p>在三轮面试结束后，我深刻意识计算机底层知识的重要性，</p><p>如果再给一次机会，我肯定不会再用这种词汇去侮辱真正智慧的结晶。</p></li><li><h4 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h4><p>反问环节我问面试官：是该继续学习 Java 还是说学习 Go，</p><p>面试官给我一个醍醐灌顶的回答，大概意思就是，</p><p><strong>我从来不认为自己是什么工程师，比如 Java 工程师或者 Go 工程师，</strong></p><p><strong>每一种语言更像是一种工具，用在不同的场景，发挥不同的作用，</strong></p><p>不禁让我想起来大一的 C 语言课上，老师曾说过，你不需要会那么多语言，</p><p>但是一定要一门熟悉吃透的语言，结合这次面试我或许明白了，</p><p>你可以熟练运用一种工具，但是也要结合其他工具，才能盖起大厦，</p><p>所以我决定先继续巩固 Java，在入职之前花时间去学习 Go 以及其他。</p></li><li><h4 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h4><p>仍然是反问环节，不得不感慨，面试带给我的影响远超过面试的结果，</p><p>我问面试官有什么需要学习或者改善的地方，<strong>他说记录博客并且最好用英语，</strong></p><p>首先阅读英语文档是程序员的必备技能，同时也是接触新技术的重要途经，</p><p>而过了几天，我和隔壁寝室的大佬请教学习的过程中，他向我推荐了国外公开课，</p><p>我感到无比的兴奋以及对未来有了新的方向，我很感激这些前辈包括同学，</p><p>对技术和学习方面上的无私传授。</p></li></ol><hr><h3 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h3><p>趁着入职前的三四个月的空档期，把底层知识重新巩固一下，</p><p>并且整理一下过往的学习笔记，Later Equals Never，</p><p>先辈们已经把经验和技巧都传授给后辈了，站在巨人的肩膀上学习的我，</p><p>为什么有借口去安然呢？努力尽力的走下去，不因碌碌无为而悔恨就好。</p><hr><h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><p>2022/3/16 完成 HR 面，苦苦等待了很久没有音讯，最后于 2022/4/7 拿到 offer，</p><p>暂定于 5/10 入职，总体来说还是很开心的，因为还是缺少经验加上自身能力不足，</p><p>没有多投几家公司并且知识储备不足，导致有惊无险地拿到这个名额，算是侥幸吧。</p><p>对于这份实习，我更多的是担心和惶恐，感觉自己本身能力其实是达不到这个高度的，</p><p>希望在入职期间能够提升自身实力和见解，对于整个行业和自身发展有一个更深的把握。</p><p>除此之外，和女朋友在结果出来之前 3/24 分开了，心平气和地互相分开了，</p><p>还是前往原先定的城市，做好自己该做的，可以适当停下脚步，但是不能停止前进。</p>]]></content>
      
      
      <categories>
          
          <category> Thinking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thinking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础</title>
      <link href="/2022/01/31/1-Redis%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/01/31/1-Redis%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h3><p>安装：<a href="https://www.runoob.com/redis/redis-install.html">Redis 安装 | 菜鸟教程 (runoob.com)</a></p><p>推荐视频：<a href="https://www.bilibili.com/video/BV1Rv41177Af?from=search&seid=8211878355588508937&spm_id_from=333.337.0.0">【尚硅谷】Redis 6 入门到精通 超详细 教程_哔哩哔哩_bilibili</a></p><p>使用：</p><ol><li><p>打开一个 <strong>cmd</strong> 窗口 使用 cd 命令切换目录到 <strong>C:\redis</strong> 运行</p><p><code>redis-server.exe redis.windows.conf</code></p></li><li><p>另启一个 <strong>cmd</strong> 窗口，原来的不要关闭，不然就无法访问服务端</p><p><code>redis-cli.exe -h 127.0.0.1 -p 6379</code></p></li></ol><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><ol><li><p>默认 <code>16</code> 个数据库，初始默认使用 <code>0</code> 号库</p></li><li><p>统一密码管理，所有库的密码相同</p></li><li><p><code>key</code> 键操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">keys <span class="operator">*</span> 查看当前库所有 key </span><br><span class="line"><span class="keyword">exists</span> key判断是否存在某 key</span><br><span class="line">type key查看某 key 的类型</span><br><span class="line">del key删除指定的 key</span><br><span class="line">unlink key根据 <span class="keyword">value</span> 选择非阻塞删除</span><br><span class="line">expire key为给定 key 设置过期时间</span><br><span class="line">ttl key查看还有多少秒 key 过期<span class="number">-1</span>表示永不,<span class="number">-2</span>表示已过期</span><br><span class="line"><span class="keyword">select</span> key命令切换数据库</span><br><span class="line">dbsize查看当前数据库的 key 数量</span><br><span class="line">flushdb清空当前数据库</span><br><span class="line">flushall清空所有数据库</span><br></pre></td></tr></table></figure></li></ol><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="String-字符串类型"><a href="#String-字符串类型" class="headerlink" title="String 字符串类型"></a><strong>String 字符串类型</strong></h4><p>String 的数据结构为简单动态字符串 <strong>（Simple Dynamic String - SDS）</strong>，是可修改的字符串，</p><p>尽管 Redis 是用 C 写的，但是并未使用 C 的字符串表示，而是对char*进行了简单的包装，</p><p>采用预分配冗余空间的方式来减少内存的频繁分配，</p><p>扩容是加倍现有的空间，但是最大长度为 <strong>512M</strong></p><ul><li><p><a href="https://blog.csdn.net/qq_43561507/article/details/109148830">C语言字符串和 SDS 之间的区别</a></p></li><li><p><a href="https://blog.csdn.net/darker0019527/article/details/102995888">二者之间的详细对比</a></p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> key <span class="keyword">value</span> 添加键值对，重复则会覆盖</span><br><span class="line"><span class="keyword">get</span> key查询对应键值</span><br><span class="line">append key <span class="keyword">value</span>将给定的 <span class="keyword">value</span> 追加到原值的末尾</span><br><span class="line">strlen key获得值的长度</span><br><span class="line">setnx key <span class="keyword">value</span>只有在 key 不存在时，设置 key 的值</span><br><span class="line">incr<span class="operator">/</span>decr key将 key 中存储的数字增加<span class="operator">/</span>减少 <span class="number">1</span></span><br><span class="line">incrby<span class="operator">/</span>decrby key len将 key 中存储的数字值增减，自定义步长</span><br><span class="line">mset key1 value...同时设置一个或多个 key<span class="operator">-</span><span class="keyword">value</span> 对</span><br><span class="line">mget key1 key2...同时获取一个或多个 <span class="keyword">value</span></span><br><span class="line">msetnx key1 value...同时设置一个或多个 key<span class="operator">-</span><span class="keyword">value</span> 对，当且仅当所有给定 key 不存在</span><br><span class="line">getrange key <span class="keyword">start</span> <span class="keyword">end</span>获得值的范围</span><br><span class="line">setrange key pos <span class="keyword">value</span>从 pos 开始用 <span class="keyword">value</span> 复写 key 所存储的字符串值</span><br><span class="line">setex key <span class="type">time</span> <span class="keyword">value</span>设置键值的同时，设置过期时间，单位秒</span><br><span class="line">getset key <span class="keyword">value</span>以新换旧，设置新值的同时获得旧值</span><br></pre></td></tr></table></figure></li></ul><h4 id="List-列表类型"><a href="#List-列表类型" class="headerlink" title="List 列表类型"></a><strong>List 列表类型</strong></h4><p>List 的底层实际是双向链表，对两端的操作性能较高，但是查询索引性能较差，</p><p>数据结构为快速链表（<strong>quickList</strong>），列表元素较少的情况下会使用一块连续的内存存储，</p><p>这个结构称为压缩列表 <strong>（zipList）</strong>，当数据量较多时，多个压缩列表组成快速链表，</p><p>简单的字符串列表，按照插入顺序排序，可以在列表首尾添加元素</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lpush<span class="operator">/</span>rpush key value...在左<span class="operator">/</span>右边插入一个或多值</span><br><span class="line">lpop<span class="operator">/</span>rpop key从左<span class="operator">/</span>右边弹出一个值，值在键在，值光键亡</span><br><span class="line">rpoplpush key1 key2从 key1 列表右边弹出一个值查到 key2 列表左边</span><br><span class="line">lrange key <span class="keyword">start</span> <span class="keyword">end</span>按照索引下标获得元素（从左到右）</span><br><span class="line">lrange key <span class="number">0</span> <span class="number">-1</span>获取所有元素</span><br><span class="line">lindex key index按照索引下标获得元素（从左到右）</span><br><span class="line">llen key获得列表长度</span><br><span class="line">linsert key before v1 v2在 v1 的前面插入 v2</span><br><span class="line">lrem key n <span class="keyword">value</span>从左边删除 n 个 <span class="keyword">value</span></span><br><span class="line">lset key index <span class="keyword">value</span>将列表 key 下标为 index 的只替换为 <span class="keyword">value</span></span><br></pre></td></tr></table></figure><h4 id="Set-集合类型"><a href="#Set-集合类型" class="headerlink" title="Set 集合类型"></a><strong>Set 集合类型</strong></h4><p>Set 提供的功能整体与 List 类似，特殊之处在于 Set 可以<strong>自动排重</strong>，</p><p>并且提供了判断某个成员是否在一个集合内的接口，底层无序集合，hash 表实现，</p><p>所以添加、删除、查找的时间复杂度都是 O（1），<strong>数据结构是 dict 字典</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sadd key value...将一个或多个元素不重复地加入到集合</span><br><span class="line">smembers key取出该集合地所有值</span><br><span class="line">sismember key <span class="keyword">value</span>判断集合 key 是否含有该 <span class="keyword">value</span> 值,有 <span class="number">1</span> 无 <span class="number">0</span></span><br><span class="line">scard key返回该集合地元素个数</span><br><span class="line">srem key value...删除集合中一个或多个元素</span><br><span class="line">spop key从该集合中随机弹出一个元素</span><br><span class="line">srandmember key n从该集合中随机取出 n 个元素</span><br><span class="line">smove src des <span class="keyword">value</span>将集合中地某个元素移动到另一个集合</span><br><span class="line">sinter key1 key2返回两个集合的交集元素</span><br><span class="line">sunion key1 key2返回两个集合的并集元素</span><br><span class="line">sdiff key1 key2返回两个集合的差集元素</span><br></pre></td></tr></table></figure><h4 id="Hash-哈希类型"><a href="#Hash-哈希类型" class="headerlink" title="Hash 哈希类型"></a><strong>Hash 哈希类型</strong></h4><p>键值对集合，String 类型的 field 和 value 的映射表，适合用于存储对象</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hset key field <span class="keyword">value</span>给 key 中的 field 键赋值 <span class="keyword">value</span></span><br><span class="line">hget key field 从 key 中取出 field 的 <span class="keyword">value</span></span><br><span class="line">hmset key field value...批量设置 hash 值</span><br><span class="line">hexists key filed查看哈希表中，是否存在键 field</span><br><span class="line">hkeys key列出该 hash 集合中所有 field</span><br><span class="line">hvals key列出该 hash 集合中所有 <span class="keyword">value</span></span><br><span class="line">hincrby key field inc为 hash 中 field 的值上增量 <span class="number">1</span><span class="operator">/</span><span class="number">-1</span></span><br><span class="line">hsetnx key field <span class="keyword">value</span>当且仅当不存在设置键值对</span><br></pre></td></tr></table></figure><h4 id="Zset-有序集合"><a href="#Zset-有序集合" class="headerlink" title="Zset 有序集合"></a><strong>Zset 有序集合</strong></h4><p>Zset 与普通集合大体相似，不同之处在于有序集合的每个成员关联一个<strong>评分（score）</strong>，</p><p>评分被用来按照从低到高的方式排序集合中的成员，成员唯一，但是评分可以重复，</p><p>SortedSet（Zset）是一个非常特别的数据结构，<strong>底层使用两个数据结构：hash 和 跳跃表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">zadd key score value...将一个或多个元素及其 score 值加入到有序集中</span><br><span class="line">zrange key <span class="keyword">start</span> stop返回下标在 <span class="keyword">start</span> 和 pop 之间的元素</span><br><span class="line">zrangebyscore key min max返回 score 值介于 min 和 max 之间的元素</span><br><span class="line">zincrbykey inc <span class="keyword">value</span>为元素的 score 加上增量</span><br><span class="line">zrem key <span class="keyword">value</span>删除指定元素</span><br><span class="line">zcount key min max统计分数区间内的元素个数</span><br><span class="line">zrank key <span class="keyword">value</span>返回该值在集合中的排名</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring快速开始</title>
      <link href="/2022/01/31/1-Spring%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>/2022/01/31/1-Spring%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><p><strong>PS：仅作为个人学习笔记，以后深入学习再补充</strong></p><p>Spring 学习笔记地址：<a href="https://github.com/Eminem-x/Spring">https://github.com/Eminem-x/Spring</a></p><p>SpringBoot学习笔记地址：<a href="https://github.com/Eminem-x/SpringBoot">https://github.com/Eminem-x/SpringBoot</a></p><p>推荐 Spring 学习视频：<a href="https://www.bilibili.com/video/BV1WZ4y1P7Bp?from=search&seid=9648668674109084850&spm_id_from=333.337.0.0">黑马程序员 SSM 框架教程</a></p><p>推荐 SpringBoot 学习视频：<a href="https://www.bilibili.com/video/BV19K4y1L7MT?from=search&seid=14164871616704737958&spm_id_from=333.337.0.0">尚硅谷 雷神 SpringBoot 学习</a></p><p>SpringBoot 学习参考：<a href="http://www.ityouknow.com/springboot/2016/01/06/spring-boot-quick-start.html">ityouknow-SpringBoot学习</a></p><hr><h3 id="Spring程序开发步骤"><a href="#Spring程序开发步骤" class="headerlink" title="Spring程序开发步骤"></a>Spring程序开发步骤</h3><ol><li>导入 Spring 开发的基本包坐标（通过Maven）；</li><li>创建 Bean；</li><li>创建 Spring 核心配置文件；</li><li>在 Spring 配置文件中进行配置；</li><li>使用 Spring 的 API 获得 Bean 实例；</li></ol><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol><li><p>Dao 是数据访问层，Service 是业务层；</p></li><li><p>Dao 的作用是封装对数据库的访问：CRUD，不涉及业务逻辑；</p></li><li><p>Service 则专注业务逻辑，对于其中需要的数据库操作，通过 Dao 实现；</p></li><li><p>这样的分层是<strong>基于 MVC 架构</strong>而言：</p><p>M是指业务模型（model），V是指用户界面（view），C则是控制器（controller），</p><p>使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。</p></li><li><p>分层的作用是<strong>解耦</strong>；</p></li><li><p><strong>对于 Spring 框架：</strong></p><p>（View\Web）表示层调用控制层（Controller），</p><p>控制层调用业务层（Service），</p><p>业务层调用数据访问层（Dao）。</p></li><li><p><strong>Bean 是一个被实例化，组装，并通过 Spring IoC 容器所管理的对象。</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC获得请求数据</title>
      <link href="/2022/01/31/10-SpringMVC%E8%8E%B7%E5%BE%97%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE/"/>
      <url>/2022/01/31/10-SpringMVC%E8%8E%B7%E5%BE%97%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><p>客户端请求参数的格式是：<strong>name=value&amp;name=value…</strong></p><p>服务器端要获得请求的参数，有时还需要进行数据的封装，</p><h3 id="接收参数类型"><a href="#接收参数类型" class="headerlink" title="接收参数类型"></a>接收参数类型</h3><h4 id="1-基本类型参数"><a href="#1-基本类型参数" class="headerlink" title="1. 基本类型参数"></a>1. 基本类型参数</h4><p>Controller 中的业务方法的参数名称要与请求参数一致，参数值会自动映射匹配</p><h4 id="2-POJO类型参数"><a href="#2-POJO类型参数" class="headerlink" title="2. POJO类型参数"></a>2. POJO类型参数</h4><p>Controller 中的业务方法的 POJO 参数的属性名与请求参数一致，自动映射匹配</p><h4 id="3-数组类型参数"><a href="#3-数组类型参数" class="headerlink" title="3. 数组类型参数"></a>3. 数组类型参数</h4><p>Controller 中的业务方法的 数组名称的与请求参数一致，自动映射匹配</p><h4 id="4-集合类型参数"><a href="#4-集合类型参数" class="headerlink" title="4. 集合类型参数"></a>4. 集合类型参数</h4><ol><li><p>获得集合参数时，需要将集合参数包装到 POJO</p></li><li><p>使用 ajax 提交时，可以指定 contextType 为 json 形式，</p><p>在方法参数位置使用 <strong>@RequsetBody</strong> 可以直接接收集合数据</p></li></ol><hr><h3 id="请求数据乱码问题："><a href="#请求数据乱码问题：" class="headerlink" title="请求数据乱码问题："></a><strong>请求数据乱码问题：</strong></h3><p>当 post 请求时，数据会出现乱码，设置过滤器进行编码的过滤</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    配置全局过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>GBK<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="参数绑定注解"><a href="#参数绑定注解" class="headerlink" title="参数绑定注解"></a>参数绑定注解</h3><p>当请求与业务方法的参数名称不一致时，就需要通过 <strong>@RequsetParam</strong> 注解显示的绑定</p><ul><li>value：请求参数名称</li><li>required：指定请求参数是否必须包括，默认值为 true</li><li>defaultValue：当没有指定请求参数时，则使用默认值赋值</li></ul><hr><h3 id="获得Restful风格的参数"><a href="#获得Restful风格的参数" class="headerlink" title="获得Restful风格的参数"></a>获得Restful风格的参数</h3><p>Restful 是一种软件架构风格、设计风格，而不是标准，</p><p>主要用于客户端和服务器交互类的软件，基于此风格设计，</p><p>可以使得软件更加简洁，具有层次，易于实现缓存机制。</p><p><strong>使用”url + 请求方式” 表示一次请求目的：</strong></p><ul><li>GET：用于获取资源</li><li>POST：用于新建资源</li><li>PUT：用于更新资源</li><li>DELETE：用于删除资源</li></ul><p>在方法中使用 <strong>@PathVariable</strong> 注解进行占位符的匹配获取。</p><hr><h3 id="自定义类型转换器"><a href="#自定义类型转换器" class="headerlink" title="自定义类型转换器"></a>自定义类型转换器</h3><p>默认例子：客户端提交的字符串转换成 int 型进行参数设置</p><p>现实需求：日期类型的数据就需要自定义类型转换器</p><p><strong>具体开发步骤：</strong></p><ol><li>定义转换器类实现 Converter 接口</li><li>在配置文件中声明转换器</li><li>在 &lt;annotation-driven&gt; 中引用转换器</li></ol><hr><h3 id="获得Servlet相关API"><a href="#获得Servlet相关API" class="headerlink" title="获得Servlet相关API"></a>获得Servlet相关API</h3><p>SpringMVC支持使用原始ServletAPI对象作为控制器方法的参数进行注入：</p><ul><li>HttpServletRequest</li><li>HttpServletResponse</li><li>HttpSession</li></ul><hr><h3 id="获得请求头"><a href="#获得请求头" class="headerlink" title="获得请求头"></a>获得请求头</h3><h4 id="1-RequestHeader"><a href="#1-RequestHeader" class="headerlink" title="1. @RequestHeader"></a>1. @RequestHeader</h4><p>注解属性如下：</p><ul><li>value：请求头的名称</li><li>required：是否必须携带此请求头</li></ul><h4 id="2-CookieValue"><a href="#2-CookieValue" class="headerlink" title="2. @CookieValue"></a>2. @CookieValue</h4><p>注解属性如下：</p><ul><li>value：指定 cookie 的名称</li><li>required：是否必须携带此 cookie</li></ul><hr><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><h4 id="1-文件上传客户端三要素"><a href="#1-文件上传客户端三要素" class="headerlink" title="1. 文件上传客户端三要素"></a>1. 文件上传客户端三要素</h4><ul><li>表单项 type = “file”</li><li>表单的提交方式是 post</li><li>表单的 enctype 属性是多部分表单形式</li></ul><h4 id="2-单文件上传步骤"><a href="#2-单文件上传步骤" class="headerlink" title="2. 单文件上传步骤"></a>2. 单文件上传步骤</h4><ul><li><p>导入 fileupload 和 io 坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置文件上传解析器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    配置文件上传解析器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;500000&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写文件上传代码</p></li></ul><h4 id="3-多文件上传"><a href="#3-多文件上传" class="headerlink" title="3. 多文件上传"></a>3. 多文件上传</h4><p>避免重复步骤，将方法参数 MultipartFile 类型修改为 MultipartFile[] 即可</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringJdbcTemplate</title>
      <link href="/2022/01/31/11-Spring%20JdbcTemplate/"/>
      <url>/2022/01/31/11-Spring%20JdbcTemplate/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="JdbcTemplate概述"><a href="#JdbcTemplate概述" class="headerlink" title="JdbcTemplate概述"></a>JdbcTemplate概述</h3><p>Spring 框架中提供的对象，对原始繁琐的 Jdbc API 对象简单封装，提供了很多的操作模板类</p><h3 id="JdbcTemplate开发步骤"><a href="#JdbcTemplate开发步骤" class="headerlink" title="JdbcTemplate开发步骤"></a>JdbcTemplate开发步骤</h3><ul><li><p>导入 spring-jdbc 和 spring-tx 坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建数据库表和实体</p></li><li><p>创建 JdbcTemplate对象</p></li><li><p>执行数据库操作</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring环境搭建</title>
      <link href="/2022/01/31/12-Spring%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2022/01/31/12-Spring%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="环境搭建步骤"><a href="#环境搭建步骤" class="headerlink" title="环境搭建步骤"></a>环境搭建步骤</h3><ol><li>创建工程（Project&amp;Module）</li><li>导入静态页面</li><li>导入所需坐标</li><li>创建包结构（controller、service、dao、domain、utils）</li><li>导入数据库脚本</li><li>创建 POJO 类</li><li>创建配置文件</li></ol><h3 id="角色列表展示的步骤"><a href="#角色列表展示的步骤" class="headerlink" title="角色列表展示的步骤"></a>角色列表展示的步骤</h3><ol><li>点击角色管理菜单发送请求到服务端</li><li>创建 RoleController 和 showList() 方法</li><li>创建 RoleService 和 showList() 方法</li><li>创建 RoleDao 和 findAll() 方法</li><li>使用 JdbcTemplate 完成查询操作</li><li>将查询数据存储到 Model 中</li><li>转发到 role-list.jsp 页面进行展示</li></ol><h3 id="角色添加的步骤"><a href="#角色添加的步骤" class="headerlink" title="角色添加的步骤"></a>角色添加的步骤</h3><ol><li>点击列表页面新建按钮跳转到角色添加页面</li><li>输入角色信息，剪辑保存按钮，表单数据提交服务器</li><li>编写 RoleController 的 save() 方法</li><li>编写 RoleService 的 save() 方法</li><li>编写 RoleDao 的 save() 方法</li><li>使用 JdbcTemplate 保存 Role 数据到 sys_role</li><li>跳转回角色列表页面</li></ol><h3 id="用户登录权限控制"><a href="#用户登录权限控制" class="headerlink" title="用户登录权限控制"></a>用户登录权限控制</h3><p>用户没有登录的情况下，不能对后台菜单进行访问操作，点击菜单跳转到登陆页面，</p><p>只有用户登录成功后才能进行后台功能的操作。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC拦截器</title>
      <link href="/2022/01/31/13-SpringMVC%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
      <url>/2022/01/31/13-SpringMVC%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="拦截器作用"><a href="#拦截器作用" class="headerlink" title="拦截器作用"></a>拦截器作用</h3><p>SpringMVC 的拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行<strong>预处理</strong>和<strong>后处理</strong>；</p><p>将拦截器按一定顺序连接成一条链，这条链成为<strong>拦截器链（Interceptor Chain）</strong>；</p><p>在访问被拦截的方法或字段时，拦截器链中的拦截器就会按之前定义的顺序被调用；</p><p>拦截器也是 <strong>AOP</strong> 思想的具体实现。</p><h3 id="拦截器和过滤器区别"><a href="#拦截器和过滤器区别" class="headerlink" title="拦截器和过滤器区别"></a>拦截器和过滤器区别</h3><table><thead><tr><th>区别</th><th align="left">过滤器（Filter）</th><th>拦截器（Interceptor）</th></tr></thead><tbody><tr><td>适用范围</td><td align="left">servlet 规范中的一部分，<br />任何 Java Web 工程都可以使用</td><td>SpringMVC框架才能使用</td></tr><tr><td>拦截范围</td><td align="left">在 url-pattern 中配置 /* 后，<br />可以对所有要访问的资源拦截</td><td>在 &lt;mvc:mapping path=”” /&gt; 中配置 /** 后，也可以全部拦截，<br />但是可以通过  &lt;mvc:exclude-mapping path=”” /&gt;标签，<br />排除不需要拦截的资源</td></tr></tbody></table><h3 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h3><ol><li><p>创建拦截器类实现 HandlerInterceptor 接口</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>preHandle()</td><td>方法将在请求处理之前进行调用，返回值为布尔类型，<br />当返回值为 false 时，表示请求结束；<br />当返回值为 true 时，继续调用下一个拦截器的 preHandle 方法</td></tr><tr><td>postHandle()</td><td>方法在 preHandle 方法返回值为 true 时才能被调用，<br />并且会在视图返回渲染之前被调用</td></tr><tr><td>afterCompletion()</td><td>在整个请求结束后即渲染视图之后执行</td></tr></tbody></table></li><li><p>配置拦截器在 spring-mvc.xml 文件中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    配置拦截器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    对哪些资源执行拦截操作--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.yuanhao.controller.interceptor.MyInterceptor1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试拦截器</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC异常处理</title>
      <link href="/2022/01/31/14-SpringMVC%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2022/01/31/14-SpringMVC%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="异常处理的思路"><a href="#异常处理的思路" class="headerlink" title="异常处理的思路"></a>异常处理的思路</h3><p>系统中异常包括两类：预期异常和运行时异常；</p><p>前者通过捕获异常从而获取异常信息，后者通过代码规范、测试减少发生。</p><p><strong>系统的 Dao、Service、Controller出现都通过 throws Exception 向上抛出，</strong></p><p><strong>最后由 SpringMVC 前端控制器交由异常处理器进行异常处理。</strong></p><h3 id="异常处理的两种方式"><a href="#异常处理的两种方式" class="headerlink" title="异常处理的两种方式"></a>异常处理的两种方式</h3><ul><li><p>SpringMVC 提供的简单异常处理器：SimpleMappingExceptionResolver</p><p>在使用时可以根据项目情况进行相应异常与视图的映射配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    配置简单映射异常处理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultErrorView&quot;</span> <span class="attr">value</span>=<span class="string">&quot;error&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionMappings&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;com.yuanhao.exception.MyException&quot;</span> <span class="attr">value</span>=<span class="string">&quot;error&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;java.lang.ClassCastException&quot;</span> <span class="attr">value</span>=<span class="string">&quot;error&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Spring 的异常处理接口 HandleExceptionResolver 自定义异常处理器</p><ol><li><p>创建异常处理器类实现接口</p></li><li><p>配置异常处理器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    自定义异常处理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.resolver.MyExceptionResolver&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写异常页面</p></li><li><p>测试异常跳转</p></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP</title>
      <link href="/2022/01/31/15-Spring%20AOP/"/>
      <url>/2022/01/31/15-Spring%20AOP/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="AOP的概念"><a href="#AOP的概念" class="headerlink" title="AOP的概念"></a>AOP的概念</h3><p>AOP 为 Aspect Oriented Programming 的缩写，意味<strong>面向切面编程</strong>，</p><p>是通过<strong>预编译方式和运行期动态代理</strong>实现程序功能的统一维护的一种技术，</p><p>利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使业务逻辑之间松耦合。</p><ul><li>Target（目标对象）：代理的目标对象</li><li>Proxy（代理）：一个类被 AOP 织入增强后，就产生一个结果代理类</li><li>Joinpoint（连接点）：可以被拦截到的点，在 Spring 中指的是方法</li><li>Pointcut（切入点）：对哪些 Joinpoint 进行真正的拦截的定义</li><li>Advice（通知/增强）：拦截到 Joinpoint 之后所要做的事情</li><li>Aspect（切面）：切入点和通知的结合</li><li>Weaving（织入）：把增强应用到目标对象来创建新的代理对象的过程</li></ul><hr><h3 id="AOP的作用及其优势"><a href="#AOP的作用及其优势" class="headerlink" title="AOP的作用及其优势"></a>AOP的作用及其优势</h3><p>作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强</p><p>优势：减少重复代码，提高开发效率，并且便于维护</p><hr><h3 id="AOP的底层实现"><a href="#AOP的底层实现" class="headerlink" title="AOP的底层实现"></a>AOP的底层实现</h3><p>通过 Spring 提供的动态代理技术实现，在程序运行期间，</p><p>Spring 通过动态代理技术动态的生成代理对象，代理对象方法执行时，</p><p>进行增强功能的介入，再去调用目标对象的方法，从而完成功能的增强。</p><hr><h3 id="AOP的动态代理技术"><a href="#AOP的动态代理技术" class="headerlink" title="AOP的动态代理技术"></a>AOP的动态代理技术</h3><ol><li>JDK 代理：基于接口的动态代理技术</li><li>cglib 代理：基于父类的动态代理技术</li></ol><hr><h3 id="AOP的开发明确事项"><a href="#AOP的开发明确事项" class="headerlink" title="AOP的开发明确事项"></a>AOP的开发明确事项</h3><ol><li><strong>需要编写的内容</strong><ul><li>编写核心业务代码（目标类的目标方法）</li><li>编写切面类、切面类中有通知（增强功能方法）</li><li>在配置文件中，配置织入关系</li></ul></li><li><strong>AOP技术实现的内容</strong></li></ol><p>Spring框架监控切入点方法的执行，一旦监控到切入点方法被运行，使用代理机制，</p><p>动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，</p><p>将通知对应的功能织入，完成完整的代码逻辑运行。</p><ol start="3"><li><strong>AOP底层使用那种代理方式</strong></li></ol><p>在Spring中，框架会根据目标类是否实现了接口来决定采用哪种动态代理方式</p><hr><h3 id="基于XML的AOP开发"><a href="#基于XML的AOP开发" class="headerlink" title="基于XML的AOP开发"></a>基于XML的AOP开发</h3><ol><li><p><strong>步骤：</strong></p><ol><li><p>导入AOP相关坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br></pre></td></tr></table></figure></li><li><p>创建目标接口和目标类（内部有切点）</p></li><li><p>创建切面类（内部有增强方法）</p></li><li><p>将目标类和切面类的对象创建全交给Spring</p></li><li><p>在 appliactionContext.xml 中配置织入关系</p></li><li><p>测试代码</p></li></ol></li><li><p><strong>切点表达式的写法：</strong></p><p><code>execution([修饰符] 返回值类型 包名.类名.方法名(参数))</code></p><ul><li>访问修饰符可以省略</li><li>返回值类型、包名、类名、方法名可以使用星号 * 代表任意</li><li>包名与类名之间两个点表示当前包及其子包下的类</li><li>参数列表可以使用两个点表示任意个数，任意类型的参数列表</li></ul></li><li><p><strong>通知类型：</strong></p><p><code>&lt;aop:通知类型 method= ”切面类中方法名“ pointcut=”切点表达式“/&gt;</code></p><table><thead><tr><th>名称</th><th>标签</th><th>说明</th></tr></thead><tbody><tr><td>前置通知</td><td>&lt;aop:before&gt;</td><td>指定增强方法在切入点方法之前执行</td></tr><tr><td>后置通知</td><td>&lt;aop:after-returning&gt;</td><td>指定增强方法在切入点方法之后执行</td></tr><tr><td>环绕通知</td><td>&lt;aop:round&gt;</td><td>指定增强方法在切入点之前之后都执行</td></tr><tr><td>异常抛出通知</td><td>&lt;aop:throwing&gt;</td><td>指定增强的方法在出现异常时执行</td></tr><tr><td>最终通知</td><td>&lt;aop:after&gt;</td><td>无论增强方式执行是否有异常都会执行</td></tr></tbody></table></li></ol><hr><h3 id="基于注解的AOP开发"><a href="#基于注解的AOP开发" class="headerlink" title="基于注解的AOP开发"></a>基于注解的AOP开发</h3><ol><li><p><strong>步骤：</strong></p><ol><li><p>创建目标接口和目标类</p></li><li><p>创建切面类</p></li><li><p>将目标类和切面类的对象创建权交给 Spring</p></li><li><p>在切面类中使用注解配置织入关系</p></li><li><p>在配置文件中开启组件扫描和 AOP 的自动代理</p><p><code>&lt;aop:aspectj-autoproxy/&gt;</code></p></li><li><p>测试代码</p></li></ol></li><li><p><strong>切点表达式的抽取：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;MyAspect.pointcut()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.*.*(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring事务控制</title>
      <link href="/2022/01/31/16-Spring%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/"/>
      <url>/2022/01/31/16-Spring%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="编程式事务控制相关对象"><a href="#编程式事务控制相关对象" class="headerlink" title="编程式事务控制相关对象"></a>编程式事务控制相关对象</h3><ol><li><p><strong>PlatformTransactionManager</strong> 是接口类型，不同的 Dao 层技术有不同的实现类，</p><p>Jdbc 或 Mybatis 时：</p><p><code>org.springframework.jdbc.datasource.DataSourceTransactionManager</code></p><p>Hibernate 时：</p><p><code>org.springframework.orm.hibernate5.HibernateTransactionManager</code></p></li><li><p><strong>TransactionDefinition</strong> 是事务的定义信息对象</p><ol><li><p><strong>事务隔离级别</strong></p><ul><li>ISOLATION_DEFAULT</li><li>ISOLATION_READ_UNCOMMITTED</li><li>ISOLATION_READ_COMMITTED</li><li>ISOLATION_REPEATABLE_READ</li><li>ISOLATION_SERIALIZABLE</li></ul></li><li><p><strong>事务传播行为</strong></p><p><strong>指的是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行。 </strong><br>例如：A 事务方法调用 B 事务方法时，B 是继续在调用者 A 的事务中运行，</p><p>还是为自己开启一个新事务运行，这就是由 B 的事务传播行为决定的。</p></li><li><p><strong>事务运行状态 TransactionStatus</strong></p></li></ol></li></ol><hr><h3 id="声明式事务控制"><a href="#声明式事务控制" class="headerlink" title="声明式事务控制"></a>声明式事务控制</h3><ol><li><strong>概念：</strong></li></ol><p>Spring 在配置文件中声明的方式来处理事务，代替代码式的处理事务</p><ol start="2"><li><strong>作用：</strong></li></ol><ul><li><p>事务管理不侵入开发的组件，具体来说，业务逻辑对象就不会意识到正在事务管理之中，</p><p>事实上也应如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，</p><p>如果想要改变事务管理策划的化，也只需要在定义文件中重新配置即可</p></li><li><p>不需要事务管理的时候，只要再设定文件上修改，便于维护</p></li></ul><ol start="3"><li><strong>Spring声明式事务控制底层就是AOP</strong></li></ol><hr><h3 id="基于XML文件配置"><a href="#基于XML文件配置" class="headerlink" title="基于XML文件配置"></a>基于XML文件配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    配置平台事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--通知 事务的增强--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--代表切点方法的事务参数的配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    配置事务的aop织入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.service.impl.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="基于注解"><a href="#基于注解" class="headerlink" title="基于注解"></a>基于注解</h3><ol><li>使用 <strong>@Transactional</strong> 在需要进行事务控制的类或方法上修饰</li><li>注解使用在类上，那么该类下的所有方法都使用同一套注解参数配置</li><li>使用在方法上，不同的方法可以采用不同的事务参数配置</li><li>配置事务注解驱动 <code>&lt;tx:annotation-driver&gt;</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis基础</title>
      <link href="/2022/01/31/17-Mybatis%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/01/31/17-Mybatis%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="原始-Jdbc-操作分析"><a href="#原始-Jdbc-操作分析" class="headerlink" title="原始 Jdbc 操作分析"></a>原始 Jdbc 操作分析</h3><p><strong>存在以下问题：</strong></p><ol><li>数据库连接创建、释放频繁造成系统资源浪费从而影响性能</li><li>sql 语句在代码中硬编码，不易维护，不便于实际应用</li><li>查询和插入操作时，需要手动处理结果集和实体集</li></ol><p><strong>解决方案：</strong></p><ol><li>使用数据库连接池初始化连接资源</li><li>将 sql 语句抽取到 xml 配置文件中</li><li>使用反射、内省等底层技术，自动将实体与表进行映射</li></ol><h3 id="Mybatis-概念"><a href="#Mybatis-概念" class="headerlink" title="Mybatis 概念"></a>Mybatis 概念</h3><ul><li>基于 Java 的持久层框架，内部封装了 Jdbc，简化了开发者的工作</li><li>通过 xml 或注解的方式将要执行的各种 statement 配置起来</li><li>将结果映射为对象并返回，采用 ORM 思想解决实体和数据库映射问题</li><li>对 Jdbc 进行封装，屏蔽了底层访问细节，便于操作和维护</li></ul><h3 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h3><ol><li><p>添加 MyBatis 坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建数据表（user）</p></li><li><p>创建实体类（User）</p></li><li><p>编写映射文件（UserMapper.xml）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> </span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;userMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.domain.User&quot;</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>&lt;if&gt;：if 判断</li><li>&lt;foreach&gt;：循环</li><li>&lt;sql&gt;：sql 片段抽取</li></ul></li><li><p>编写核心文件（SqlMapConfig.xml）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span> </span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--数据源环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/study&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写测试类</p><p><strong>操作涉及数据库数据变化时，要提交事务，即<code>sqlSession.commit()</code></strong></p></li></ol><h3 id="核心配置文件"><a href="#核心配置文件" class="headerlink" title="核心配置文件"></a>核心配置文件</h3><ul><li>environments 标签：数据源环境配置标签</li><li>mappers 标签：加载映射配置</li><li>properties 标签：加载外部的 properties 文件</li><li>typeAliases 标签：设置类型别名</li><li>typeHandlers 标签：重写或创建类型处理器来处理不支持或非标准的类型</li><li>plugins 标签：Mybatis 可以使用第三方插件对功能进行拓展</li></ul><h3 id="相应API"><a href="#相应API" class="headerlink" title="相应API"></a>相应API</h3><ol><li><h4 id="SqlSession-工厂构建器-SqlSessionFactoryBuilder"><a href="#SqlSession-工厂构建器-SqlSessionFactoryBuilder" class="headerlink" title="SqlSession 工厂构建器 SqlSessionFactoryBuilder"></a>SqlSession 工厂构建器 SqlSessionFactoryBuilder</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得核心配置文件</span></span><br><span class="line">InputStream resourceAsStream = Resources.getResourceAsStream(<span class="string">&quot;sqlMapConfig.xml&quot;</span>);</span><br><span class="line"><span class="comment">// 获得session工厂对象</span></span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(resourceAsStream);</span><br></pre></td></tr></table></figure><p>通过加载核心文件输入流的形式构建一个 SqlSessionFactory 对象</p></li><li><h4 id="SqlSession-工厂对象-SqlSessionFactory"><a href="#SqlSession-工厂对象-SqlSessionFactory" class="headerlink" title="SqlSession 工厂对象 SqlSessionFactory"></a>SqlSession 工厂对象 SqlSessionFactory</h4><p>存在多个方法创建 SqlSession 实例，常用的如下两种：</p><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>openSession()</td><td>默认开启一个事务，但事务不会自动提交，需要手动提交，<br />更新数据才会持久化到数据库中</td></tr><tr><td>openSession(boolean autoCommit)</td><td>参数为是否自动提交，如果为 true，那么不需要手动提交</td></tr></tbody></table></li><li><h4 id="SqlSession-会话对象"><a href="#SqlSession-会话对象" class="headerlink" title="SqlSession 会话对象"></a>SqlSession 会话对象</h4><p>包含所有执行语句、提交或回滚事务和获取映射器实例的方法</p></li></ol><h3 id="Dao层代理开发"><a href="#Dao层代理开发" class="headerlink" title="Dao层代理开发"></a>Dao层代理开发</h3><p>Mybatis的代理开发方式实现 DAO 层的开发：<strong>Mapper接口开发方法</strong>，</p><p><strong>只需要实现 Mapper 接口，由 Mybatis 框架根据接口定义创建接口的动态代理对象。</strong></p><p><strong>遵循以下开发规范：</strong></p><ul><li>Mapper.xml 文件中的 namespace 与 mapper 接口的全限定名相同</li><li>Mapper 接口方法名和 Mapper.xml 中定义的每个 statement 的 id 相同</li><li>Mapper 接口方法的输入参数类型和文件中定义的每个 sql 的 parameterType 类型相同</li><li>Mapper 接口方法的输出参数类型和文件中定义的每个 sql 的 resultType 类型相同、</li></ul><h3 id="MyBatis注解开发"><a href="#MyBatis注解开发" class="headerlink" title="MyBatis注解开发"></a>MyBatis注解开发</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM框架整合</title>
      <link href="/2022/01/31/18-SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/"/>
      <url>/2022/01/31/18-SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p>从 GitHub 上 Fork 的项目：<a href="https://github.com/liyifeng1994/ssm/tree/master/src">https://github.com/liyifeng1994/ssm/tree/master/src</a></p><p>并且该项目有详细的整合流程：<a href="https://blog.csdn.net/qq598535550/article/details/51703190">https://blog.csdn.net/qq598535550/article/details/51703190</a></p><p>但是因为是几年前的项目，许多包的版本过时，无法正常启动，所以重新构建了整个项目，</p><p>跟着原作者的流程完成，整体不会出现太难解决的问题，并且该项目并无具体 web实现，</p><p>仅通过 test 测试整体框架的完备性，适合学习框架的设计流程。</p><h3 id="更改版本"><a href="#更改版本" class="headerlink" title="更改版本"></a>更改版本</h3><ol><li><p>数据库驱动版本：要和自己的数据库版本保持一致</p></li><li><p>c3p0 版本：<a href="https://blog.csdn.net/Peng_Ze_Yu/article/details/81632828">https://blog.csdn.net/Peng_Ze_Yu/article/details/81632828</a></p><p>在 Maven 导入时，更改版本信息，否则报错</p></li><li><p>Spring 版本：5.0.5.RELEASE</p></li><li><p>junit 版本：4.12 避免低版本不支持</p><p>mybatis 以及 mybatis-spring 版本更新</p></li><li><p>entity：<a href="https://blog.csdn.net/qq_35991056/article/details/81390551">https://blog.csdn.net/qq_35991056/article/details/81390551</a></p><p>entity / domain / model 的区别，在以后项目中应该也会遇到</p></li><li><p>数据库的 appoint_time 修改为 appoint_date</p><p>因为创建变量时，误写为 appointDate，所以更改了数据库列名</p></li></ol><h3 id="整合流程"><a href="#整合流程" class="headerlink" title="整合流程"></a>整合流程</h3><ol><li><p>建立整个项目的基础目录结构，同时遵循 maven 的目录规范</p></li><li><p>导入相应的 jar 包，资源坐标，注意版本号兼容性</p></li><li><p>资源文件中建立 spring 文件，按照 dao、service、controller分层配置</p></li><li><p>配置 mybatis 的核心文件 <code>mybatis-config.xml</code></p></li><li><p>配置 <code>web.xml</code> 文件</p></li><li><p>根据需求，配置日志文件</p></li><li><p>需要根据需求设计数据库以及查询语句</p></li><li><p>在 entity 层中封装数据库实体，注意内部成员名称</p></li><li><p>在 dao 层建立相对应的接口，由于 mybatis 不需要实现</p></li><li><p>资源文件中编写相对应的 mapper 配置文件</p></li><li><p>定义业务的数据字典，返回给客户端的状态信息</p></li><li><p>在 dto 包下建立类存储执行操作后的返回结果</p></li><li><p>在 dto 包下建立封装 json 返回结果的类，设计成泛型</p></li><li><p>在 exception 下建立自定义异常类</p></li><li><p>在 service 层下编写具体业务代码，创建并实现接口</p></li><li><p>编写 controller 层即 web 层，完善整体结构</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring配置文件</title>
      <link href="/2022/01/31/2-Spring%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/2022/01/31/2-Spring%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="Bean-标签基本配置"><a href="#Bean-标签基本配置" class="headerlink" title="Bean 标签基本配置"></a>Bean 标签基本配置</h3><ol><li><p>Bean 用于配置对象交由 Spring 来创建，<strong>默认情况下调用的是类中的无参构造函数</strong>，</p><p>如果没有无参构造函数则不能创建成功；</p></li><li><p>基本属性</p><ol><li><p><strong>id</strong>：Bean 实例在 Spring 容器中的唯一标识</p></li><li><p><strong>class</strong>：Bean 的全限定名称</p></li><li><p><strong>scope</strong>：Bean 的作用范围</p></li><li><p><strong>&lt;property&gt;</strong>标签：属性注入</p><ol><li>name 属性：属性名称</li><li>value 属性：注入的普通属性值</li><li>ref 属性：注入的对象引用值</li><li>&lt;list&gt;标签、&lt;map&gt;标签、&lt;properties&gt;标签</li></ol></li><li><p><strong>&lt;constructor-arg&gt;标签</strong></p></li></ol></li><li><p><strong>&lt;import&gt;标签</strong>：导入其他的 Spring 的分文件</p></li></ol><h3 id="Bean-标签范围配置"><a href="#Bean-标签范围配置" class="headerlink" title="Bean 标签范围配置"></a>Bean 标签范围配置</h3><table><thead><tr><th align="center">取值范围</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">singleton</td><td align="center">默认值、单例</td></tr><tr><td align="center">prototype</td><td align="center">多例</td></tr><tr><td align="center">request</td><td align="center">WEB项目中，存入到 request 域</td></tr><tr><td align="center">session</td><td align="center">WEB项目中，存入到 session 域</td></tr><tr><td align="center">global session</td><td align="center">WEB项目中，应用在 Portlet 环境</td></tr></tbody></table><ol><li><h4 id="当-scope-的取值为-singleton-时："><a href="#当-scope-的取值为-singleton-时：" class="headerlink" title="当 scope 的取值为 singleton 时："></a>当 scope 的取值为 singleton 时：</h4></li></ol><ul><li>Bean 的实例化个数：1个</li><li>Bean 的实例化时机：当 Spring 核心文件被加载时，实例化配置的 Bean 实例</li><li>Bean 的生命周期：<ol><li>对象创建：当应用加载，创建容器时，对象就被创建；</li><li>对象运行：只要容器在，对象就一直存在；</li><li>对象销毁：当应用卸载，销毁容器时，对象就被销毁；</li></ol></li></ul><ol start="2"><li><h4 id="当-scope-的取值为-prototype-时："><a href="#当-scope-的取值为-prototype-时：" class="headerlink" title="当 scope 的取值为 prototype 时："></a>当 scope 的取值为 prototype 时：</h4></li></ol><ul><li>Bean 的实例化个数：多个</li><li>Bean 的实例化时机：当调用 getBean() 方法时实例化 Bean</li><li>Bean 的生命周期：<ol><li>对象创建：当使用对象时，创建新的对象实例；</li><li>对象运行：只要对象在使用中，就一直存在；</li><li>对象销毁：当对象长时间不用，就被 Java 的垃圾回收期回收；</li></ol></li></ul><h3 id="Bean-生命周期配置"><a href="#Bean-生命周期配置" class="headerlink" title="Bean 生命周期配置"></a>Bean 生命周期配置</h3><ul><li><p>init-method：指定类中的初始化方法名称</p></li><li><p>destroy-method：指定类中的销毁方法名称</p><p><strong>注意：需要手动关闭容器，才能运行销毁方法</strong></p></li></ul><p><strong>特殊说明：</strong></p><p>当创建 ApplicationContext 对象时，不存在 close() 方法，有两种解决方法：</p><ol><li>更改为 AbstractApplicationContext 对象；</li><li><strong>向下强制转为 ConfigurableApplicationContext，即声明时的类型；</strong></li><li>在大多数情况下更加推荐第二种方法；</li><li>参考文章：<a href="https://stackoverflow.com/questions/14423980/how-to-close-a-spring-applicationcontext">java - How to close a spring ApplicationContext? - Stack Overflow</a></li></ol><h3 id="Bean-实例化三种方式"><a href="#Bean-实例化三种方式" class="headerlink" title="Bean 实例化三种方式"></a>Bean 实例化三种方式</h3><ul><li>无参构造方法实例化</li><li>工厂静态方法实例化</li><li>工厂实例方法实例化</li></ul><h3 id="Bean-依赖注入"><a href="#Bean-依赖注入" class="headerlink" title="Bean 依赖注入"></a>Bean 依赖注入</h3><ol><li><p><strong>依赖注入（Dependency Injection）: Spring框架核心 IOC 的具体实现</strong></p></li><li><p>依赖注入方式：</p><ul><li>构造方法</li><li>set 方法</li></ul></li><li><p>依赖注入的数据类型：</p><ul><li>普通数据类型</li><li>引用数据类型</li><li>集合数据类型</li></ul></li></ol><h3 id="引入其他配置文件（分模块开发）"><a href="#引入其他配置文件（分模块开发）" class="headerlink" title="引入其他配置文件（分模块开发）"></a>引入其他配置文件（分模块开发）</h3><p>实际开发中，Spring 的配置内容非常多，导致配置很繁杂并且体积大，</p><p>所以可以将部分配置拆解到其他配置文件中，而在 Spring 主配置文件中，</p><p>通过 import 标签进行加载。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis进阶</title>
      <link href="/2022/01/31/3-Redis%E8%BF%9B%E9%98%B6/"/>
      <url>/2022/01/31/3-Redis%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a><strong>RDB</strong>（Redis DataBase）</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>在指定时间间隔内将内存中的数据集快照写入磁盘</p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>Redis 会<strong>单独创建（fork）</strong>一个子进程来进行持久化，会先将数据写入到一个临时文件，</p><p>待持久化过程结束，再用临时文件替换上次持久化好的文件，<strong>默认 dump.rdb</strong></p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p><ol><li><p>整个过程中，主进程不进行任何 IO 操作，这就确保了极高的性能</p></li><li><p>如果对数据恢复的完整性不敏感，那么比 AOF 更加高效。</p></li><li><p>节省磁盘空间，恢复速度快</p></li></ol><p>缺点：</p><ol><li>最后一次持久化后的数据可能丢失</li><li>虽然使用了写时复制技术，但是如果数据庞大还是比较消耗性能</li><li>Fork 的时候内存中的数据被克隆一份，大致 2 倍的膨胀性需要考虑</li></ol><h4 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h4><ol><li><p>Fork 的作用是复制一个与当前进程一样的进程，所有的数据均一致，</p><p>但是是一个全新的进程，并作为原进程的子进程</p></li><li><p>写时复制技术</p></li><li><p>一般情况父进程和子进程共用一段物理内存</p></li></ol><hr><h3 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a><strong>AOF</strong>（Append Only File）</h3><ol><li><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>以日志的形式来记录每个写操作（增量保存），</p><p>将 Redis 执行过的所有写指令记录下来（读操作不记录），</p><p>只许追加文件但不可以改写文件，Redis 启动时会读取文件重构数据</p></li><li><h4 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h4><ul><li>客户端的请求写命令会被 append 追加到 AOF 缓冲区内</li><li>AOF 缓存区根据 AOF 持久化策略将操作 sync 同步到磁盘 AOF 文件</li><li>AOF 文件大小超过重写策略或手动重写时，进行 rewrite 重写和压缩</li><li>Redis 服务启动时，会重新加载 AOF 文件中的写操作恢复数据</li></ul></li><li><h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><ol><li>AOF 默认不开启，需要在配置文件中将 <code>appendonly</code> 改为 <code>yes</code></li><li>AOF 和 RDB 同时开启时，系统默认取 AOF 的数据<strong>（数据不会存在丢失）</strong></li><li>异常通过 <code>redis-check-aof --fix appendonly,aof</code> 恢复文件，重启即可</li><li>同步频率设置 appendfsync：<ul><li>always：始终同步，每次 Redis 的写入都会立刻记入日志，完整性好但性能差</li><li>everysec：每秒同步，如果宕机，本秒的数据可能丢失</li><li>no：不主动进行同步，把同步时机交给操作系统</li></ul></li><li>Rewrite 压缩：避免 AOF 文件过大，采用重写机制，将内容压缩</li></ol></li><li><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p><ol><li>备份机制更稳健，丢失数据概率更低</li><li>可读的日志文本，可以处理误操作</li></ol><p>缺点：</p><ol><li>占用更多的磁盘空间</li><li>恢复备份速度慢</li><li>每次读写都同步的话，存在一定的性能压力</li><li>存在个别 bug，造成恢复不能</li></ol></li></ol><hr><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ol><li>官方推荐两个都启用</li><li>如果对数据不敏感，可以单独使用 RDB</li><li>不建议单独使用 AOF，可能会出现 bug</li><li>如果只是做纯内存缓存，可以都不用</li></ol><hr><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><ol><li><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a><strong>概念</strong></h4><p>主机数据更新后根据配置和策略，自动同步到备机的 <strong>master/slaver 机制，</strong></p><p>master 以写为主，slaver 以读为主，但是会存在<strong>复制延时</strong>的情况，</p><p>当系统繁忙或 slaver 机器数量增加的时候，延迟问题会更加严重</p></li><li><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h4><ul><li>读写分离，性能拓展</li><li>容灾快速恢复</li></ul></li><li><h4 id="搭建简单的一主两从"><a href="#搭建简单的一主两从" class="headerlink" title="搭建简单的一主两从"></a><strong>搭建简单的一主两从</strong></h4><ol><li><p>创建 <code>/myRedis</code> 文件夹，拷贝 <code>redis.Windows.conf</code> 文件至目录下</p></li><li><p>配置一主两从，创建三个配置文件</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis6379.<span class="keyword">conf</span></span><br><span class="line">redis6380.<span class="keyword">conf</span></span><br><span class="line">redis6381.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure></li><li><p>在每个配置文件中写入以下内容（替换 6379 即可）</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> redis.windows.<span class="keyword">conf</span></span><br><span class="line">pidfile /<span class="keyword">var</span>/<span class="keyword">run</span>/redis_6379.pid</span><br><span class="line">port 6379</span><br><span class="line">dbfilename dump6379.rdb</span><br></pre></td></tr></table></figure></li><li><p>启动三个 Redis 服务</p><ul><li>查看当前主机运行状况</li><li>在从机上执行 <code>slaveof</code> 主机 ip 端口号</li><li><code>SLAVEOF 127.0.0.1 6379</code> 配置主从关系</li><li>验证主从的基本性质，master 以写为主，slaver 以读为主</li></ul></li></ol></li><li><h4 id="主从复制特点"><a href="#主从复制特点" class="headerlink" title="主从复制特点"></a><strong>主从复制特点</strong></h4><ul><li>一主二仆</li><li>薪火相传</li><li>反客为主</li></ul></li><li><h4 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a><strong>哨兵模式</strong></h4><ol><li><p>反客为主的自动版，能够后台监控主机是否故障，根据投票数将从库转为主库</p></li><li><p>模拟案例</p><ol><li><p>建立一个简易的一主二仆模式</p></li><li><p>在 <code>/myRedis</code> 目录下建立 <code>sentinel.conf</code> 文件</p></li><li><p>写入 <code>sentinel monitor mymaster 127.0.0.1 6379 1</code> </p><p><code>mymaster</code> 为监控对象起的名称，<code>1</code> 为至少有多少个哨兵同意迁移的数量</p></li><li><p>如果你使用 <code>redis-sentinel</code> 可执行文件，你可以使用下面的命令来运行 <code>Sentinel</code>：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel <span class="regexp">/path/</span>to/sentinel.conf</span><br></pre></td></tr></table></figure><p>另外，你可以直接使用 <code>redis-server</code> 并以 <code>Sentinel</code> 模式来启动：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-<span class="keyword">server</span> /<span class="type">path</span>/<span class="keyword">to</span>/sentinel.conf <span class="comment">--sentinel</span></span><br></pre></td></tr></table></figure></li><li><p>将主机关闭，查看结果即可</p></li></ol></li><li><p>选择条件依次如下</p><ul><li>选择优先级靠前的（redis.conf 中的 slave-priority 值越小优先级越高）</li><li>选择偏移量最大的（获得最全原主机数据的从服务）</li><li>选择 runid 最小地从服务（每个 Redis 启动后随机生成的 40 位 runid）</li></ul></li></ol></li></ol><hr><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><ol><li><h5 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h5>Redis 集群实现了对 Redis 的水平扩容，即启动 N 个 Redis 节点，将整个数据库分布存储在这 N 个节点中，每个节点存储总数据的 1/N，集群通过分区来提供一定程度的可用性，即使集群中有一部分节点失效或者无法进行通讯，集群也可以继续处理命令请求</li><li><h5 id="搭建简易集群"><a href="#搭建简易集群" class="headerlink" title="搭建简易集群"></a>搭建简易集群</h5><ol><li><p>在目录下创建六份实例 <code>redis.conf</code></p></li><li><p>在主从的基础上，添加以下内容（替换 6379 即可）</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cluster</span>-enabled yes</span><br><span class="line"><span class="keyword">cluster</span>-config-<span class="keyword">file</span> nodes-6379.<span class="keyword">conf</span></span><br><span class="line"><span class="keyword">cluster</span>-node-timeout 15000</span><br></pre></td></tr></table></figure></li><li><p>启动六个 Redis 服务，将节点合成一个集群</p><p>启动服务后，确保所有的 <code>nodes-xxxx.conf</code> 文件生成正常</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create --cluster-replicas <span class="number">1 127.0.0</span>.<span class="number">1:6379 127</span>.<span class="number">0</span>.<span class="number">0.1:6380</span> <span class="number">127.0.0.1</span>:<span class="number">6381 127.0</span>.<span class="number">0.1:6389</span> <span class="number">127.0.0.1</span>:<span class="number">6390 127.0</span>.<span class="number">0.1:6391</span></span><br></pre></td></tr></table></figure><p>通过任意节点进入集群 <code>redis-cli.exe -p 6379</code></p><p>查看集群节点信息 <code>cluster nodes</code></p></li></ol></li><li><h5 id="如何分配节点"><a href="#如何分配节点" class="headerlink" title="如何分配节点"></a>如何分配节点</h5><code>--cluster-replicas 1</code> 表示为集群中的每个主节点创建一个从节点分配原则尽量保证每个主数据库运行在不同的 IP 地址，每个主库和从库不在一个 IP 地址上</li><li><h5 id="插槽-Hash-Slot"><a href="#插槽-Hash-Slot" class="headerlink" title="插槽 Hash Slot"></a>插槽 Hash Slot</h5>一个集群包含 <code>16384</code> 个插槽，数据库中的每个键都属于其中一个，集群使用公式 <code>CRC16(key) % 16384</code> 来计算 key 属于哪个槽，而集群中的每个节点负责处理一部分插槽</li><li><strong>故障恢复</strong><ul><li><p>如果主节点宕机，从节点根据超时时间自动升为主节点</p></li><li><p>主节点恢复后，主节点变成从机</p></li><li><p>如果所有某段插槽的主从节点都宕机，</p><p>集群根据 <code>cluster-require-full-coverage</code> 是否宕机</p></li></ul></li><li><h5 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h5>优点：<ol><li>实现扩容</li><li>分摊压力</li><li>无中心配置相对简单</li></ol></li></ol><p>   缺点：</p><pre><code>  1. 多键操作是不支持的  2. 多键的 Redis 事务是不被支持的，lua 脚本不被支持  3. 出现较晚，目前整体迁移复杂度较大</code></pre>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis特性</title>
      <link href="/2022/01/31/2-Redis%E7%89%B9%E6%80%A7/"/>
      <url>/2022/01/31/2-Redis%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置信息存储在 <code>redis.windows.conf</code> 文件</p><hr><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h4><p>发布订阅（pub / sub）是一种消息通信模式：发送者（pub）发送信息，订阅者（sub）接收信息，</p><p>Redis 客户端可以订阅任意数量的频道，发布的消息没有持久化。</p><h4 id="2-命令行实现"><a href="#2-命令行实现" class="headerlink" title="2. 命令行实现"></a>2. 命令行实现</h4><ul><li><p>打开一个客户端订阅 channel1：<code>subscribe channel1</code></p></li><li><p>打开另一个客户端，给 channel1 发布消息：<code>public channel1 helloworld</code></p></li><li><p>打开第一个客户端可以接收到发送的信息</p></li></ul><hr><h3 id="新数据类型"><a href="#新数据类型" class="headerlink" title="新数据类型"></a>新数据类型</h3><h4 id="1-Bitmaps"><a href="#1-Bitmaps" class="headerlink" title="1. Bitmaps"></a>1. Bitmaps</h4><p>合理地使用操作位能够有效地提高内存使用率和开发效率</p><p>Redis 提供 Bitmaps 实现对位的操作：</p><ul><li><p>本身不是一种数据类型，实际上就是字符串，不过可以对位进行操作</p></li><li><p>提供单独的一套命令，可以堪称一个以位为单位的数组</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setbit key <span class="keyword">offset</span> <span class="keyword">value</span>设置 Bitmaps 中某个偏移量的值</span><br><span class="line">getbit key <span class="keyword">offset</span>获取 Bitmaps 中某个偏移量的值</span><br><span class="line">bitcount key <span class="keyword">start</span> <span class="keyword">end</span>统计字符串被设置为 <span class="number">1</span> 的 bit 数</span><br><span class="line">bitop op dest src多功能符合操作</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-HyperLogLog"><a href="#2-HyperLogLog" class="headerlink" title="2. HyperLogLog"></a>2. HyperLogLog</h4><p>工作当中，会遇到<strong>基数问题：</strong>求集合中不重复元素的个数，解决方案：</p><ol><li>数据存储在 MySQL 中，使用 <code>distinct count</code> 计算不重复个数</li><li>使用 Redis 提供的 hash、set、bitmaps 等数据结构来处理</li></ol><p>以上方案的结果准确，但是随着数据规模增加，导致占用空间非常大，</p><p><strong>而 HyperLogLog 可以降低一定的精度来平衡存储空间，用来做基数统计。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pfadd key element添加指定元素到 HyperLogLog 中</span><br><span class="line">pfcount key计算 HLL 近似基数值</span><br><span class="line">pfmerge dest src将一个或多个 HLL 合并后的结果存在 dest 中 </span><br></pre></td></tr></table></figure><h4 id="3-Geospatial"><a href="#3-Geospatial" class="headerlink" title="3. Geospatial"></a>3. Geospatial</h4><p>对 GEO 类型的支持，<strong>GEO（Geographic）地理信息的缩写，二维坐标</strong></p><p>基于该类型，提供了经纬度设置、范围查询、距离查询等常见操作。</p><hr><h3 id="事务和锁机制"><a href="#事务和锁机制" class="headerlink" title="事务和锁机制"></a>事务和锁机制</h3><h4 id="1-事务概念"><a href="#1-事务概念" class="headerlink" title="1. 事务概念"></a>1. 事务概念</h4><p>Redis 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行，</p><p>事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p><h4 id="2-事务作用"><a href="#2-事务作用" class="headerlink" title="2. 事务作用"></a>2. 事务作用</h4><p>Redis 事务的主要作用就是串联多个命令防止别的命令插队</p><h4 id="3-操作命令"><a href="#3-操作命令" class="headerlink" title="3. 操作命令"></a>3. 操作命令</h4><ul><li>Multi：输入的命令依次进入命令队列中</li><li>Exec：将之前的命令队列中的命令依次执行</li><li>Discard：放弃组队</li></ul><h4 id="4-事务特性"><a href="#4-事务特性" class="headerlink" title="4. 事务特性"></a>4. 事务特性</h4><ol><li><p><strong>单独的隔离操作</strong></p><p>事务中的所有命令都会序列化、按顺序地执行，事务在执行的过程中，</p><p>不会被其他客户端发送来的命令请求所打断</p></li><li><p><strong>没有隔离级别的概念</strong></p><p>队列中的命令没有提交之前都不会实际被执行，</p><p>因为事务提交前任何指令都不会被实际执行</p></li><li><p><strong>不保证原子性</strong></p><p>事务中如果有一条命令执行失败，其后的命令仍然会被执行，不回滚</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring相关API</title>
      <link href="/2022/01/31/3-Spring%E7%9B%B8%E5%85%B3API/"/>
      <url>/2022/01/31/3-Spring%E7%9B%B8%E5%85%B3API/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><p>各个版本的 API 文档链接：<a href="https://docs.spring.io/spring-framework/docs/">https://docs.spring.io/spring-framework/docs/</a></p><h3 id="ApplicationContext-的继承体系"><a href="#ApplicationContext-的继承体系" class="headerlink" title="ApplicationContext 的继承体系"></a>ApplicationContext 的继承体系</h3><p>ApplicationContext：接口类型，代表应用上下文，可以通过其实例获得 Spring 容器中的 Bean 对象</p><h3 id="ApplicationContext-的实现类"><a href="#ApplicationContext-的实现类" class="headerlink" title="ApplicationContext 的实现类"></a>ApplicationContext 的实现类</h3><ul><li><p><strong>ClassPathXmlApplicationContext</strong></p><p>从类的根路径下加载配置文件<strong>（推荐使用）</strong></p></li><li><p><strong>FileSystemXmlApplicationContext</strong></p><p>从磁盘路径上加载配置文件，配置文件可以在磁盘上的任意位置</p></li><li><p><strong>AnnotationConfigApplicationContext</strong></p><p>当使用注解配置容器对象时，需要用此类创建容器，用来读取注解</p></li></ul><h3 id="getBean-方法"><a href="#getBean-方法" class="headerlink" title="getBean() 方法"></a>getBean() 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.<span class="function">Object <span class="title">getBean</span><span class="params">(java.lang.String name)</span> <span class="keyword">throws</span> BeansException</span></span><br><span class="line"><span class="function">&lt;T&gt; T <span class="title">getBean</span><span class="params">(java.lang.Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span></span><br></pre></td></tr></table></figure><ol><li><p>参数类型是字符串时，表示根据 Bean 的 id 从容器中获得实例，</p><p>返回时 Object，需要进行强制类型转换</p></li><li><p>参数类型是 Class 时，表示根据类型从容器中匹配 Bean 实例，</p><p>不需要强制类型转换，但是当有多个相同 Bean 时，会报错</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis应用</title>
      <link href="/2022/01/31/4-Redis%E5%BA%94%E7%94%A8/"/>
      <url>/2022/01/31/4-Redis%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="秒杀"><a href="#秒杀" class="headerlink" title="秒杀"></a>秒杀</h3><ol><li><p><strong>关于 Postman 和 JMeter 的选择</strong></p><p>推荐选择 JMeter，因为 Postman 只能支持串行接口测试</p><p>JMeter 推荐参考文章：</p><ul><li><p><a href="https://www.jianshu.com/p/0e4daecc8122">JMeter入门教程 - 简书 (jianshu.com)</a></p></li><li><p><a href="https://www.cnblogs.com/summerstore/p/11529105.html">如何使用JMeter进行并发测试 - 你安静了夏天 - 博客园 (cnblogs.com)</a></p></li></ul><p>Postman 关于能否并发：<a href="https://www.zhihu.com/question/280155125">https://www.zhihu.com/question/280155125</a></p></li><li><p><strong>出现的问题</strong></p><ul><li><p>超时：节省每次连接 Redis 服务带来的消耗，使用连接池解决</p></li><li><p>超卖：使用乐观锁，事务提交，解决超出库存的问题</p></li><li><p>库存遗留问题：由于乐观锁的机制造成仍有库存遗留</p><p><strong>通过 LUA 脚本解决争抢问题</strong>，实际上是 Redis 利用其单线程的特性，</p><p>用任务队列的方式解决多任务并发问题</p></li></ul></li></ol><hr><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><ol><li><p>概念</p><p>使用 Redis 大部分情况都是通过 key 查询对应的值，</p><p>假如发送的请求传进来的 key 是不存在 Redis 中的，</p><p>那么就查不到缓存，查不到缓存就会去数据库查询，</p><p>假如有大量这样的请求，这些请求像“穿透”了缓存一样直接打在数据库上。</p></li><li><p>解决方案</p><ol><li><p><strong>把无效的 key 存进 Redis 中</strong></p><p>如果Redis查不到数据，数据库也查不到，我们把这个 key 值保存进 Redis，</p><p>设置 value=”null”，当下次再通过这个 key 查询时就不需要再查询数据库，</p><p>这种方式是有问题的，若不存在的 Key 值每次都是随机的，存进Redis也没有意义。</p></li><li><p><strong>设置可访问的名单（白名单）</strong></p></li><li><p><strong>采用布隆过滤器（Boom Filter）</strong></p><p>布隆过滤器的作用是某个 key 不存在，那么就一定不存在，</p><p>它说某个 key 存在，那么很大可能是存在(存在一定的误判率)，</p><p>于是我们可以在缓存之前再加一层布隆过滤器，</p><p>在查询的时候先去布隆过滤器查询 key 是否存在，如果不存在就直接返回。</p></li><li><p><strong>进行实时监控</strong></p><p>当发现 Redis 的命中率开始急速降低时，需要排查访问对象和访问的数据，</p><p>以及运维人员配合，可以设置黑名单限制服务。</p></li></ol></li></ol><hr><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><ol><li><p>概念</p><p>缓存击穿是一个热点的 key ，有大并发集中对其进行访问，</p><p>突然间这个 key 失效了，导致大并发全部打在数据库上，</p><p>导致数据库压力剧增，这种现象就叫做缓存击穿。</p></li><li><p>解决方案</p><ol><li><p><strong>预先设置热门数据</strong></p><p>如果业务允许的话，对于热点的 key 可以设置永不过期，</p><p>或者加大热门数据 key 的过期时长。</p></li><li><p><strong>实时调整</strong></p><p>现场监控哪些数据热门，实时调整 key 的过期时长。</p></li><li><p><strong>使用互斥锁</strong></p><p>如果缓存失效的情况，只有拿到锁才可以查询数据库，</p><p>降低了在同一时刻打在数据库上的请求，防止数据库打死，</p><p>当然这样会导致系统的性能变差。</p></li></ol></li></ol><hr><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><ol><li><p>概念</p><p>当某一个时刻出现大规模的缓存失效的情况，</p><p>那么就会导致大量的请求直接打在数据库上面，导致数据库压力巨大，</p><p>如果在高并发的情况下，可能瞬间就会导致数据库宕机，</p><p>这时如果马上重启数据库，马上又会有新的流量把数据库打死，这就是缓存雪崩。</p></li><li><p>解决方案</p><ol><li><p><strong>构建多级缓存架构</strong></p><p>nginx + redis + 其他缓存</p></li><li><p><strong>使用锁或队列</strong></p><p>用加锁或队列的方式保证不会有大量的线程对数据库一次性读写，</p><p>从而避免失效时大量的并发请求落到底层存储系统上，不适用高并发情况</p></li><li><p><strong>设置过期标志更新缓存</strong></p><p>如果过期会触发通知另外的线程在后台去更新实际 key 的缓存</p></li><li><p><strong>将缓存失效时间分散</strong></p><p>在失效时间上加上一个随机值，避免因为相同的过期时间导致缓存雪崩</p></li><li><p><strong>熔断机制</strong></p><p>当流量到达一定的阈值时，就直接返回“系统拥挤”之类的提示，</p><p>防止过多的请求打在数据库上，至少能保证一部分用户是可以正常使用，</p><p>其他用户多刷新几次也能得到结果。</p></li></ol></li></ol><hr><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><ol><li><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，</p><p>由于分布式系统多线程、多进程并且分布在不同机器上，</p><p>这使原单机部署情况下的并发控制锁策略失效，</p><p>单纯的 Java API 并不能提供分布式锁的能力，为了解决这个问题，</p><p>需要一种跨 JVM 的互斥机制来控制共享资源的访问</p></li><li><h5 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h5><ol><li>基于数据库实现分布式锁</li><li><strong>基于缓存（Redis 等）</strong></li><li>基于 Zookeeper</li></ol></li><li><h5 id="使用-redis-实现分布式锁"><a href="#使用-redis-实现分布式锁" class="headerlink" title="使用 redis 实现分布式锁"></a><strong>使用 redis 实现分布式锁</strong></h5><ol><li>设置锁和过期时间</li><li>UUID 防止误删</li><li>LUA 保证删除原子性</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring配置数据源</title>
      <link href="/2022/01/31/4-Spring%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E6%BA%90/"/>
      <url>/2022/01/31/4-Spring%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="数据源（连接池）的作用"><a href="#数据源（连接池）的作用" class="headerlink" title="数据源（连接池）的作用"></a>数据源（连接池）的作用</h3><ul><li>提高程序性能</li><li>事先实例化数据源，初始化部分连接资源</li><li>使用连接资源时从数据源中获取</li><li>使用完毕后连接资源归还给数据源</li></ul><p>常见的数据源：DBCP、C3P0、BoneCP、Druid等</p><h3 id="数据源的开发步骤"><a href="#数据源的开发步骤" class="headerlink" title="数据源的开发步骤"></a>数据源的开发步骤</h3><ol><li>导入数据源的坐标和数据库驱动坐标</li><li>创建数据源对象</li><li>设置数据源的基本连接数据</li><li>使用数据源获取连接资源和归还连接资源</li></ol><h3 id="Spring-配置数据源"><a href="#Spring-配置数据源" class="headerlink" title="Spring 配置数据源"></a>Spring 配置数据源</h3><p>可以将 DataSource 的创建权交由 Spring 容器完成</p><h4 id="抽取-jdbc-配置文件"><a href="#抽取-jdbc-配置文件" class="headerlink" title="抽取 jdbc 配置文件"></a>抽取 jdbc 配置文件</h4><p>applicationContext.xml 加载 jdbc.properties 配置文件获得连接信息。</p><ol><li><p>引入 context 命名空间和约束路径：</p><p>命名空间：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br></pre></td></tr></table></figure><p>约束路径：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://www.springframework.org/schema/context </span><br><span class="line">http://www.springframework.org/schema/context/spring-context.xsd</span><br></pre></td></tr></table></figure></li><li><p>Spring 容器加载 properties 文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;xx.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;key&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring注解开发</title>
      <link href="/2022/01/31/5-Spring%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/"/>
      <url>/2022/01/31/5-Spring%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p><escpae><span id="more"></span></escape></p><p>Spring 是轻代码而重配置的框架，配置比较繁重，影响开发效率，</p><p>所以注解是一种开发趋势，注解代替 <code>xml</code> 配置文件可以简化配置，提高开发效率。</p><h3 id="原始注解"><a href="#原始注解" class="headerlink" title="原始注解"></a>原始注解</h3><p>Spring 原始注解主要是替代 &lt;Bean&gt; 的配置</p><table><thead><tr><th>注解</th><th align="left">说明</th></tr></thead><tbody><tr><td>@Component</td><td align="left">使用在类上实例化 Bean</td></tr><tr><td>@Controller</td><td align="left">使用在 web 层类上实例化 Bean</td></tr><tr><td>@Service</td><td align="left">使用在 service 层类上实例化 Bean</td></tr><tr><td>@Repository</td><td align="left">使用在 dao 层类上实例化 Bean</td></tr><tr><td>@Autowired</td><td align="left">使用在字段上用于根据类型依赖注入</td></tr><tr><td>@Qualifier</td><td align="left">结合 @Autowired 用于根据名称依赖注入</td></tr><tr><td>@Resource</td><td align="left">相当于 @Autowired + @Qualifier</td></tr><tr><td>@Value</td><td align="left">注入普通属性</td></tr><tr><td>@Scope</td><td align="left">标注 Bean 的作用范围</td></tr><tr><td>@PostConstruct</td><td align="left">标注方法上表明是 Bean 的初始化方法</td></tr><tr><td>@PreDestory</td><td align="left">标注方法上表明是 Bean 的销毁方法</td></tr></tbody></table><p><strong>注意：</strong></p><ol><li><p>使用注解进行开发时，需要在 <code>xml</code> 中配置组件扫描，其作用是：</p><p>指定哪个包及其子包下的 <code>Bean</code> 需要进行扫描以便识别使用注解配置的类、字段和方法；</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p><code>@Autowired</code> 根据数据类型从 <code>Spring</code> 容器中进行匹配</p><p><code>@Qualifier</code> 根据 <code>id</code> 值从容器中进行匹配，但是需要结合 <code>@Autowired</code> 使用；</p></li><li><p>使用 <code>prototype</code> 时 <code>Spring</code> 不会负责销毁容器对象，将 <code>scope</code> 改为 <code>singleton</code> 才会生效 <code>destroy</code> 方法；</p></li></ol><h3 id="新注解"><a href="#新注解" class="headerlink" title="新注解"></a>新注解</h3><ul><li>非自定义的 <code>Bean</code> 配置：&lt;bean&gt;</li><li>加载外部 <code>properties</code> 文件的配置：&lt;context:property-placeholder&gt;</li><li>组件扫描的配置：&lt;context:component-scan&gt;</li><li>引入其他文件：&lt;import&gt;</li></ul><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Configuration</td><td>用于指定当前类是一个 Spring 核心配置类</td></tr><tr><td>@ComponentScan</td><td>用于指定 Spring 在初始化容器时要扫描的包</td></tr><tr><td>@Bean</td><td>使用在方法上，将该方法的返回值存储到容器中</td></tr><tr><td>@PropertySource</td><td>用于加载 properties 文件</td></tr><tr><td>@Import</td><td>用于导入其他配置类</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring集成Junit</title>
      <link href="/2022/01/31/6-Spring%E9%9B%86%E6%88%90Junit/"/>
      <url>/2022/01/31/6-Spring%E9%9B%86%E6%88%90Junit/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="原始-Junit-测试-Spring-的问题"><a href="#原始-Junit-测试-Spring-的问题" class="headerlink" title="原始 Junit 测试 Spring 的问题"></a>原始 Junit 测试 Spring 的问题</h3><p>在测试类中，每个测试方法都有一下两行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">IAccountService as = ac.getBean(<span class="string">&quot;accountService&quot;</span>, IAccountService.class);</span><br></pre></td></tr></table></figure><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ul><li>让 SpringJunit 负责创建 Spring 容器，但是需要将配置文件的名称告之；</li><li>将需要进行测试 Bean 直接在测试类中进行注入；</li></ul><h3 id="Spring-集成-Junit-步骤"><a href="#Spring-集成-Junit-步骤" class="headerlink" title="Spring 集成 Junit 步骤"></a>Spring 集成 Junit 步骤</h3><ol><li>导入 Spring 集成 Junit 的坐标</li><li>使用 @RunWith 注解替换原来的运行期</li><li>使用 @ContextConfiguration 指定配置文件或配置类</li><li>使用 @Autowired 注入需要测试的对象</li><li>创建测试方法进行测试</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring与Web环境集成</title>
      <link href="/2022/01/31/7-Spring%E4%B8%8EWeb%E7%8E%AF%E5%A2%83%E9%9B%86%E6%88%90/"/>
      <url>/2022/01/31/7-Spring%E4%B8%8EWeb%E7%8E%AF%E5%A2%83%E9%9B%86%E6%88%90/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="ApplicationContext应用上下文获取方式"><a href="#ApplicationContext应用上下文获取方式" class="headerlink" title="ApplicationContext应用上下文获取方式"></a>ApplicationContext应用上下文获取方式</h3><p>应用上下文对象是通过 <code>new ClassPathXmlApplicationContext(Spring配置文件)</code>方式获取，</p><p>但是每次从容器中获得 Bean 时都要编写，会导致配置文件加载多次，应用上下文创建多次。</p><br><p>在 Web 项目中，可以使用 <code>ServletContextListener</code> 监听 Web 应用的启动，当应用启动时，</p><p>就加载 Spring 的配置文件，创建应用上下文对象，并将其存储到 <code>servletContext</code> 域中，</p><p>这样就可以在任意位置从域中获得应用上下文对象 <code>ApplicationContext</code> 对象。</p><h3 id="Spring提供获取应用上下文的工具"><a href="#Spring提供获取应用上下文的工具" class="headerlink" title="Spring提供获取应用上下文的工具"></a>Spring提供获取应用上下文的工具</h3><p>Spring 提供监听器 <code>ContextLoaderListener</code> 对上述功能封装，</p><p>该监听器内部加载 Spring 配置文件，创建应用上下文对象，并存储到 <code>servletContext</code> 域中，</p><p>提供了一个客户端工具 <code>WebApplicationContextUtils</code> 供获得应用上下文对象。</p><ol><li>在 web.xml 中配置 ContextLoaderListener 监听器<strong>（导入 spring-web 坐标）</strong></li><li>使用 WebApplicationContextUtils 获得应用上下文对象</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC基础</title>
      <link href="/2022/01/31/8-SpringMVC%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/01/31/8-SpringMVC%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="SpringMVC概述"><a href="#SpringMVC概述" class="headerlink" title="SpringMVC概述"></a>SpringMVC概述</h3><p>SpringMVC 是一种基于 Java 的实现 MVC设计模型的请求驱动类型的轻量级 Web 框架</p><ol><li>前端控制器：DispatcherServlet</li><li>处理器映射器：HandlerMapping</li><li>处理器适配器：HandlerAdapter</li><li>处理器：Handler</li><li>视图解析器：ViewResolver</li><li>视图：View</li></ol><h3 id="SpringMVC步骤"><a href="#SpringMVC步骤" class="headerlink" title="SpringMVC步骤"></a>SpringMVC步骤</h3><p>需求：客户端发起请求，服务器端接受请求，执行逻辑并进行视图跳转</p><ol><li>导入 SpringMVC 相关坐标</li><li>配置 SpringMVC 核心控制器 DispatcherServlet</li><li>创建 Controller 类和视图页面</li><li>使用注解配置 Controller 类中业务方法的映射地址</li><li>配置 SpringMVC 核心文件 spring-mvc.xml</li><li>客户端发起请求测试</li></ol><h3 id="SpringMVC执行流程"><a href="#SpringMVC执行流程" class="headerlink" title="SpringMVC执行流程"></a>SpringMVC执行流程</h3><ol><li><p>用户发送请求至前端控制器 DispatcherServlet</p></li><li><p>DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器</p></li><li><p>处理器映射器找到具体的处理器，生成处理器对象以及处理器拦截器，</p><p>一并返回给 DispatcherServlet</p></li><li><p>DispatcherServlet 调用 HandlerAdapter 处理器适配器</p></li><li><p>HandlerAdapter 经过适配器调用具体的处理器</p></li><li><p>Controller 执行完成后返回 ModelAndView</p></li><li><p>HandlerAdapter 将 ModelAndView 返回给 DispatcherServlet</p></li><li><p>DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器</p></li><li><p>ViewReslover 解析后返回具体 View</p></li><li><p>DispatcherServlet 根据 View 进行渲染视图后响应用户</p></li></ol><h3 id="SpringMVC注解解析"><a href="#SpringMVC注解解析" class="headerlink" title="SpringMVC注解解析"></a>SpringMVC注解解析</h3><ol><li><strong>@RequestMapping</strong></li></ol><p>作用：用于建立请求 URL 和 处理请求方法之间的对应关系</p><p>位置：</p><ul><li>类上，请求 URL 的第一级访问目录</li><li>方法上，请求 URL 的第二级访问目录</li></ul><p>属性：</p><ul><li>value：用于指定请求的 URL</li><li>method：用于指定请求的方式</li><li>params：用于指定限制请求参数的条件，支持简单的表达式</li></ul><h3 id="SpringMVC的XML配置解析"><a href="#SpringMVC的XML配置解析" class="headerlink" title="SpringMVC的XML配置解析"></a>SpringMVC的XML配置解析</h3><ol><li>mvc 命名空间引入和组件扫描</li><li>配置内部资源视图解析器</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC数据响应</title>
      <link href="/2022/01/31/9-SpringMVC%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94/"/>
      <url>/2022/01/31/9-SpringMVC%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h3><h4 id="直接返回字符串"><a href="#直接返回字符串" class="headerlink" title="直接返回字符串"></a>直接返回字符串</h4><p>此种方式会将返回的字符串与视图解析器的前后缀拼接后跳转</p><h4 id="通过-ModelAndView-对象返回"><a href="#通过-ModelAndView-对象返回" class="headerlink" title="通过 ModelAndView 对象返回"></a>通过 ModelAndView 对象返回</h4><hr><h3 id="回写数据"><a href="#回写数据" class="headerlink" title="回写数据"></a>回写数据</h3><h4 id="直接返回字符串-JSON"><a href="#直接返回字符串-JSON" class="headerlink" title="直接返回字符串 / JSON"></a>直接返回字符串 / JSON</h4><ul><li>通过 SpringMVC 框架注入的 response 对象，此时不需要视图跳转，方法返回值为 void</li><li>将需要回写的字符串直接返回，通过 <strong>@ResponseBody</strong> 注解告知 SpringMVC 框架</li></ul><h4 id="返回对象或集合"><a href="#返回对象或集合" class="headerlink" title="返回对象或集合"></a>返回对象或集合</h4><p>通过 SpringMVC 进行 JSON 字符串的转换并回写，为处理器适配器配置消息转化参数，</p><p>指定使用 jackson 进行转换，因此需要在 spring-mvc.xml 中进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;messageConverters&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在方法上添加 @ResponseBody 就可以返回 json 格式的字符串，但是配置比较繁琐，</p><p>因此，可以使用<strong>注解驱动代替上述配置：<code>&lt;mvc:annotation-driven/&gt;</code></strong></p><p><strong>处理器映射器、处理器适配器、视图解析器成为 SpringMVC 的三大组件</strong>，</p><p>上述注解驱动默认底层就会集成 jackson 进行对象或集合的 json格式字符串的转换。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分搜索</title>
      <link href="/2021/12/20/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"/>
      <url>/2021/12/20/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><blockquote><blockquote><p>总结一下二分搜索的特性，处理问题时总遇到怎么确定 left 或者 right 的情况；</p><p>因此总结一下基本的用法，方便以后使用。</p></blockquote></blockquote><h3 id="第一种判定方式：left-≤-right"><a href="#第一种判定方式：left-≤-right" class="headerlink" title="第一种判定方式：left ≤ right"></a>第一种判定方式：<code>left ≤ right</code></h3><p>如果有的题目需要得到不存在时，应在数组中的位置：</p><ol><li><strong>如果以 <code>left</code> 为基准，那么最终 <code>left</code> 指向的位置在 <code>target</code> 右边；</strong></li><li>如果以 <code>right</code> 为基准，那么最终 <code>right</code> 指向的位置在 <code>target</code> 左边；</li><li>以第一种情况为例：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果仅用来搜索是否存在</span></span><br><span class="line">        <span class="comment">// return -1;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断位置</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[--left];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断左右那个值得差更小</span></span><br><span class="line">        <span class="keyword">if</span> (target - nums[left - <span class="number">1</span>] &lt; nums[left] - target) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[left - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二种判定方式：left-lt-right"><a href="#第二种判定方式：left-lt-right" class="headerlink" title="第二种判定方式：left &lt; right"></a>第二种判定方式：<code>left &lt; right</code></h3><p>在得到 <code>mid</code> 时，常用得方法有两种：</p><ol><li><code>mid = (right - left) / 2 + left</code> ，避免溢出；</li><li><strong><code>mid = (right + left) &gt;&gt; 1</code> 运算更快，推荐；</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] != target) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(logn)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Next的界面优化</title>
      <link href="/2021/11/29/Hexo%E7%9A%84%E7%95%8C%E9%9D%A2%E4%BC%98%E5%8C%96/"/>
      <url>/2021/11/29/Hexo%E7%9A%84%E7%95%8C%E9%9D%A2%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="如何将页面背景改为黑色模式？"><a href="#如何将页面背景改为黑色模式？" class="headerlink" title="如何将页面背景改为黑色模式？"></a>如何将页面背景改为黑色模式？</h3><p>修改 Next 主题下的 _config.yml 配置文件：将 darkmode 的值修改为 true 。</p><p>如果主界面已经设置了 hexo-tag-cloud 标签云的展示，那么修改博客站点的配置文件，</p><p>_config.yml 中标签云模块下的 textColor 更改为 ‘#FFFFFF’ # 白色，或者其他颜色即可。</p><hr><h3 id="如何为页面添加当前浏览进度？"><a href="#如何为页面添加当前浏览进度？" class="headerlink" title="如何为页面添加当前浏览进度？"></a>如何为页面添加当前浏览进度？</h3><p>修改 Next 主题下的 _config.yml 配置文件：</p><p>将 back2top 中的 enable 和 scrollpercent 值修改为 true 。</p><hr><h3 id="如何将页面的首页更改为归档？"><a href="#如何将页面的首页更改为归档？" class="headerlink" title="如何将页面的首页更改为归档？"></a>如何将页面的首页更改为归档？</h3><p>修改 Next 主题下的 _config.yml 配置文件：</p><p>将 menu 下的 home 路径修改为 archive 即可，同时注释掉 archive。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: <span class="regexp">/archives/</span> || fa fa-archive</span><br><span class="line">  <span class="attr">about</span>: <span class="regexp">/about/</span> || fa fa-user</span><br><span class="line">  <span class="attr">tags</span>: <span class="regexp">/tags/</span> || fa fa-tags</span><br><span class="line">  <span class="attr">categories</span>: <span class="regexp">/categories/</span> || fa fa-th</span><br><span class="line">  #archives: <span class="regexp">/archives/</span> || fa fa-archive</span><br><span class="line">  #schedule: <span class="regexp">/schedule/</span> || fa fa-calendar</span><br><span class="line">  #sitemap: /sitemap.xml || fa fa-sitemap</span><br><span class="line">  #commonweal: <span class="regexp">/404/</span> || fa fa-heartbeat</span><br></pre></td></tr></table></figure><p><em>（提醒：如果担心更改错误，备份原文件）</em></p><hr><h3 id="如何为页面添加加载特效？"><a href="#如何为页面添加加载特效？" class="headerlink" title="如何为页面添加加载特效？"></a>如何为页面添加加载特效？</h3><p>参考文章：<a><a href="https://juejin.cn/post/6844903789946896398">Hexo博客NexT主题美化之顶部加载进度条 - 掘金 (juejin.cn)</a></a></p><hr><h3 id="如何修改主题的段距？"><a href="#如何修改主题的段距？" class="headerlink" title="如何修改主题的段距？"></a>如何修改主题的段距？</h3><p>回答在官方仓库的 Issue，链接：<a href="https://github.com/theme-next/hexo-theme-next/issues/1703">https://github.com/theme-next/hexo-theme-next/issues/1703</a></p><hr><h3 id="如何美化分类页面？"><a href="#如何美化分类页面？" class="headerlink" title="如何美化分类页面？"></a>如何美化分类页面？</h3><p>参考这两篇博客：</p><p><a href="https://jrbcode.gitee.io/posts/be9758cd.html">Hexo+NexT博客归档/标签/分类页美化 | CodeHeap (gitee.io)</a></p><p><a href="https://www.cnblogs.com/cscshi/p/15196122.html">Hexo-NexT 分类多层级描述 - 锦瑟，无端 - 博客园 (cnblogs.com)</a></p><p>前者是添加一些 CSS 样式以及美化，而后者是增强分类的观感。</p><hr><h3 id="如何把文章间的距离缩小？"><a href="#如何把文章间的距离缩小？" class="headerlink" title="如何把文章间的距离缩小？"></a>如何把文章间的距离缩小？</h3><p>参考 Issue：<a href="https://github.com/iissnan/hexo-theme-next/issues/591">https://github.com/iissnan/hexo-theme-next/issues/591</a></p><hr><h3 id="如何修改文章链接样式？"><a href="#如何修改文章链接样式？" class="headerlink" title="如何修改文章链接样式？"></a>如何修改文章链接样式？</h3><p>修改 <code>themes\next\source\css\_common\components\post.styl</code> 文件，添加如下 CSS 样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 文章内链接文本样式</span><br><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#8CC7B5</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#8CC7B5</span>;</span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fc6423</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: none;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#fc6423</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>color</code> 部分可以根据个人喜好更改。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本概念</title>
      <link href="/2021/11/29/Java%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2021/11/29/Java%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="Java语言有哪些优点？"><a href="#Java语言有哪些优点？" class="headerlink" title="Java语言有哪些优点？"></a>Java语言有哪些优点？</h3><ol><li><p>Java为纯面向对象的语言</p></li><li><p>平台无关性</p></li><li><p>Java提供了很多内置的类库</p></li><li><p>提供了对Web应用开发的支持</p></li><li><p>具有较好的安全性和健壮性</p></li><li><p>去除了C++语言中难以理解、容易混淆的特性</p><p><strong>说明：Java语言是由C++语言改进并重新设计而来的</strong></p></li></ol><hr><h3 id="Java与C、C-有什么异同"><a href="#Java与C、C-有什么异同" class="headerlink" title="Java与C、C++有什么异同"></a>Java与C、C++有什么异同</h3><ol><li><p><strong>Java为半编译半解释型语言，而C / C++为编译型语言</strong></p><ul><li>Java程序源代码先经过Java编译器编译成字节码，然后由JVM解释执行</li><li>C / C++程序源代码经过编译和链接后生成可执行的二进制代码</li></ul><p>因此C / C++的执行速度比Java快，但是Java因为JVM可以跨平台执行。</p></li><li><p><strong>Java为纯面向对象的语言，而C++兼具面向过程和面向对象的特点</strong></p><ul><li>Java中除了基本数据类型，所有类型都是类</li><li>Java语言中不存在全局变量或者全局函数</li></ul></li><li><p><strong>Java没有多重继承，但是可以实现多个接口</strong></p></li><li><p><strong>Java语言提供了垃圾回收器来实现垃圾的自动回收</strong></p><ul><li>C++语言中，需要开发人员去管理对内存的分配（申请与释放）</li><li>Java的GC机制，不需要开发人员去关心内存空间</li></ul></li><li><p><strong>Java具有平台无关性</strong></p><ul><li>Java中每种基本类型数据都分配固定长度</li><li>C / C++中在不同的平台会分配不同的字节数</li></ul></li><li><p><strong>其他不同的地方</strong></p><ol><li>Java不支持运算符重载</li><li>Java没有预处理器，但是提供 import 机制</li><li>Java不支持默认函数参数</li><li>Java不提供 goto 语句，但是做为保留关键字</li><li>Java不提供自动强制类型转化，需要显示转换</li><li>Java不包含结构和联合，所有内容封装在类里面</li><li>Java没有指针的概念，避免指针引起的系统问题</li><li>Java提供了一些标准库，用于完成特定的任务，比如 JDBC</li></ol></li></ol><p><strong>常见的一个错误说法：Java语言中的方法属于类的成员</strong></p><p>静态方法：类成员</p><p>非静态方法：实例成员</p><hr><h3 id="为什么需要-main-方法"><a href="#为什么需要-main-方法" class="headerlink" title="为什么需要 main 方法"></a>为什么需要 main 方法</h3><p><code>public static void main(String args[]) &#123;&#125;</code></p><ol><li><p>该方法为Java程序的入口方法，JVM在运行程序时，会首先查找 main() 方法</p></li><li><p>字符串数组 args 为开发人员在命令行状态下与程序交互提供了一种手段</p></li><li><p>因为 main() 方法是程序的入口，要执行一个类的方法，就必须实例化一个对象，</p><p>此时还没有实例化对象，所以该方法需要被定义成 public 和 static </p></li><li><p>main() 方法其他可用的定义格式：</p><p><em><strong>说明：public 和 static 的位置可以互换，没有先后关系</strong></em></p><ol><li><code>static public void main(String args[]) &#123;&#125;</code></li><li><code>public static final void main(String args[]) &#123;&#125;</code></li><li><code>public static synchronized void main(String args[]) &#123;&#125;</code></li></ol><p><strong>但是不可以用 abstract 关键字修饰，因为该函数为程序的入口方法</strong></p></li></ol><hr><h3 id="一个Java文件中是否可以定义多个类"><a href="#一个Java文件中是否可以定义多个类" class="headerlink" title="一个Java文件中是否可以定义多个类"></a>一个Java文件中是否可以定义多个类</h3><ol><li>可以定义多个类，但是<strong>最多只能有一个被 public 修饰的类</strong>，并且该类与文件名相同</li><li>如果没有 public 类，那么文件名随便一个类的名字即可</li><li>当编译此文件时，每一个类都会生成一个对应的字节码文件 .class</li><li><strong>普通方法可以与构造函数有相同的方法名</strong></li></ol><hr><h3 id="Java程序初始化的顺序"><a href="#Java程序初始化的顺序" class="headerlink" title="Java程序初始化的顺序"></a>Java程序初始化的顺序</h3><p>在Java语言中，当实例化对象时，对象所在类的所有成员变量首先要进行初始化，</p><p>只有当所有类成员完成初始化后，才会调用对象所在类的构造函数创建对象。</p><p><strong>程序初始化一般遵循三个原则（优先级依次递减）：</strong></p><ol><li>静态对象（变量）优先于非静态</li><li>父类优先于子类</li><li>按照成员变量的定义顺序进行初始化</li></ol><p><strong>具体的执行顺序如下：</strong></p><p>父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、</p><p>父类非静态变量、父类非静态代码块、父类构造函数、</p><p>子类非静态变量、子类非静态代码块、子类构造函数。</p><p><strong>示例代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Load B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Create B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Load B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Load A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Create A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>程序运行结果是：</strong>Load B    Load B    Load A    Create B    Create A</p><hr><h3 id="Java中的作用域"><a href="#Java中的作用域" class="headerlink" title="Java中的作用域"></a>Java中的作用域</h3><table><thead><tr><th align="center">作用域与可见性</th><th align="center">当前类</th><th align="center">同一package</th><th align="center">子类</th><th align="center">其他package</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">protected</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">default</td><td align="center">√</td><td align="center">√</td><td align="center">×</td><td align="center">×</td></tr><tr><td align="center">private</td><td align="center">√</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><p>注意：private 和 protected 不能用来修饰类</p><hr><h3 id="Java中的标识接口"><a href="#Java中的标识接口" class="headerlink" title="Java中的标识接口"></a>Java中的标识接口</h3><p>标识接口：没有任何方法声明的接口</p><p>作用：仅仅充当一个标识作用，用来表明实现它的类属于一个特定的类型</p><hr><h3 id="Java中的clone方法"><a href="#Java中的clone方法" class="headerlink" title="Java中的clone方法"></a>Java中的clone方法</h3><p>实际编程中，需要从某个已有的对象 A 创建处另外一个与 A 具有相同状态的对象 B，</p><p>并且对 B 的修改不会影响到 A 的自身状态，因此提供了 clone 方法返回一个新的对象。</p><p><strong>使用clone方法的步骤：</strong></p><ol><li>实现clone的类首先需要继承 Cloneable 接口</li><li>在类中重写 Object 类中的 clone() 方法</li><li>在 clone() 方法章调用 super.clone() <strong>（浅复制）</strong></li><li>对对象中的非基本类型的属性也调用 clone() 方法 <strong>（深复制）</strong></li><li>把复制的引用指向原型对象新的克隆体</li></ol><p><strong>示例代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date birth = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getBirth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birth.setMonth(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Obj o = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 实现浅复制</span></span><br><span class="line">            o = (Obj) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现深复制</span></span><br><span class="line">        o.birth = (Date) <span class="keyword">this</span>.getBirth().clone();</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Obj a = <span class="keyword">new</span> Obj();</span><br><span class="line">        Obj b = (Obj)a.clone();</span><br><span class="line">        b.changeDate();</span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span> + a.getBirth());</span><br><span class="line">        System.out.println(<span class="string">&quot;b = &quot;</span> + b.getBirth());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>程序运行结果是：</strong></p><p>a = Mon Nov 29 19:05:03 CST 2021<br>b = Sat May 29 19:05:03 CST 2021</p><hr><h3 id="Java创建对象的四种方式"><a href="#Java创建对象的四种方式" class="headerlink" title="Java创建对象的四种方式"></a>Java创建对象的四种方式</h3><ol><li>通过 new 语句实例化一个对象</li><li>通过反射机制创建对象</li><li>通过 clone() 方法创建一个对象</li><li>通过反序列化的方式船舰一个对象</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Next的基础搭建</title>
      <link href="/2021/11/27/Hexo%E7%9A%84%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/"/>
      <url>/2021/11/27/Hexo%E7%9A%84%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="如何通过GitHub搭建Hexo博客？"><a href="#如何通过GitHub搭建Hexo博客？" class="headerlink" title="如何通过GitHub搭建Hexo博客？"></a>如何通过GitHub搭建Hexo博客？</h3><p>推荐UP主 CodeSheep 的这期视频：<a><a href="https://www.bilibili.com/video/BV1Yb411a7ty?from=search&seid=12143109252670934815&spm_id_from=333.337.0.0">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo_哔哩哔哩_bilibili</a></a></p><p><em>（讲的很详细，并且其他视频对于初学者都很有帮助）</em></p><p><strong>补充：这里如果windows下的cmd操作不适配，推荐下载使用Git，仿照视频操作。</strong></p><hr><h3 id="如何添加-分类-标签-模块？"><a href="#如何添加-分类-标签-模块？" class="headerlink" title="如何添加 分类 | 标签 模块？"></a>如何添加 分类 | 标签 模块？</h3><p>推荐文章：<a><a href="https://juejin.cn/post/6921750181297782798">Hexo添加分类及标签（在Next主题下） - 掘金 (juejin.cn)</a></a></p><p><strong>补充：文章只能属于一个分类，但是可以属于多个标签。</strong></p><hr><h3 id="如何在文章内部署图片？"><a href="#如何在文章内部署图片？" class="headerlink" title="如何在文章内部署图片？"></a>如何在文章内部署图片？</h3><p>推荐文章：<a><a href="https://www.jianshu.com/p/f72aaad7b852">HEXO插入图片（详细版） - 简书 (jianshu.com)</a></a></p><p><strong>补充：</strong></p><ol><li><p>此方法插入图片时，typora或者其他markdown软件中，不可见图片，但是网页部署会出现，</p><p>这里推荐文章：<a>hexo博客如何插入图片 - 知乎 (zhihu.com)](<a href="https://zhuanlan.zhihu.com/p/265077468">https://zhuanlan.zhihu.com/p/265077468</a>)</a>的第三点说明。</p></li><li><p>在执行npm的时候可能会报错，参考下面文章依据情况解决：</p><p><a><a href="https://blog.csdn.net/zzq00zzj/article/details/120826520?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link">(13条消息) npm install报错 npm ERR! 的四种解决办法_zzq00zzj的博客-CSDN博客</a></a></p></li></ol><hr><h3 id="如何添加访客统计和文章阅读次数？"><a href="#如何添加访客统计和文章阅读次数？" class="headerlink" title="如何添加访客统计和文章阅读次数？"></a>如何添加访客统计和文章阅读次数？</h3><p>推荐文章：<a><a href="https://blog.csdn.net/baidu_34310405/article/details/102665373">(13条消息) Hexo Next主题添加访客统计、访问次数统计、文章阅读次数统计_AcLings的博客-CSDN博客</a></a></p><hr><h3 id="如何美化代码块以-Mac-Pane的风格？"><a href="#如何美化代码块以-Mac-Pane的风格？" class="headerlink" title="如何美化代码块以 Mac Pane的风格？"></a>如何美化代码块以 Mac Pane的风格？</h3><p>推荐文章：<a><a href="https://miaosakurai.com/2020/04/20/Hexo-NexT%E7%BE%8E%E5%8C%96%F0%9F%8D%95Mac-Panel%E9%A3%8E%E6%A0%BC%E4%BB%A3%E7%A0%81%E5%9D%97%E9%85%8D%E7%BD%AE/">Hexo+NexT美化🍕Mac Panel风格代码块配置 | 樱井喵 (miaosakurai.com)</a></a></p><hr><h3 id="如何添加-标签云模块-博客背景-搜索功能-模块？"><a href="#如何添加-标签云模块-博客背景-搜索功能-模块？" class="headerlink" title="如何添加 标签云模块 |博客背景 |搜索功能 模块？"></a>如何添加 标签云模块 |博客背景 |搜索功能 模块？</h3><p>推荐博主：<a><a href="https://vic.kim/">归档 | Vicの博客</a></a></p><p><strong>补充：标签云至少存在两个标签才会生效显示</strong></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java课设总结</title>
      <link href="/2021/11/18/JavaFX/"/>
      <url>/2021/11/18/JavaFX/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="内容要求"><a href="#内容要求" class="headerlink" title="内容要求"></a>内容要求</h3><ol><li><strong>内容：开发一个简易的幻灯片制作与播放软件</strong></li><li><strong>基本功能：</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">新建幻灯片，幻灯片由不少于一个页面组成</span><br><span class="line">新建一个空白的幻灯片页面</span><br><span class="line">打开或保存整个幻灯片</span><br><span class="line">在幻灯片页面上绘制基本图形</span><br><span class="line">在幻灯片页面上绘制任意直线</span><br><span class="line">添加文字</span><br><span class="line">设定颜色与文字风格</span><br><span class="line">对幻灯片页面上已有的基本图形、线形、文字进行选取和移动</span><br><span class="line">通过鼠标拖动完成上述绘制和添加文字等操作</span><br></pre></td></tr></table></figure><ol><li><strong>选作功能：</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">幻灯片的全屏播放、翻页</span><br><span class="line">设定画笔、插入图像、修改图像（使用橡皮擦）</span><br><span class="line">图形填充、线型设置</span><br><span class="line">对幻灯片页面上已有的基本图形、线性、文字进行修改</span><br><span class="line">操作的撤销与重组</span><br><span class="line">菜单</span><br><span class="line">简易的JDBC连接MySQL数据库实现用户登录</span><br></pre></td></tr></table></figure><hr><h3 id="帮助文档"><a href="#帮助文档" class="headerlink" title="帮助文档"></a>帮助文档</h3><ol><li><p><strong>开发环境和插件选择</strong>：</p><p><code>Gradle + JavaFx + JPoneiX + JDK 1.8 + Spire.Presentation + IDEA </code></p><p>说明：</p><ol><li>按照 <code>non-modular + idea</code> 使用 JavaFx，会带来配置修改问题</li><li>使用 <code>JPoneiX</code> 开源项目优化 UI 界面，更加美观和方便</li><li>使用<code>Gradle</code>管理项目更加方便，兼容性更好</li></ol></li><li><p><strong>本人项目地址：</strong></p><p>GitHub：<a><a href="https://github.com/Eminem-x/JFoenix">https://github.com/Eminem-x/JFoenix</a></a></p></li></ol><ol start="2"><li><p><strong>JavaFX的基本操作指南：</strong></p><ol><li>官方文档: <a><a href="https://openjfx.io/">https://openjfx.io/</a></a><ul><li>基本内容以及示例说明</li><li>JavaFX的doc文档说明 </li></ul></li><li>WiKi教程: <a><a href="https://iowiki.com/javafx/javafx_images.html">https://iowiki.com/javafx/javafx_images.html</a></a></li><li>JavaFX和FXML的关系阐述： <a><a href="https://blog.csdn.net/theonegis/article/details/50181339">https://blog.csdn.net/theonegis/article/details/50181339</a></a></li></ol></li><li><p><strong>Java操作PPT的免费非开源组件:</strong></p><ol><li><p>官方网址：<a>冰蓝科技 PowerPoint 组件<a href="https://www.e-iceblue.cn/">https://www.e-iceblue.cn/</a></a></p></li><li><p>说明：</p><ol><li><p>此组件目前没有免费开源，会带有水印，不过不影响整体的实现，</p><p>可以通过适当操作，去掉水印的显示；</p></li><li><p>另外官方没有Gradle方式添加到工程，附上Gradle如何添加本地外包的方法：<br> <a href="https://blog.csdn.net/m1213642578/article/details/52763130?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link">Gradle添加本地外包</a></p></li></ol></li></ol></li><li><p><strong>JavaFX实现绘图功能的项目：</strong></p><ol><li>GitHub链接：<a><a href="https://github.com/FlyuZ/FYDrawing-JAVAFX">https://github.com/FlyuZ/FYDrawing-JAVAFX</a></a></li><li>可以参考实现方法，按照需求更改</li></ol></li><li><p><strong>JPoneiX开源项目：</strong></p><ol><li>GitHub链接：<a href="https://github.com/sshahine/JFoenix">https://github.com/sshahine/JFoenix</a></li><li>官方doc文档：<a><a href="https://javadoc.io/doc/com.jfoenix/jfoenix/latest/overview-summary.html">https://javadoc.io/doc/com.jfoenix/jfoenix/latest/overview-summary.html</a></a></li><li>此开源项目美化了JavaFx的组件UI，并且提供了许多便于使用和操作的组件</li></ol></li><li><p><strong>可用 Icon 的选取：</strong></p><ol><li>样式链接：<a><a href="https://fontawesome.com/v5.15/icons?d=gallery&amp;p=4&amp;s=solid&amp;m=free">https://fontawesome.com/v5.15/icons?d=gallery&amp;p=4&amp;s=solid&amp;m=free</a></a></li><li>使用时在 <code>Extern Libraries</code>下寻找此插件的 <code>solid</code>样式，然后相应位置替换即可</li><li>其他图片可能会失效，尝试即可，推荐使用 <code>solid</code></li></ol></li></ol><hr><h3 id="项目演示"><a href="#项目演示" class="headerlink" title="项目演示"></a>项目演示</h3><ol><li><p>文件结构：</p><p><img src="java%E8%AF%BE%E8%AE%BE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="文件结构"></p></li><li><p>项目运行效果：</p><p><img src="java%E8%AF%BE%E8%AE%BE%E6%95%88%E6%9E%9C%E5%9B%BE1.png" alt="主界面"></p><p><img src="java%E8%AF%BE%E8%AE%BE%E6%95%88%E6%9E%9C%E5%9B%BE2.png" alt="画图"></p><p><img src="java%E8%AF%BE%E8%AE%BE%E6%95%88%E6%9E%9C%E5%9B%BE3.png" alt="放映"></p></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 课程设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
