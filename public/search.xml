<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>泛型机制和实现</title>
      <link href="/2022/04/21/%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/04/21/%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6%E5%92%8C%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p>最近在重新学习数据结构，因为以前总是停留在概念，只知道如何使用，但不清楚具体的实现机制，</p><p>于是想着借此机会阅读 <code>JDK</code> 源码，另外尝试自己实现一个简单的 <code>JDK</code> ，巩固基础并且深入学习。</p><p>学习过程中也捡起了放置了很久的一本书《数据结构与算法分析 Java 版》，因为以前基础比较薄弱，</p><p>并且缺少练习，导致对书中很多概念模糊不清，花费将近半天时间，重新阅读了<strong>泛型</strong>这一小节，</p><p>纸上得来终觉浅，绝知此事要躬行，因此在阅读过程中，也将一些地方，用代码实现了一遍。</p><p><em>（代码部分链接如下：<a href="https://github.com/Eminem-x/Learning/tree/main/Java/GenericMechanism/src/com/yuanhao">泛型机制和实现代码</a>)</em></p><p>重新学习，收获还是很多的，站在和以前不同的角度去学习，以前书上的一些笔记也得到了解答，</p><p>接下来的内容按照这本书的内容顺序，加上一些个人理解和代码实现来叙述，会忽略一些基础。</p><h3 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h3><h4 id="Object-接口-泛型特性"><a href="#Object-接口-泛型特性" class="headerlink" title="Object + 接口 / 泛型特性"></a>Object + 接口 / 泛型特性</h4><ol><li><p><strong>Object + 接口类型表示泛型</strong></p><p><code>Java</code> 中的基本思想就是可以通过使用像 <code>Object</code> 类这样的超类来实现泛型类，</p><p>不过只有在使用 <code>Object</code> 类中已有的方法能够表示所执行操作的时候，才能采用这种方式，</p><p>因此，可以使用接口类型表示泛型，比如 <code>Comparable</code>，为 <code>Object</code> 提供了一种能力比较对象大小。</p><p>那么不妨简单的构建以上情况，<code>MyInteger1</code> 类实现 <code>Comparable1</code> 接口，并且附上一个测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInteger1</span> <span class="keyword">implements</span> <span class="title">Comparable1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        MyInteger1 t = (MyInteger1) o;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.val - t.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testObjectAndAnyType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 利用 Object 超类实现泛型</span></span><br><span class="line">    MyInteger1 myInteger = <span class="keyword">new</span> MyInteger1();</span><br><span class="line">    MyInteger1 otherInteger = <span class="keyword">new</span> MyInteger1();</span><br><span class="line">    Shape shape1 = <span class="keyword">new</span> Shape();</span><br><span class="line">    System.out.println(myInteger.compareTo(otherInteger));</span><br><span class="line">    <span class="comment">// 运行时会抛出 ClassCastException</span></span><br><span class="line">    System.out.println(myInteger.compareTo(shape1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下图：</p><p><img src="/2022/04/21/%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6%E5%92%8C%E5%AE%9E%E7%8E%B0/object.png"></p></li><li><p><strong>泛型特性实现泛型</strong></p><p><code>Java 5</code> 支持泛型类，当指定一个泛型类时，类的声明则包含一个或多个类型参数，位于 <code>&lt;&gt;</code> 内，</p><p>与 <code>Object</code> 类不同的是，如果在给定一个参数类型以后，尝试传递其他参数，那么就会产生编译错误。</p><p>仍然简单构造上述情况，<code>MyInteger2</code> 类实现 <code>Comparable2</code> 接口，并附上一个测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInteger2</span> <span class="keyword">implements</span> <span class="title">Comparable2</span>&lt;<span class="title">MyInteger2</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(MyInteger2 o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.val - o.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testObjectAndAnyType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 利用泛型特性实现泛型</span></span><br><span class="line">    com.yuanhao.MyInteger2 integer2 = <span class="keyword">new</span> com.yuanhao.MyInteger2();</span><br><span class="line">    com.yuanhao.MyInteger2 otherInteger2 = <span class="keyword">new</span> com.yuanhao.MyInteger2();</span><br><span class="line">    com.yuanhao.Shape shape2 = <span class="keyword">new</span> com.yuanhao.Shape();</span><br><span class="line">    System.out.println(integer2.compareTo(otherInteger2));</span><br><span class="line">    <span class="comment">// 传递参数时产生一个编译错误</span></span><br><span class="line">    System.out.println(integer2.compareTo(shape2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译结果如下图：</p><p><img src="/2022/04/21/%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6%E5%92%8C%E5%AE%9E%E7%8E%B0/T.png"></p></li><li><p><strong>对比结果</strong></p><p>不难看出，利用 <code>Java 5</code> 的泛型特性去实现泛型构件，</p><p>避免了以前的运行时错误 <code>ClassCastException</code>，</p><p>通过使类变成泛型类，将运行时才能报告的许多错误，转变为现如今编译时的错误。</p></li></ol><h4 id="数组兼容性-通配符"><a href="#数组兼容性-通配符" class="headerlink" title="数组兼容性 / 通配符"></a>数组兼容性 / 通配符</h4><ol><li><p><strong>协变数组类型</strong></p><p>在介绍这个概念之前，不妨先看一段代码（可以先忽略注释），思考能否通过编译以及运行：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person[] arr = <span class="keyword">new</span> <span class="type">Employee</span>[<span class="number">5</span>]; <span class="comment">// 编译: arrays are compatible</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="type">Student</span>(...);<span class="comment">// 编译: Student IS-A Person</span></span><br></pre></td></tr></table></figure><p>上述代码中，<code>Employee</code> 和 <code>Student</code> 继承自 <code>Person</code>，先说结果：<strong>可编译但会运行错误。</strong></p><p>因为 <code>Employee IS-A Person</code>，因此 <code>Employee[] IS-A Person[]</code>，这似乎是没问题的，</p><p>但是 <code>Student IS-A Person</code>，而 <code>Student IS-NOT-A Employee</code>，这就会产生类型混乱。</p><p><strong>运行时系统不会抛出 <code>ClassCastException</code>，因为不存在类型转换。</strong></p><p>避免这种情况最容易的办法是指定这些数组不是类型兼容的，可是 <code>Java</code> 中数组是兼容的，</p><p>称为<strong>协变数组类型（covariant array type），</strong>其实从多态的角度挺容易理解这个问题的。</p><p>第二段代码中，编译时没有进行动态绑定，不清楚是 <code>Person</code> 还是 <code>Employee</code>，所以运行出错，</p><p><strong>如果将一个不兼容的类型插入到数组中，那么虚拟机将抛出 <code>ArrayStoreException</code> 异常。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Shape[] arr = <span class="keyword">new</span> Square[<span class="number">5</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="keyword">new</span> Circle();</span><br></pre></td></tr></table></figure><p><img src="/2022/04/21/%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6%E5%92%8C%E5%AE%9E%E7%8E%B0/ASE.PNG"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = <span class="keyword">new</span> Square[] &#123;<span class="keyword">new</span> Circle()&#125;; <span class="comment">// Incompatible types. Found: &#x27;Circle&#x27;, required: &#x27;Square&#x27;</span></span><br></pre></td></tr></table></figure><p>如果再深入思考一点，可以发现这样声明时，就会出现编译报错，恰恰验证了从多态角度考虑的正确性。</p></li><li><p><strong>带有限制的通配符</strong></p><p>因为使用泛型的全部原因就在于产生编译器错误而不是运行时异常，所以泛型集合是不可协变的，</p><p>因此不能传递类型不同的参数，但是这样一来，就使得代码失去了灵活性，对用户而言不太友好，</p><p><strong>因此，<code>Java 5 </code> 用通配符（wildcard） 来弥补这个不足，其用来表示参数类型的子类或超类。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCovariant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Shape&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Square&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    System.out.println(totalArea(list1));</span><br><span class="line">    System.out.println(totalArea(list2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Collection&lt;Shape&gt; 不加通配符就会产生编译错误</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">totalArea</span><span class="params">(Collection&lt;? extends Shape&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Shape s : arr) &#123;</span><br><span class="line">        total += s.test();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="类型限界"><a href="#类型限界" class="headerlink" title="类型限界"></a>类型限界</h4><p>类型限界的概念其实还是蛮好理解的，就是限制参数类型，但是比较难理解的地方是改进的做法。</p><p><code>findMax</code> 是一个泛型方法，需要对参数执行 <code>compareTo</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不合法 编译出错 不能运行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">findMax</span><span class="params">(T[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>].compareTo(arr[<span class="number">1</span>]) == <span class="number">0</span> ? arr[<span class="number">0</span>] : arr[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不对 <code>&lt;T&gt;</code> 添加类型限制，编译器不能证明 <code>arr[0]</code> 对 <code>compareTo</code> 方法调用是合法的，所以编译错误。</p><p><strong>因此需要类型限界（type bound）解决这个问题，类型限界在尖括号内指定，指定参数必须具有的性质。</strong></p><p>因此可以对代码进行修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以运行 但会 warning</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">T <span class="title">findMax</span><span class="params">(T[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>].compareTo(arr[<span class="number">1</span>]) == <span class="number">0</span> ? arr[<span class="number">0</span>] : arr[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法看起来很自然，但是在 <code>IDEA</code> 编译器下，会报出 <code>warning</code>，但不影响运行，</p><p>可以参考这篇回答：<a href="https://stackoverflow.com/questions/4830400/java-unchecked-call-to-comparetot-as-a-member-of-the-raw-type-java-lang-compa">关于 <code>&lt;T extends Comparable&gt;</code> warning</a>，其中有一个回答：</p><blockquote><blockquote><p>In essence, this warning says that <code>Comparable</code> object can’t be compared to arbitrary objects. <code>Comparable&lt;T&gt;</code> is a generic interface, where type parameter <code>T</code> specifies the type of the object this object can be compared to.</p><p>So, in order to use <code>Comparable&lt;T&gt;</code> correctly, you need to make your sorted list generic, to express a constraint that your list stores objects that can be compared to each other, something like this:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortedList</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;? <span class="title">super</span> <span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T obj)</span> </span>&#123; ... &#125;</span><br><span class="line">   ...</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote><p>这个回答和书上后续的补充是对应的，那么接着修改上述代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// warning 消失</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function">T <span class="title">findMax</span><span class="params">(T[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>].compareTo(arr[<span class="number">1</span>]) == <span class="number">0</span> ? arr[<span class="number">0</span>] : arr[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>那么为何还会出现 <code>&lt;T extends Comparable&lt;? super T&gt;&gt;</code> 这种形式的类型界限呢？</strong></p><p>为了看清楚这个问题，编写一段代码：</p><p>( <code>Square</code> 是 <code>Shape</code> 的子类，并且 <code>Shape</code> 实现 <code>Comparable&lt;Shape&gt;</code>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 这两段代码都可以通过编译并且正常运行</span></span><br><span class="line">    Shape[] arr1 = <span class="keyword">new</span> Square[<span class="number">5</span>];</span><br><span class="line">    arr1[<span class="number">0</span>] = <span class="keyword">new</span> Square();</span><br><span class="line">    arr1[<span class="number">1</span>] = <span class="keyword">new</span> Square();</span><br><span class="line">    System.out.println(findMax(arr1));</span><br><span class="line"></span><br><span class="line">    Square[] arr2 = <span class="keyword">new</span> Square[<span class="number">5</span>];</span><br><span class="line">    arr2[<span class="number">0</span>] = <span class="keyword">new</span> Square();</span><br><span class="line">    arr2[<span class="number">1</span>] = <span class="keyword">new</span> Square();</span><br><span class="line">    System.out.println(findMax(arr2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function">T <span class="title">findMax</span><span class="params">(T[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里可以打印类, 确认无误</span></span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>].compareTo(arr[<span class="number">1</span>]) == <span class="number">0</span> ? arr[<span class="number">0</span>] : arr[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>此时，我们所知道的只是 <code>Square</code> 实现 <code>Comparable&lt;Shape&gt;</code>，</strong></p><p><strong>于是 <code>Square IS-A Comparable&lt;Shape&gt;</code>，</strong>这在前面也解释过，</p><p><strong>但是 <code>Square IS-NOT-A Comparable&lt;Square&gt;</code>，这看起来合情合理，可放到代码里确实费解的。 </strong></p><p><strong>因此对类型界限再加修饰：<code>&lt;T extends Comparable&lt;? super T&gt;&gt;</code></strong>。</p><h4 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h4><p>泛型在很大程度上是 <code>Java</code> 语言中的成分而不是虚拟机中的结构。</p><p>泛型类可以由编译器通过所谓的<strong>类型擦除（type erase）</strong>过程而转变成非泛型类，</p><p>这样，编译器就生成一种与泛型类同名的<strong>原始类（raw object）</strong>，但是参数类型都被删去了。</p><p>类型变量由它们的类型界限来代替，当一个具有擦除返回类型的泛型方法被调用的时，一些特性被自动地插入。</p><p>类型擦除的一个重要结论是，所生成的代码与程序员在泛型之前所写的代码并没有太多的差异，</p><p>而且事实上运行的也并不快，优点在于，程序员不比类型转换，交给编译器类型检验。</p><p>更深层的细节参考博客：<a href="https://www.cnblogs.com/wuqinglong/p/9456193.html">https://www.cnblogs.com/wuqinglong/p/9456193.html</a></p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>除上述描述的一些概念以外，还有一些细枝末节，就不再赘述，比如泛型的使用或者方式等等，</p><p>当然也是重要的部分，不过这部分就不是细节方面的问题了，但是还是补充一点，关于 <code>static</code> 泛型。</p><p>个人感觉 <code>static</code> 所带来的问题，一律带到它是静态的，是类的属性而不是成员，就往往自洽了，</p><p>因为类的属性先加载而成员需要运行时，所以从这个角度分析问题，就不需要死记硬背了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树状数组</title>
      <link href="/2022/04/12/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
      <url>/2022/04/12/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p>树状数组用起来很简单，但是比较难理解，不过网上资源比较多，在此加上自身理解整合一下。</p><p><em>（具体参考的博客文章附在下文中）</em></p><h4 id="起源与介绍"><a href="#起源与介绍" class="headerlink" title="起源与介绍"></a>起源与介绍</h4><p>树状数组或二元索引树（Binary Indexed Tree），又以其发明者命为 Fenwick 树，</p><p>初衷是用来解决数据压缩里的累计频率（Cumulative Frequency）的计算问题，</p><p>现多用于高效计算数列的前缀和、区间和（下面附有一些相关题目），</p><p>时间复杂度为 O(logn)，二进制在算法中的使用，有时使得时间复杂度降到与 <code>n</code> 的二进制中的 <code>1</code> 相关。</p><p>具体内容参考 paper： <a href="https://static.aminer.org/pdf/PDF/001/073/976/a_new_data_structure_for_cumulative_frequency_tables.pdf">A New Data Structure for Cumulative Frequency Tables (aminer.org)</a></p><h4 id="使用情景"><a href="#使用情景" class="headerlink" title="使用情景"></a>使用情景</h4><p>可以解决大部分基于区间上的更新以及求和问题</p><p>相关题目：</p><p><a href="https://leetcode-cn.com/problems/range-sum-query-mutable/">307. 区域和检索 - 数组可修改 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p><a href="https://leetcode-cn.com/problems/range-sum-query-2d-mutable/">308. 二维区域和检索 - 可变 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>下面几题实质为偏序问题，树状数组是针对偏序问题的常用解法之一：</p><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51. 数组中的逆序对 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p><a href="https://leetcode-cn.com/problems/range-sum-query-2d-mutable/">308. 二维区域和检索 - 可变 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p><a href="https://leetcode-cn.com/problems/reverse-pairs/">493. 翻转对 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">315. 计算右侧小于当前元素的个数 - 力扣（LeetCode） (leetcode-cn.com)</a></p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>修改和查询的时间复杂度都是 O(logn)，而且相比线段树系数要少很多，比传统数组要快，而且容易写。</p><p>但是遇到复杂的区间问题还是不能解决，功能还是有限。</p><h4 id="参考博客："><a href="#参考博客：" class="headerlink" title="参考博客："></a>参考博客：</h4><p>推荐这一篇：<a href="https://blog.csdn.net/flushhip/article/details/79165701">(30条消息) 树状数组简单易懂的详解_FlushHip的博客-CSDN博客_树状数组</a></p><p>剩下两篇辅助理解：</p><p><a href="https://www.cnblogs.com/xenny/p/9739600.html">树状数组详解 - Xenny - 博客园 (cnblogs.com)</a></p><p><a href="https://www.cnblogs.com/Last--Whisper/p/13823614.html#bit-%E7%9A%84%E5%8E%9F%E7%90%86">树状数组（BIT）—— 一篇就够了 - Last_Whisper - 博客园 (cnblogs.com)</a></p><p>相关题目以及其他方法：</p><p><a href="https://leetcode-cn.com/circle/article/P92uug/">前缀和、差分、树状数组、块状数组 - 力扣（LeetCode） (leetcode-cn.com)</a></p><hr><h3 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h3><h4 id="lowbit-函数"><a href="#lowbit-函数" class="headerlink" title="lowbit 函数"></a>lowbit 函数</h4><p>树状数组需要用到的一个 function，作用是求某一个数的二进制表示中最低的一位 <code>1</code>。</p><p>举个例子，<code>x = 6</code>，它的二进制为 <code>110</code>，那么 <code>lowbit(x) </code>就返回<code>2</code>，因为最后一位 <code>1</code> 表示 <code>2</code>。</p><p><strong>具体的实现有两种写法：<code>x - (x &amp; (x - 1))</code> 或者 <code>x &amp; -x;</code>，</strong>根据数学知识简单论证即可。</p><h4 id="树状数组的思想"><a href="#树状数组的思想" class="headerlink" title="树状数组的思想"></a>树状数组的思想</h4><p>按照 Peter M.Fenwick 的说法，BIT 的产生源自整数与二进制的类比。</p><blockquote><p>Each integer can be represented as sum of powers of two. In the same way, cumulative frequency can be represented as sum of sets of subfrequencies. In our case, each set contains some successive number of non-overlapping frequencies.</p></blockquote><p>实际上，BIT 也是采用类似的想法，将序列和类比为整数的二进制拆分，举个例子：</p><p>一个数 <code>n = 6 </code>，它的二进制为 <code>110</code>，我们将其表示成累加的形式：<code>110 = 100 + 10</code>，</p><p>这种拆分的形式恰好可以借助前文提到的 <code>lowbit</code> 方法，那么如何映射到序列和呢？</p><br><p>假设序列以数组 <code>a</code> 表示，那么前六项的前缀和为： <code>sum[6] = a1 + a2 + a3 + a4 + a5 + a6</code>；</p><p>按照上述二进制拆分的形式去拆分可以得到：<code>sum[6] = (a1 + a2 + a3 + a4) + (a5 + a6)</code>；</p><br><p><strong>那么树状数组是怎么处理的呢？</strong>其定义了一个数组 <code>tree</code>，</p><p><code>tree[i]</code> 表示从第 <code>i</code> 个元素向前数 <code>lowbit(i)</code> 个元素，这一段的和。</p><p>那么上述的前缀和可以按照这种形式表示成：<code>sum[6] = tree[4] + tree[6]</code>。</p><p>按照这种形式，我们可以表示出来任意区间的前缀和，但是该如何更新呢？</p><br><p>在介绍如何更新之前，先结合树状数组的经典图，来具体了解其相关性质。</p><p><img src="/2022/04/12/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84.png"></p><p>（简要陈述图片含义，横坐标表示具体的序列，纵坐标表示层数，矩形表示 <code>tree[i]</code> 包含元素）</p><p><strong>由这张图，可以得到树状数组的以下性质：</strong></p><ul><li><p>后缀和的长度是2的幂；</p></li><li><p>上一层后缀和的长度是下一层后缀和长度的两倍；</p></li><li><p>下一层后缀和只要补上自己后缀和的长度就可以得到上面层的后缀和(图中的虚框框)，</p><p>注意，是上面的后缀和，而不是上一层的后缀和，这个性质就是更新操作的依据；</p></li><li><p>最后一位 1 右边有多少个 0 (可以用 <code>log2(lowbit(x)</code> )，</p><p>就表示这一层有多少个直系子层(子层的意思就是这一层的和包含下面某一层的和)。</p></li></ul><br><p><strong>结合求区间和的方式以及性质，可以推出，更新时只要更新修改这个点会影响到的 <code>tree</code> 即可。</strong></p><p>那么如何得到影响的 <code>tree</code>，结合性质三显而易见，<code>x += lowbit(x)</code> 即可。</p><br><p><strong>既然已经陈述了其方法和思想，那么回到名字上，为什么命名为树状数组呢？</strong></p><p>让我们回到最开始介绍此数据结构的 paper 里，可以看到下面两张图：</p><p> <img src="/2022/04/12/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/paper1.png"></p><p> <img src="/2022/04/12/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/paper2.png"></p><p>由这两张图可以看到，数组转化为树形结构，只不过省略了一些结点，有兴趣可以钻研一下。</p><h4 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BIT</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BIT</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] tree;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BIT</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="keyword">int</span>[length + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt; tree.length; i += lowbit(i)) &#123;</span><br><span class="line">            tree[i] += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            sum += tree[x];</span><br><span class="line">            x -= lowbit(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 树状数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闫氏分析法</title>
      <link href="/2022/04/06/%E9%97%AB%E6%B0%8F%E5%88%86%E6%9E%90%E6%B3%95/"/>
      <url>/2022/04/06/%E9%97%AB%E6%B0%8F%E5%88%86%E6%9E%90%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span><escape></escape></escape></p><h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p>此方法由闫学灿推出，链接：<a href="https://www.bilibili.com/video/BV1X741127ZM?spm_id_from=333.337.search-card.all.click">闫氏DP分析法，从此再也不怕DP问题！_哔哩哔哩_bilibili</a> 观看学习。</p><p>为 dp 问题提供了可供按照惯例的方式去解决，采用集合划分的思想，</p><p>但是需要大量的练习和总结，才能去快速解决此类问题，此类问题也有很多变形，</p><p>包括：背包问题、线性DP、区间DP、计数类DP、数位统计DP、状态压缩DP、树形DP等。</p><p><img src="/2022/04/06/%E9%97%AB%E6%B0%8F%E5%88%86%E6%9E%90%E6%B3%95/%E6%A6%82%E8%BF%B0.png"></p><p>主要思路：</p><ol><li>问题一般是求有限集合中的最优集合；</li><li>因此化零为整，抽象出状态表示，包括集合和属性，这一步需要大量的练习；</li><li>随后化整为零，寻找集合之间的最后一个不同点，求出状态转移方程；</li><li>不同类型的 dp 问题都可以以此来求解，但是细节有所不同；</li></ol><p>也是听了这节视频以及整个 AcWing 平台题目的紧凑性，尤其是对 LCS 的讲解，</p><p>使得我豁然开朗，也让我决定在此平台不断学习算法。</p><hr><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h4><p>问题详细描述：<a href="https://www.acwing.com/problem/content/2/">2. 01背包问题 - AcWing题库</a></p><p>按照上述思路进行分析：</p><p><img src="/2022/04/06/%E9%97%AB%E6%B0%8F%E5%88%86%E6%9E%90%E6%B3%95/01%E8%83%8C%E5%8C%85.png"></p><p>代码如下（未优化）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.math.*; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">int</span> N = in.nextInt();</span><br><span class="line">            <span class="keyword">int</span> V = in.nextInt();</span><br><span class="line">            <span class="keyword">int</span>[][] objects = <span class="keyword">new</span> <span class="keyword">int</span>[N][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                objects[i][<span class="number">0</span>] = in.nextInt();</span><br><span class="line">                objects[i][<span class="number">1</span>] = in.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println((<span class="keyword">new</span> Main()).solution(N, V, objects));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> V, <span class="keyword">int</span>[][] objects)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][V + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= V; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = objects[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> w = objects[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (j - v &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - v] + w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N][V];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h4><p>问题详细描述：<a href="https://www.acwing.com/problem/content/3/">3. 完全背包问题 - AcWing题库</a></p><p>按照上述思路进行分析：</p><p><img src="/2022/04/06/%E9%97%AB%E6%B0%8F%E5%88%86%E6%9E%90%E6%B3%95/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.png"></p><p>代码如下（未优化）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.math.*; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">int</span> N = in.nextInt();</span><br><span class="line">            <span class="keyword">int</span> V = in.nextInt();</span><br><span class="line">            <span class="keyword">int</span>[][] objects = <span class="keyword">new</span> <span class="keyword">int</span>[N][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                objects[i][<span class="number">0</span>] = in.nextInt();</span><br><span class="line">                objects[i][<span class="number">1</span>] = in.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println((<span class="keyword">new</span> Main()).solution(N, V, objects));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> V, <span class="keyword">int</span>[][] objects)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][V + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= V; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = objects[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> w = objects[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (j - k * v &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - k * v] + w * k);</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N][V];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h4><p>问题详细描述：<a href="https://www.acwing.com/problem/content/3/"><a href="https://www.acwing.com/problem/content/284/">282. 石子合并 - AcWing题库</a></a></p><p><strong>该题是区间DP</strong>，依然按照上述思路进行分析：</p><p><img src="/2022/04/06/%E9%97%AB%E6%B0%8F%E5%88%86%E6%9E%90%E6%B3%95/%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6.png"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.math.*; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">int</span> N = in.nextInt();</span><br><span class="line">            <span class="keyword">int</span>[] objects = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                objects[i] = in.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println((<span class="keyword">new</span> Main()).solution(N, objects));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span>[] objects)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] sum = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">            sum[i + <span class="number">1</span>] = sum[i] + objects[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][N + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= N; len++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= N; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = Integer.MAX_VALUE; </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; k++) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k + <span class="number">1</span>][j] + sum[j] - sum[i - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h4><p>问题详细描述：<a href="https://www.acwing.com/problem/content/3/"><a href="https://www.acwing.com/problem/content/899/">897. 最长公共子序列 - AcWing题库</a></a></p><p>按照上述思路进行分析：</p><p><img src="/2022/04/06/%E9%97%AB%E6%B0%8F%E5%88%86%E6%9E%90%E6%B3%95/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.png"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.math.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = in.nextInt();</span><br><span class="line">            <span class="keyword">int</span> m = in.nextInt();</span><br><span class="line">            String s1 = in.next();</span><br><span class="line">            String s2 = in.next();</span><br><span class="line">            System.out.println(<span class="keyword">new</span> Main().getLcs(s1, s2));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLcs</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s1.length();</span><br><span class="line">        <span class="keyword">int</span> m = s2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (s1.charAt(i - <span class="number">1</span>) == s2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀树</title>
      <link href="/2022/03/24/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
      <url>/2022/03/24/%E5%AD%97%E5%85%B8%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span><escape></escape></escape></p><h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p><strong><code>Trie</code> （发音类似 try）前缀树</strong>，一种树形数据结构，用于高效地存储和检索字符串数据集中的键，</p><p>有相当多地应用情景：自动补全和拼写检查，又称为<strong>字典树</strong>，实质上是 <strong>N叉树</strong> 的一种特殊形式。</p><p>相关题目推荐：</p><ul><li><p><a href="https://leetcode-cn.com/problems/concatenated-words/">472. 连接词 - 力扣（LeetCode） (leetcode-cn.com)</a></p></li><li><p><a href="https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/">440. 字典序的第K小数字 - 力扣（LeetCode） (leetcode-cn.com)</a></p></li></ul><hr><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Trie[] children;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        children = <span class="keyword">new</span> Trie[<span class="number">26</span>];</span><br><span class="line">        isEnd = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Trie node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = word.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> index = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.children[index] = <span class="keyword">new</span> Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Trie node = searchPrefix(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="keyword">null</span> &amp;&amp; node.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> searchPrefix(prefix) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Trie <span class="title">searchPrefix</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        Trie node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = prefix.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> index = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文章开始处的两个链接，前者直接应用到字典树，而后者间接用到字典树，</p><p>都给出了非常巧妙地解法，<strong>尤其是后者如何层序遍历得出字典树结点数目，非常精彩。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RBAC</title>
      <link href="/2022/03/23/RBAC/"/>
      <url>/2022/03/23/RBAC/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p>在最近学习的一个项目中，涉及到了权限管理，其所采用的是主流的 RBAC 模型，</p><p>RBAC(Role-Based Access Control) 基于角色的访问控制，不过根据业务的需要会有不同的变形，</p><p>查阅了一些文章和项目文档，认真总结 RBAC 模型的相关知识，随着学习再不断补充完善。</p><p>在此之前，需要阐述一个问题：<strong>为什么需要权限管理或者说角色权限系统？</strong></p><p>最主要的原因是系统存在不同权限的用户，而根据业务要求的不同，</p><p>每个用户使用的功能、查看的内容是不同的，</p><p>在接下来的示例中，也会体现这一点。</p><hr><h3 id="1-什么是-RBAC-模型"><a href="#1-什么是-RBAC-模型" class="headerlink" title="1. 什么是 RBAC 模型"></a>1. 什么是 RBAC 模型</h3><p>Role-Based Access Control：基于角色的访问控制：</p><p>通过角色关联用户，角色关联权限的访问间接赋予用户权限。</p><p><img src="/2022/03/23/RBAC/RBAC-basis.png"></p><p>在该项目中，一个用户拥有若干角色，每一个角色拥有若干个菜单，菜单中存在菜单权限与按钮权限。</p><p><img src="/2022/03/23/RBAC/RBAC.png"></p><p>（从定义和业务中可以看出，该模型是灵活的，重要的是权限控制思想）</p><p><strong>那么为什么不直接给用户分配 permission，而是在二者之间增加 Role 这一环节？</strong></p><p>从逻辑上来说，可以直接给用户分配权限，但如果这样，Coupling 就太强了，降低了 Expansibility，</p><p>适合用户数量、角色类型少的平台，不具有 generality 和 expansibility。</p><p>对于通常的系统，如果对批量的 user permission 调整，只需要调整用户关联的 role permission，</p><p>无需对每一个用户都进行权限调整，既大幅提升权限调整的效率，又降低了漏调权限的概率。</p><hr><h3 id="2-RBAC-模型的分类"><a href="#2-RBAC-模型的分类" class="headerlink" title="2. RBAC 模型的分类"></a>2. RBAC 模型的分类</h3><p>RBAC模型可以分为：RBAC0、RBAC1、RBAC2、RBAC3 四种，</p><p>其中 RBAC0 是基础，相当于底层逻辑，另外三种是以其为基础的拓展，</p><p>一般情况下使用 RBAC0 模型就可以满足常规的权限管理系统设计。</p><ol><li><p><strong>RBAC0</strong></p><p>最简单的 User、Role、Permission 模型，而其又包含两种：</p><ul><li>用户和角色是多对一关系</li><li>用户和角色是多对多关系</li></ul></li><li><p><strong>RBAC1</strong></p><p>基于RBAC0，增加子角色，引入继承概念，即子角色可以继承父角色的所有权限。</p><p><img src="/2022/03/23/RBAC/RBAC1.png"></p></li></ol><p>   使用场景：如某个业务部门有经理、主管、专员。权限等级依次降低，</p><p>   那么可以先创建完经理角色并配置权限后，主管角色继承经理，并删除某些权限。</p><ol start="3"><li><p><strong>RBAC2</strong></p><p>基于RBAC0，增加对 Role 的 restrictions：角色互斥、基数约束、先决条件角色等。</p><ul><li>角色互斥：同一用户不能分配到一组互斥角色集合中的多个角色</li><li>基数约束：一个角色被分配的用户数量有限</li><li>先决条件角色：若想获得更高的权限，首先需要拥有低一级的权限</li><li>运行时互斥：允许用户有多个角色，但在运行中不可同时激活</li></ul></li><li><p><strong>RBAC3</strong></p><p>统一模型：包含 RABC1 和 RABC2。</p></li></ol><hr><h3 id="3-什么是权限"><a href="#3-什么是权限" class="headerlink" title="3. 什么是权限"></a>3. 什么是权限</h3><p>Permission 可以看作是资源的集合，这里的资源指软件中的所有内容，</p><p>包括模块、菜单、页面、字段、操作功能（增删改查）等等，</p><p><strong>可以将权限分为：页面权限、操作权限和数据权限。</strong></p><ol><li><p><strong>Page Permission</strong></p><p>用户能否获取某些页面的菜单或者进入页面。</p></li><li><p><strong>Operation Permission</strong></p><p>用户凡是在操作系统中的任何动作、交互都是操作权限，如增删改查等。</p></li><li><p><strong>Data Permission</strong></p><p>一般业务管理系统，都有数据私密性的要求：哪些人可以看到哪些数据，不可以看到哪些数据</p></li></ol><p>以该项目为例，测试员 test 和 管理员 admin 登录后所拉取的菜单不同：</p><p><img src="/2022/03/23/RBAC/admin.png"></p><p><img src="/2022/03/23/RBAC/test.png"></p><p>而如果 test 想要访问其未拉取的菜单，就会报错，显示未拥有权限：</p><p><img src="/2022/03/23/RBAC/error.png"></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈模拟</title>
      <link href="/2022/03/21/%E6%A0%88%E6%A8%A1%E6%8B%9F/"/>
      <url>/2022/03/21/%E6%A0%88%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="栈模拟"><a href="#栈模拟" class="headerlink" title="栈模拟"></a>栈模拟</h3><span id="more"></span><h4 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h4><p>再学习栈模拟之前，遇到模拟问题，都只会简单的模拟，时间复杂度会很高，</p><p>并且代码量也大，遇到再难一些的特征模拟问题，会束手无策，借着机会，</p><p>引用下面两个题，来整理一下栈模拟的代码：</p><ul><li><p><a href="https://leetcode-cn.com/problems/asteroid-collision/">735. 行星碰撞 - 力扣（LeetCode） (leetcode-cn.com)</a></p></li><li><p><a href="https://leetcode-cn.com/problems/count-collisions-on-a-road/">6028. 统计道路上的碰撞次数 - 力扣（LeetCode） (leetcode-cn.com)</a></p></li></ul><hr><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="行星碰撞"><a href="#行星碰撞" class="headerlink" title="行星碰撞"></a>行星碰撞</h4><p>遍历数组，不妨规定正方向为向右，在题目中即正数，用栈存储，</p><p>如果遇到负数，那么即判断与栈顶元素的碰撞结果，依据题意出栈入栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] asteroidCollision(<span class="keyword">int</span>[] asteroids) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; asteroids.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (asteroids[i] &lt; <span class="number">0</span> &amp;&amp; stack.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">while</span> (stack.size() &gt; <span class="number">0</span> &amp;&amp; stack.peek() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (stack.peek() &gt; Math.abs(asteroids[i])) &#123;</span><br><span class="line">                        flag = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stack.peek() == Math.abs(asteroids[i])) &#123;</span><br><span class="line">                        flag = <span class="keyword">false</span>;</span><br><span class="line">                        stack.pop();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        stack.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    stack.push(asteroids[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(asteroids[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[stack.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = ans.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            ans[i] = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(N)<br>&amp;空间复杂度:O(N)<br>\end{align}<br>$$</p><hr><h4 id="统计道路上的碰撞次数"><a href="#统计道路上的碰撞次数" class="headerlink" title="统计道路上的碰撞次数"></a>统计道路上的碰撞次数</h4><p>栈模拟思路与上述相似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countCollisions</span><span class="params">(String directions)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; directions.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = directions.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (stack.size() &gt; <span class="number">0</span> &amp;&amp; stack.peek() == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">                        ans++;</span><br><span class="line">                        stack.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans++;</span><br><span class="line">                    stack.push(<span class="string">&#x27;S&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;S&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (stack.size() &gt; <span class="number">0</span> &amp;&amp; stack.peek() == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(<span class="string">&#x27;S&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>另外一种解法，偏向于思考：</strong></p><p>道路两端向左向右的车必定不会发生碰撞，而其内部的车一定会碰撞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countCollisions</span><span class="params">(String directions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = directions.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; directions.charAt(left) == <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; directions.charAt(right) == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (directions.charAt(i) == <span class="string">&#x27;L&#x27;</span> || directions.charAt(i) == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 模拟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯经典题目</title>
      <link href="/2022/03/16/%E5%9B%9E%E6%BA%AF%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/"/>
      <url>/2022/03/16/%E5%9B%9E%E6%BA%AF%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><span id="more"></span><h4 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h4><p>回溯解法很好理解，我个人觉得是对解空间的一种遍历，但是会进行一些判断，</p><p>当不满足相应条件时，返回上一状态，向其他状态重复上述状态，直至得解，</p><p>但是回溯和 BFS 其实并不一样，起初我对二者有些混淆，</p><p>后来经过练习和理解，也逐渐了解二者的区别，这篇文章主要列出以下问题，</p><ul><li><a href="https://leetcode-cn.com/problems/subsets/">子集Ⅰ</a></li><li><a href="https://leetcode-cn.com/problems/subsets-ii/">子集Ⅱ</a></li><li><a href="https://leetcode-cn.com/problems/combinations/">组合</a></li><li><a href="https://leetcode-cn.com/problems/permutations/">全排列</a></li></ul><p>以上问题均来源于 LeetCode</p><hr><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>上面四个问题都可以用回溯去解决，不同的地方在于回溯的终止条件，</p><p>以组合为例，只需要当前存储数值达到要求即可返回，</p><p>而对于排列，不需要判断当前包含的数目，只需要判断是否达到末尾即可。</p><p>当然，还有一些细节，代码如下：</p><p><strong>全排列</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; output = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            output.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        backtrack(n, output, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> n, List&lt;Integer&gt; output, List&lt;List&lt;Integer&gt;&gt; res, <span class="keyword">int</span> first)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 所有数都填完了</span></span><br><span class="line">        <span class="keyword">if</span> (first == n) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(output));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 动态维护数组</span></span><br><span class="line">            Collections.swap(output, first, i);</span><br><span class="line">            <span class="comment">// 继续递归填下一个数</span></span><br><span class="line">            backtrack(n, output, res, first + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 撤销操作</span></span><br><span class="line">            Collections.swap(output, first, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>组合</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        dfs(<span class="number">1</span>, n, k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> curr, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// short</span></span><br><span class="line">        <span class="keyword">if</span> (temp.size() + n - curr + <span class="number">1</span> &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (temp.size() == k) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// select curr</span></span><br><span class="line">        temp.add(curr);</span><br><span class="line">        dfs(curr + <span class="number">1</span>, n, k);</span><br><span class="line">        <span class="comment">// unselect curr</span></span><br><span class="line">        temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">        dfs(curr + <span class="number">1</span>, n, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度的分析比较复杂，详情可以参考原题官方的推论</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试感悟</title>
      <link href="/2022/03/15/%E9%9D%A2%E8%AF%95%E6%84%9F%E6%82%9F/"/>
      <url>/2022/03/15/%E9%9D%A2%E8%AF%95%E6%84%9F%E6%82%9F/</url>
      
        <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h4 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h4><p>不知道从哪里开始叙述我的感受，酝酿了片刻，觉得还是从头说起吧，</p><p>2019 年步入大学，那时候的我还什么都不会，对计算机怀有憧憬和热血，</p><p>当时也下定决心要去读研究生，可随着学习和生活的步调越来越大，</p><p>尤其是疫情，可以说疫情改变了我对最开始的计划，疫情那一年，</p><p>我和我女朋友分开了，并且控制力比较差，导致绩点猛滑，大概率无缘保研，</p><p>等到了开学，浑浑噩噩的我，每天只学习一些基础知识，就沉浸在打游戏的生活中，</p><p>但是也是在这漫长的时间里，我明白了我想要的生活是什么样的，于是决定工作，</p><p>破釜沉舟的决心吧，所以当真的做下这个决定后，每天都处于紧绷状态，</p><p>不愿意失败，也不甘心失败，也是在这个时候，我和我女朋友复合了，</p><p>仿佛一切都有了方向，于是我压制自己的惰性去学习，去准备工作，</p><p>2022年，我抱着试试的态度，投了字节的暑期实习后端开发岗位，</p><p>没想到过了笔试也过了三轮面试，写下这篇文章的明天就是 HR 面了，</p><p>但我并没有那种很开心的喜悦，反而更多的是沉默和思考，</p><p>这些就放到余下的篇幅里去描述吧，但我不打算去记录面试的问题，</p><p>而是去记录面试以及面试后带给我的思考。</p><hr><h3 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h3><ol><li><h4 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h4><p>最大的感触就是，自己对一些底层技术，仅仅只是了解，或者说只是记忆，</p><p>因为为了准备面试，不得已加快学习进度，去学习一些项目，走马观花，</p><p>不仅导致基础不牢，甚至项目框架部分也是摇摇欲坠，仅仅会用，</p><p>我感到不安，感到羞愧，所以在这一面结束后，我就下定决心要去花时间巩固，</p><p>重要的不是学了多久，而是如何学习，code less，code smart，</p><p>而最让我懊悔的是，在反问环节，<strong>我问面试官如何看待八股文</strong>，</p><p>尽管才过去不到一星期，但是每天我都饱受因为我的自以为是，</p><p>问出这种愚蠢的问题，不是说如何看待愚蠢，而是用八股文愚蠢，</p><p>在三轮面试结束后，我深刻意识计算机底层知识的重要性，</p><p>如果再给一次机会，我肯定不会再用这种词汇去侮辱真正智慧的结晶。</p></li><li><h4 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h4><p>反问环节我问面试官：是该继续学习 Java 还是说学习 Go，</p><p>面试官给我一个醍醐灌顶的回答，大概意思就是，</p><p><strong>我从来不认为自己是什么工程师，比如 Java 工程师或者 Go 工程师，</strong></p><p><strong>每一种语言更像是一种工具，用在不同的场景，发挥不同的作用，</strong></p><p>不禁让我想起来大一的 C 语言课上，老师曾说过，你不需要会那么多语言，</p><p>但是一定要一门熟悉吃透的语言，结合这次面试我或许明白了，</p><p>你可以熟练运用一种工具，但是也要结合其他工具，才能盖起大厦，</p><p>所以我决定先继续巩固 Java，在入职之前花时间去学习 Go 以及其他。</p></li><li><h4 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h4><p>仍然是反问环节，不得不感慨，面试带给我的影响远超过面试的结果，</p><p>我问面试官有什么需要学习或者改善的地方，<strong>他说记录博客并且最好用英语，</strong></p><p>首先阅读英语文档是程序员的必备技能，同时也是接触新技术的重要途经，</p><p>而过了几天，我和隔壁寝室的大佬请教学习的过程中，他向我推荐了国外公开课，</p><p>我感到无比的兴奋以及对未来有了新的方向，我很感激这些前辈包括同学，</p><p>对技术和学习方面上的无私传授。</p></li></ol><hr><h3 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h3><p>趁着入职前的三四个月的空档期，把底层知识重新巩固一下，</p><p>并且整理一下过往的学习笔记，Later Equals Never，</p><p>先辈们已经把经验和技巧都传授给后辈了，站在巨人的肩膀上学习的我，</p><p>为什么有借口去安然呢？努力尽力的走下去，不因碌碌无为而悔恨就好。</p><hr><h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><p>2022/3/16 完成 HR 面，苦苦等待了很久没有音讯，最后于 2022/4/7 拿到 offer，</p><p>暂定于 5/10 入职，总体来说还是很开心的，因为还是缺少经验加上自身能力不足，</p><p>没有多投几家公司并且知识储备不足，导致有惊无险地拿到这个名额，算是侥幸吧。</p><p>对于这份实习，我更多的是担心和惶恐，感觉自己本身能力其实是达不到这个高度的，</p><p>希望在入职期间能够提升自身实力和见解，对于整个行业和自身发展有一个更深的把握。</p><p>除此之外，和女朋友在结果出来之前 3/24 分开了，心平气和地互相分开了，</p><p>还是前往原先定的城市，做好自己该做的，可以适当停下脚步，但是不能停止前进。</p>]]></content>
      
      
      <categories>
          
          <category> Thinking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thinking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态压缩</title>
      <link href="/2022/03/15/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
      <url>/2022/03/15/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/</url>
      
        <content type="html"><![CDATA[<h3 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h3><span id="more"></span><h4 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a><strong>Preface</strong></h4><p>在平常刷题的过程中，遇到过几次状态压缩的题目，很多次都因为畏难，没有深入地学习下去，</p><p>后来在竞赛中遇到了相同解法的题目，懊悔以前没有静下心来认真地去思考，</p><p>在学习过后，觉得算法思想其实并不复杂，或许复杂的是难以接受新的事物。</p><p>推荐一篇状态压缩的文章：<a href="https://leetcode-cn.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks/solution/zhuang-ya-dpshi-shi-hou-xue-xi-yi-xia-li-q4mk/">状态压缩学习文章</a></p><p>以及几道常见的题目，均来源于 LeetCode：</p><ul><li><a href="https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets/">统计按位或能得到最大值的子集数目</a></li><li><a href="https://leetcode-cn.com/problems/maximum-number-of-achievable-transfer-requests/"><a href="https://leetcode-cn.com/problems/maximum-number-of-achievable-transfer-requests/">最多可达成的换楼请求数目</a></a></li><li><a href="https://leetcode-cn.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/"><a href="https://leetcode-cn.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/">两个回文子序列长度的最大乘积</a></a></li></ul><p>接下来的篇幅以<strong>两个回文子序列长度的最大乘积</strong>为例子，去阐述状态压缩的思想</p><hr><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>状态压缩其实本质就是一种穷举暴力，不过其好处在于，便于处理问题，</p><p>原本问题的解决需要对原模型求子集，但这是一个不容易处理和记录的方法，</p><p>而状态压缩相当于将每一个子集对应的状态，以二进制数字的方式存储，</p><p>因此状态压缩的基础时间复杂度就是 O(2<sup>n</sup>)，所以数据量一般不会超过 20。</p><p>以该题为例：</p><p>不妨先求出该字符串的所有子序列，然后再判断当前字符串是否为回文串，</p><p>然后与其后的子序列按照题意，进行计算求值，模拟遍历即可。</p><p><strong>其核心代码代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), m = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalindromic(str, i)) &#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, Integer.bitCount(i)&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 模拟便利 返回结果即可</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindromic</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 检查 state 对应的子序列是不是回文串</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 将 left 和 right 对应上 「状态所对应的字符」 位置</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; (state &gt;&gt; left &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; (state &gt;&gt; right &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[left] != s[right]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>而其中最核心的代码，无疑就是如何进行状态压缩以及匹配的那一段，</strong></p><p>更加抽象的代码块如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> len = nums.length;</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">1</span> &lt;&lt; len;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="comment">// 检查当前状态对应的子序列</span></span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>((i &gt;&gt; j &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        list.add(j);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp; 时间复杂度:O(2^n)<br>&amp; 空间复杂度:O(2^n)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 状态压缩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM框架整合</title>
      <link href="/2022/01/31/18-SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/"/>
      <url>/2022/01/31/18-SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="SSM框架整合"><a href="#SSM框架整合" class="headerlink" title="SSM框架整合"></a>SSM框架整合</h2><span id="more"></span><h3 id="1-项目地址"><a href="#1-项目地址" class="headerlink" title="1. 项目地址"></a>1. 项目地址</h3><p>从 GitHub 上 Fork 的项目：<a href="https://github.com/liyifeng1994/ssm/tree/master/src">https://github.com/liyifeng1994/ssm/tree/master/src</a></p><p>并且该项目有详细的整合流程：<a href="https://blog.csdn.net/qq598535550/article/details/51703190">https://blog.csdn.net/qq598535550/article/details/51703190</a></p><p>但是因为是几年前的项目，许多包的版本过时，无法正常启动，所以重新构建了整个项目，</p><p>跟着原作者的流程完成，整体不会出现太难解决的问题，并且该项目并无具体 web实现，</p><p>仅通过 test 测试整体框架的完备性，适合学习框架的设计流程。</p><h3 id="2-更改版本"><a href="#2-更改版本" class="headerlink" title="2. 更改版本"></a>2. 更改版本</h3><ol><li><p>数据库驱动版本：要和自己的数据库版本保持一致</p></li><li><p>c3p0 版本：<a href="https://blog.csdn.net/Peng_Ze_Yu/article/details/81632828">https://blog.csdn.net/Peng_Ze_Yu/article/details/81632828</a></p><p>在 Maven 导入时，更改版本信息，否则报错</p></li><li><p>Spring 版本：5.0.5.RELEASE</p></li><li><p>junit 版本：4.12 避免低版本不支持</p><p>mybatis 以及 mybatis-spring 版本更新</p></li><li><p>entity：<a href="https://blog.csdn.net/qq_35991056/article/details/81390551">https://blog.csdn.net/qq_35991056/article/details/81390551</a></p><p>entity / domain / model 的区别，在以后项目中应该也会遇到</p></li><li><p>数据库的 appoint_time 修改为 appoint_date</p><p>因为创建变量时，误写为 appointDate，所以更改了数据库列名</p></li></ol><h3 id="3-整合流程"><a href="#3-整合流程" class="headerlink" title="3. 整合流程"></a>3. 整合流程</h3><ol><li><p>建立整个项目的基础目录结构，同时遵循 maven 的目录规范</p></li><li><p>导入相应的 jar 包，资源坐标，注意版本号兼容性</p></li><li><p>资源文件中建立 spring 文件，按照 dao、service、controller分层配置</p></li><li><p>配置 mybatis 的核心文件 <code>mybatis-config.xml</code></p></li><li><p>配置 <code>web.xml</code> 文件</p></li><li><p>根据需求，配置日志文件</p></li><li><p>需要根据需求设计数据库以及查询语句</p></li><li><p>在 entity 层中封装数据库实体，注意内部成员名称</p></li><li><p>在 dao 层建立相对应的接口，由于 mybatis 不需要实现</p></li><li><p>资源文件中编写相对应的 mapper 配置文件</p></li><li><p>定义业务的数据字典，返回给客户端的状态信息</p></li><li><p>在 dto 包下建立类存储执行操作后的返回结果</p></li><li><p>在 dto 包下建立封装 json 返回结果的类，设计成泛型</p></li><li><p>在 exception 下建立自定义异常类</p></li><li><p>在 service 层下编写具体业务代码，创建并实现接口</p></li><li><p>编写 controller 层即 web 层，完善整体结构</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis基础</title>
      <link href="/2022/01/31/17-Mybatis%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/01/31/17-Mybatis%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Mybatis基础"><a href="#Mybatis基础" class="headerlink" title="Mybatis基础"></a>Mybatis基础</h2><span id="more"></span><h3 id="1-原始-Jdbc-操作分析"><a href="#1-原始-Jdbc-操作分析" class="headerlink" title="1. 原始 Jdbc 操作分析"></a>1. 原始 Jdbc 操作分析</h3><p><strong>存在以下问题：</strong></p><ol><li>数据库连接创建、释放频繁造成系统资源浪费从而影响性能</li><li>sql 语句在代码中硬编码，不易维护，不便于实际应用</li><li>查询和插入操作时，需要手动处理结果集和实体集</li></ol><p><strong>解决方案：</strong></p><ol><li>使用数据库连接池初始化连接资源</li><li>将 sql 语句抽取到 xml 配置文件中</li><li>使用反射、内省等底层技术，自动将实体与表进行映射</li></ol><h3 id="2-Mybatis-概念"><a href="#2-Mybatis-概念" class="headerlink" title="2. Mybatis 概念"></a>2. Mybatis 概念</h3><ul><li>基于 Java 的持久层框架，内部封装了 Jdbc，简化了开发者的工作</li><li>通过 xml 或注解的方式将要执行的各种 statement 配置起来</li><li>将结果映射为对象并返回，采用 ORM 思想解决实体和数据库映射问题</li><li>对 Jdbc 进行封装，屏蔽了底层访问细节，便于操作和维护</li></ul><h3 id="3-开发步骤"><a href="#3-开发步骤" class="headerlink" title="3. 开发步骤"></a>3. 开发步骤</h3><ol><li><p>添加 MyBatis 坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建数据表（user）</p></li><li><p>创建实体类（User）</p></li><li><p>编写映射文件（UserMapper.xml）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> </span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;userMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.domain.User&quot;</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>&lt;if&gt;：if 判断</li><li>&lt;foreach&gt;：循环</li><li>&lt;sql&gt;：sql 片段抽取</li></ul></li><li><p>编写核心文件（SqlMapConfig.xml）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span> </span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--数据源环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/study&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写测试类</p><p><strong>操作涉及数据库数据变化时，要提交事务，即<code>sqlSession.commit()</code></strong></p></li></ol><h3 id="4-核心配置文件"><a href="#4-核心配置文件" class="headerlink" title="4. 核心配置文件"></a>4. 核心配置文件</h3><ul><li>environments 标签：数据源环境配置标签</li><li>mappers 标签：加载映射配置</li><li>properties 标签：加载外部的 properties 文件</li><li>typeAliases 标签：设置类型别名</li><li>typeHandlers 标签：重写或创建类型处理器来处理不支持或非标准的类型</li><li>plugins 标签：Mybatis 可以使用第三方插件对功能进行拓展</li></ul><h3 id="5-相应API"><a href="#5-相应API" class="headerlink" title="5. 相应API"></a>5. 相应API</h3><ol><li><h5 id="SqlSession-工厂构建器-SqlSessionFactoryBuilder"><a href="#SqlSession-工厂构建器-SqlSessionFactoryBuilder" class="headerlink" title="SqlSession 工厂构建器 SqlSessionFactoryBuilder"></a>SqlSession 工厂构建器 SqlSessionFactoryBuilder</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得核心配置文件</span></span><br><span class="line">InputStream resourceAsStream = Resources.getResourceAsStream(<span class="string">&quot;sqlMapConfig.xml&quot;</span>);</span><br><span class="line"><span class="comment">// 获得session工厂对象</span></span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(resourceAsStream);</span><br></pre></td></tr></table></figure><p>通过加载核心文件输入流的形式构建一个 SqlSessionFactory 对象</p></li><li><h5 id="SqlSession-工厂对象-SqlSessionFactory"><a href="#SqlSession-工厂对象-SqlSessionFactory" class="headerlink" title="SqlSession 工厂对象 SqlSessionFactory"></a>SqlSession 工厂对象 SqlSessionFactory</h5><p>存在多个方法创建 SqlSession 实例，常用的如下两种：</p><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>openSession()</td><td>默认开启一个事务，但事务不会自动提交，需要手动提交，<br>更新数据才会持久化到数据库中</td></tr><tr><td>openSession(boolean autoCommit)</td><td>参数为是否自动提交，如果为 true，那么不需要手动提交</td></tr></tbody></table></li><li><h5 id="SqlSession-会话对象"><a href="#SqlSession-会话对象" class="headerlink" title="SqlSession 会话对象"></a>SqlSession 会话对象</h5><p>包含所有执行语句、提交或回滚事务和获取映射器实例的方法</p></li></ol><h3 id="6-Dao层代理开发"><a href="#6-Dao层代理开发" class="headerlink" title="6. Dao层代理开发"></a>6. Dao层代理开发</h3><p>Mybatis的代理开发方式实现 DAO 层的开发：<strong>Mapper接口开发方法</strong>，</p><p><strong>只需要实现 Mapper 接口，由 Mybatis 框架根据接口定义创建接口的动态代理对象。</strong></p><p><strong>遵循以下开发规范：</strong></p><ul><li>Mapper.xml 文件中的 namespace 与 mapper 接口的全限定名相同</li><li>Mapper 接口方法名和 Mapper.xml 中定义的每个 statement 的 id 相同</li><li>Mapper 接口方法的输入参数类型和文件中定义的每个 sql 的 parameterType 类型相同</li><li>Mapper 接口方法的输出参数类型和文件中定义的每个 sql 的 resultType 类型相同、</li></ul><h3 id="7-MyBatis注解开发"><a href="#7-MyBatis注解开发" class="headerlink" title="7. MyBatis注解开发"></a>7. MyBatis注解开发</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring事务控制</title>
      <link href="/2022/01/31/16-Spring%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/"/>
      <url>/2022/01/31/16-Spring%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring事务控制"><a href="#Spring事务控制" class="headerlink" title="Spring事务控制"></a>Spring事务控制</h2><span id="more"></span><h3 id="1-编程式事务控制相关对象"><a href="#1-编程式事务控制相关对象" class="headerlink" title="1. 编程式事务控制相关对象"></a>1. 编程式事务控制相关对象</h3><ol><li><p><strong>PlatformTransactionManager</strong> 是接口类型，不同的 Dao 层技术有不同的实现类，</p><p>Jdbc 或 Mybatis 时：</p><p><code>org.springframework.jdbc.datasource.DataSourceTransactionManager</code></p><p>Hibernate 时：</p><p><code>org.springframework.orm.hibernate5.HibernateTransactionManager</code></p></li><li><p><strong>TransactionDefinition</strong> 是事务的定义信息对象</p><ol><li><h5 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h5><ul><li>ISOLATION_DEFAULT</li><li>ISOLATION_READ_UNCOMMITTED</li><li>ISOLATION_READ_COMMITTED</li><li>ISOLATION_REPEATABLE_READ</li><li>ISOLATION_SERIALIZABLE</li></ul></li><li><h5 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h5><p><strong>指的是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行。 </strong><br>例如：A 事务方法调用 B 事务方法时，B 是继续在调用者 A 的事务中运行，</p><p>还是为自己开启一个新事务运行，这就是由 B 的事务传播行为决定的。</p></li><li><h5 id="事务运行状态-TransactionStatus"><a href="#事务运行状态-TransactionStatus" class="headerlink" title="事务运行状态 TransactionStatus"></a>事务运行状态 TransactionStatus</h5></li></ol></li></ol><h3 id="2-声明式事务控制"><a href="#2-声明式事务控制" class="headerlink" title="2. 声明式事务控制"></a>2. 声明式事务控制</h3><ol><li><h5 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h5></li></ol><p>Spring 在配置文件中声明的方式来处理事务，代替代码式的处理事务</p><ol start="2"><li><h5 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h5></li></ol><ul><li><p>事务管理不侵入开发的组件，具体来说，业务逻辑对象就不会意识到正在事务管理之中，</p><p>事实上也应如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，</p><p>如果想要改变事务管理策划的化，也只需要在定义文件中重新配置即可</p></li><li><p>不需要事务管理的时候，只要再设定文件上修改，便于维护</p></li></ul><ol start="3"><li><h5 id="Spring声明式事务控制底层就是AOP"><a href="#Spring声明式事务控制底层就是AOP" class="headerlink" title="Spring声明式事务控制底层就是AOP"></a>Spring声明式事务控制底层就是AOP</h5></li></ol><h3 id="3-基于XML文件配置"><a href="#3-基于XML文件配置" class="headerlink" title="3. 基于XML文件配置"></a>3. 基于XML文件配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    配置平台事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--通知 事务的增强--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--代表切点方法的事务参数的配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    配置事务的aop织入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.service.impl.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-基于注解"><a href="#4-基于注解" class="headerlink" title="4. 基于注解"></a>4. 基于注解</h3><ol><li>使用 <strong>@Transactional</strong> 在需要进行事务控制的类或方法上修饰</li><li>注解使用在类上，那么该类下的所有方法都使用同一套注解参数配置</li><li>使用在方法上，不同的方法可以采用不同的事务参数配置</li><li>配置事务注解驱动 <code>&lt;tx:annotation-driver&gt;</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP</title>
      <link href="/2022/01/31/15-Spring%20AOP/"/>
      <url>/2022/01/31/15-Spring%20AOP/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><span id="more"></span><h3 id="1-AOP的概念"><a href="#1-AOP的概念" class="headerlink" title="1. AOP的概念"></a>1. AOP的概念</h3><p>AOP 为 Aspect Oriented Programming 的缩写，意味<strong>面向切面编程</strong>，</p><p>是通过<strong>预编译方式和运行期动态代理</strong>实现程序功能的统一维护的一种技术，</p><p>利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使业务逻辑之间松耦合。</p><ul><li>Target（目标对象）：代理的目标对象</li><li>Proxy（代理）：一个类被 AOP 织入增强后，就产生一个结果代理类</li><li>Joinpoint（连接点）：可以被拦截到的点，在 Spring 中指的是方法</li><li>Pointcut（切入点）：对哪些 Joinpoint 进行真正的拦截的定义</li><li>Advice（通知/增强）：拦截到 Joinpoint 之后所要做的事情</li><li>Aspect（切面）：切入点和通知的结合</li><li>Weaving（织入）：把增强应用到目标对象来创建新的代理对象的过程</li></ul><h3 id="2-AOP的作用及其优势"><a href="#2-AOP的作用及其优势" class="headerlink" title="2. AOP的作用及其优势"></a>2. AOP的作用及其优势</h3><p>作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强</p><p>优势：减少重复代码，提高开发效率，并且便于维护</p><h3 id="3-AOP的底层实现"><a href="#3-AOP的底层实现" class="headerlink" title="3. AOP的底层实现"></a>3. AOP的底层实现</h3><p>通过 Spring 提供的动态代理技术实现，在程序运行期间，</p><p>Spring 通过动态代理技术动态的生成代理对象，代理对象方法执行时，</p><p>进行增强功能的介入，再去调用目标对象的方法，从而完成功能的增强。</p><h3 id="4-AOP的动态代理技术"><a href="#4-AOP的动态代理技术" class="headerlink" title="4. AOP的动态代理技术"></a>4. AOP的动态代理技术</h3><ol><li>JDK 代理：基于接口的动态代理技术</li><li>cglib 代理：基于父类的动态代理技术</li></ol><h3 id="5-AOP的开发明确事项"><a href="#5-AOP的开发明确事项" class="headerlink" title="5. AOP的开发明确事项"></a>5. AOP的开发明确事项</h3><ol><li><strong>需要编写的内容</strong><ul><li>编写核心业务代码（目标类的目标方法）</li><li>编写切面类、切面类中有通知（增强功能方法）</li><li>在配置文件中，配置织入关系</li></ul></li><li><strong>AOP技术实现的内容</strong></li></ol><p>Spring框架监控切入点方法的执行，一旦监控到切入点方法被运行，使用代理机制，</p><p>动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，</p><p>将通知对应的功能织入，完成完整的代码逻辑运行。</p><ol start="3"><li><strong>AOP底层使用那种代理方式</strong></li></ol><p>在Spring中，框架会根据目标类是否实现了接口来决定采用哪种动态代理方式</p><h3 id="6-基于XML的AOP开发"><a href="#6-基于XML的AOP开发" class="headerlink" title="6. 基于XML的AOP开发"></a>6. 基于XML的AOP开发</h3><ol><li><p><strong>步骤：</strong></p><ol><li><p>导入AOP相关坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br></pre></td></tr></table></figure></li><li><p>创建目标接口和目标类（内部有切点）</p></li><li><p>创建切面类（内部有增强方法）</p></li><li><p>将目标类和切面类的对象创建全交给Spring</p></li><li><p>在 appliactionContext.xml 中配置织入关系</p></li><li><p>测试代码</p></li></ol></li><li><p><strong>切点表达式的写法：</strong></p><p><code>execution([修饰符] 返回值类型 包名.类名.方法名(参数))</code></p><ul><li>访问修饰符可以省略</li><li>返回值类型、包名、类名、方法名可以使用星号 * 代表任意</li><li>包名与类名之间两个点表示当前包及其子包下的类</li><li>参数列表可以使用两个点表示任意个数，任意类型的参数列表</li></ul></li><li><p><strong>通知类型：</strong></p><p><code>&lt;aop:通知类型 method= ”切面类中方法名“ pointcut=”切点表达式“/&gt;</code></p><table><thead><tr><th>名称</th><th>标签</th><th>说明</th></tr></thead><tbody><tr><td>前置通知</td><td>&lt;aop:before&gt;</td><td>指定增强方法在切入点方法之前执行</td></tr><tr><td>后置通知</td><td>&lt;aop:after-returning&gt;</td><td>指定增强方法在切入点方法之后执行</td></tr><tr><td>环绕通知</td><td>&lt;aop:round&gt;</td><td>指定增强方法在切入点之前之后都执行</td></tr><tr><td>异常抛出通知</td><td>&lt;aop:throwing&gt;</td><td>指定增强的方法在出现异常时执行</td></tr><tr><td>最终通知</td><td>&lt;aop:after&gt;</td><td>无论增强方式执行是否有异常都会执行</td></tr></tbody></table></li></ol><h3 id="7-基于注解的AOP开发"><a href="#7-基于注解的AOP开发" class="headerlink" title="7. 基于注解的AOP开发"></a>7. 基于注解的AOP开发</h3><ol><li><p><strong>步骤：</strong></p><ol><li><p>创建目标接口和目标类</p></li><li><p>创建切面类</p></li><li><p>将目标类和切面类的对象创建权交给 Spring</p></li><li><p>在切面类中使用注解配置织入关系</p></li><li><p>在配置文件中开启组件扫描和 AOP 的自动代理</p><p><code>&lt;aop:aspectj-autoproxy/&gt;</code></p></li><li><p>测试代码</p></li></ol></li><li><p><strong>切点表达式的抽取：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;MyAspect.pointcut()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.*.*(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC异常处理</title>
      <link href="/2022/01/31/14-SpringMVC%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2022/01/31/14-SpringMVC%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringMVC异常处理"><a href="#SpringMVC异常处理" class="headerlink" title="SpringMVC异常处理"></a>SpringMVC异常处理</h2><span id="more"></span><h3 id="1-异常处理的思路"><a href="#1-异常处理的思路" class="headerlink" title="1. 异常处理的思路"></a>1. 异常处理的思路</h3><p>系统中异常包括两类：预期异常和运行时异常；</p><p>前者通过捕获异常从而获取异常信息，后者通过代码规范、测试减少发生。</p><p><strong>系统的 Dao、Service、Controller出现都通过 throws Exception 向上抛出，</strong></p><p><strong>最后由 SpringMVC 前端控制器交由异常处理器进行异常处理。</strong></p><h3 id="2-异常处理的两种方式"><a href="#2-异常处理的两种方式" class="headerlink" title="2. 异常处理的两种方式"></a>2. 异常处理的两种方式</h3><ul><li><p>SpringMVC 提供的简单异常处理器：SimpleMappingExceptionResolver</p><p>在使用时可以根据项目情况进行相应异常与视图的映射配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    配置简单映射异常处理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultErrorView&quot;</span> <span class="attr">value</span>=<span class="string">&quot;error&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionMappings&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;com.yuanhao.exception.MyException&quot;</span> <span class="attr">value</span>=<span class="string">&quot;error&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;java.lang.ClassCastException&quot;</span> <span class="attr">value</span>=<span class="string">&quot;error&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Spring 的异常处理接口 HandleExceptionResolver 自定义异常处理器</p><ol><li><p>创建异常处理器类实现接口</p></li><li><p>配置异常处理器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    自定义异常处理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.resolver.MyExceptionResolver&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写异常页面</p></li><li><p>测试异常跳转</p></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC拦截器</title>
      <link href="/2022/01/31/13-SpringMVC%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
      <url>/2022/01/31/13-SpringMVC%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringMVC拦截器"><a href="#SpringMVC拦截器" class="headerlink" title="SpringMVC拦截器"></a>SpringMVC拦截器</h2><span id="more"></span><h3 id="1-拦截器作用"><a href="#1-拦截器作用" class="headerlink" title="1. 拦截器作用"></a>1. 拦截器作用</h3><p>SpringMVC 的拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行<strong>预处理</strong>和<strong>后处理</strong>；</p><p>将拦截器按一定顺序连接成一条链，这条链成为<strong>拦截器链（Interceptor Chain）</strong>；</p><p>在访问被拦截的方法或字段时，拦截器链中的拦截器就会按之前定义的顺序被调用；</p><p>拦截器也是 <strong>AOP</strong> 思想的具体实现。</p><h3 id="2-拦截器和过滤器区别"><a href="#2-拦截器和过滤器区别" class="headerlink" title="2. 拦截器和过滤器区别"></a>2. 拦截器和过滤器区别</h3><table><thead><tr><th>区别</th><th align="left">过滤器（Filter）</th><th>拦截器（Interceptor）</th></tr></thead><tbody><tr><td>适用范围</td><td align="left">servlet 规范中的一部分，<br>任何 Java Web 工程都可以使用</td><td>SpringMVC框架才能使用</td></tr><tr><td>拦截范围</td><td align="left">在 url-pattern 中配置 /* 后，<br>可以对所有要访问的资源拦截</td><td>在 &lt;mvc:mapping path=”” /&gt; 中配置 /** 后，也可以全部拦截，<br>但是可以通过  &lt;mvc:exclude-mapping path=”” /&gt;标签，<br>排除不需要拦截的资源</td></tr></tbody></table><h3 id="3-自定义拦截器"><a href="#3-自定义拦截器" class="headerlink" title="3. 自定义拦截器"></a>3. 自定义拦截器</h3><ol><li><p>创建拦截器类实现 HandlerInterceptor 接口</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>preHandle()</td><td>方法将在请求处理之前进行调用，返回值为布尔类型，<br>当返回值为 false 时，表示请求结束；<br>当返回值为 true 时，继续调用下一个拦截器的 preHandle 方法</td></tr><tr><td>postHandle()</td><td>方法在 preHandle 方法返回值为 true 时才能被调用，<br>并且会在视图返回渲染之前被调用</td></tr><tr><td>afterCompletion()</td><td>在整个请求结束后即渲染视图之后执行</td></tr></tbody></table></li><li><p>配置拦截器在 spring-mvc.xml 文件中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    配置拦截器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    对哪些资源执行拦截操作--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.yuanhao.controller.interceptor.MyInterceptor1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试拦截器</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring环境搭建</title>
      <link href="/2022/01/31/12-Spring%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2022/01/31/12-Spring%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring环境搭建"><a href="#Spring环境搭建" class="headerlink" title="Spring环境搭建"></a>Spring环境搭建</h2><span id="more"></span><h3 id="1-环境搭建步骤"><a href="#1-环境搭建步骤" class="headerlink" title="1. 环境搭建步骤"></a>1. 环境搭建步骤</h3><ol><li>创建工程（Project&amp;Module）</li><li>导入静态页面</li><li>导入所需坐标</li><li>创建包结构（controller、service、dao、domain、utils）</li><li>导入数据库脚本</li><li>创建 POJO 类</li><li>创建配置文件</li></ol><h3 id="2-角色列表展示的步骤"><a href="#2-角色列表展示的步骤" class="headerlink" title="2. 角色列表展示的步骤"></a>2. 角色列表展示的步骤</h3><ol><li>点击角色管理菜单发送请求到服务端</li><li>创建 RoleController 和 showList() 方法</li><li>创建 RoleService 和 showList() 方法</li><li>创建 RoleDao 和 findAll() 方法</li><li>使用 JdbcTemplate 完成查询操作</li><li>将查询数据存储到 Model 中</li><li>转发到 role-list.jsp 页面进行展示</li></ol><h3 id="3-角色添加的步骤"><a href="#3-角色添加的步骤" class="headerlink" title="3. 角色添加的步骤"></a>3. 角色添加的步骤</h3><ol><li>点击列表页面新建按钮跳转到角色添加页面</li><li>输入角色信息，剪辑保存按钮，表单数据提交服务器</li><li>编写 RoleController 的 save() 方法</li><li>编写 RoleService 的 save() 方法</li><li>编写 RoleDao 的 save() 方法</li><li>使用 JdbcTemplate 保存 Role 数据到 sys_role</li><li>跳转回角色列表页面</li></ol><h3 id="4-用户登录权限控制"><a href="#4-用户登录权限控制" class="headerlink" title="4. 用户登录权限控制"></a>4. 用户登录权限控制</h3><p>用户没有登录的情况下，不能对后台菜单进行访问操作，点击菜单跳转到登陆页面，</p><p>只有用户登录成功后才能进行后台功能的操作。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringJdbcTemplate</title>
      <link href="/2022/01/31/11-Spring%20JdbcTemplate/"/>
      <url>/2022/01/31/11-Spring%20JdbcTemplate/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-JdbcTemplate"><a href="#Spring-JdbcTemplate" class="headerlink" title="Spring JdbcTemplate"></a>Spring JdbcTemplate</h2><span id="more"></span><h3 id="1-JdbcTemplate概述"><a href="#1-JdbcTemplate概述" class="headerlink" title="1. JdbcTemplate概述"></a>1. JdbcTemplate概述</h3><p>Spring 框架中提供的对象，对原始繁琐的 Jdbc API 对象简单封装，提供了很多的操作模板类</p><h3 id="2-JdbcTemplate开发步骤"><a href="#2-JdbcTemplate开发步骤" class="headerlink" title="2. JdbcTemplate开发步骤"></a>2. JdbcTemplate开发步骤</h3><ul><li><p>导入 spring-jdbc 和 spring-tx 坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建数据库表和实体</p></li><li><p>创建 JdbcTemplate对象</p></li><li><p>执行数据库操作</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC获得请求数据</title>
      <link href="/2022/01/31/10-SpringMVC%E8%8E%B7%E5%BE%97%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE/"/>
      <url>/2022/01/31/10-SpringMVC%E8%8E%B7%E5%BE%97%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringMVC获得请求数据"><a href="#SpringMVC获得请求数据" class="headerlink" title="SpringMVC获得请求数据"></a>SpringMVC获得请求数据</h2><span id="more"></span><p>客户端请求参数的格式是：<strong>name=value&amp;name=value…</strong></p><p>服务器端要获得请求的参数，有时还需要进行数据的封装，</p><h3 id="1-接收参数类型"><a href="#1-接收参数类型" class="headerlink" title="1. 接收参数类型"></a>1. 接收参数类型</h3><ol><li><h5 id="基本类型参数"><a href="#基本类型参数" class="headerlink" title="基本类型参数"></a>基本类型参数</h5><p>Controller 中的业务方法的参数名称要与请求参数一致，参数值会自动映射匹配</p></li><li><h5 id="POJO类型参数"><a href="#POJO类型参数" class="headerlink" title="POJO类型参数"></a>POJO类型参数</h5><p>Controller 中的业务方法的 POJO 参数的属性名与请求参数一致，自动映射匹配</p></li><li><h5 id="数组类型参数"><a href="#数组类型参数" class="headerlink" title="数组类型参数"></a>数组类型参数</h5><p>Controller 中的业务方法的 数组名称的与请求参数一致，自动映射匹配</p></li><li><h5 id="集合类型参数"><a href="#集合类型参数" class="headerlink" title="集合类型参数"></a>集合类型参数</h5><ol><li><p>获得集合参数时，需要将集合参数包装到 POJO</p></li><li><p>使用 ajax 提交时，可以指定 contextType 为 json 形式，</p><p>在方法参数位置使用 <strong>@RequsetBody</strong> 可以直接接收集合数据</p></li></ol></li></ol><h3 id="2-请求数据乱码问题："><a href="#2-请求数据乱码问题：" class="headerlink" title="2. 请求数据乱码问题："></a>2. <strong>请求数据乱码问题：</strong></h3><p>当 post 请求时，数据会出现乱码，设置过滤器进行编码的过滤</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    配置全局过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>GBK<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-参数绑定注解"><a href="#3-参数绑定注解" class="headerlink" title="3. 参数绑定注解"></a>3. 参数绑定注解</h3><p>当请求与业务方法的参数名称不一致时，就需要通过 <strong>@RequsetParam</strong> 注解显示的绑定</p><ul><li>value：请求参数名称</li><li>required：指定请求参数是否必须包括，默认值为 true</li><li>defaultValue：当没有指定请求参数时，则使用默认值赋值</li></ul><h3 id="4-获得Restful风格的参数"><a href="#4-获得Restful风格的参数" class="headerlink" title="4. 获得Restful风格的参数"></a>4. 获得Restful风格的参数</h3><p>Restful 是一种软件架构风格、设计风格，而不是标准，</p><p>主要用于客户端和服务器交互类的软件，基于此风格设计，</p><p>可以使得软件更加简洁，具有层次，易于实现缓存机制。</p><p><strong>使用”url + 请求方式” 表示一次请求目的：</strong></p><ul><li>GET：用于获取资源</li><li>POST：用于新建资源</li><li>PUT：用于更新资源</li><li>DELETE：用于删除资源</li></ul><p>在方法中使用 <strong>@PathVariable</strong> 注解进行占位符的匹配获取。</p><h3 id="5-自定义类型转换器"><a href="#5-自定义类型转换器" class="headerlink" title="5. 自定义类型转换器"></a>5. 自定义类型转换器</h3><p>默认例子：客户端提交的字符串转换成 int 型进行参数设置</p><p>现实需求：日期类型的数据就需要自定义类型转换器</p><p><strong>具体开发步骤：</strong></p><ol><li>定义转换器类实现 Converter 接口</li><li>在配置文件中声明转换器</li><li>在 &lt;annotation-driven&gt; 中引用转换器</li></ol><h3 id="6-获得Servlet相关API"><a href="#6-获得Servlet相关API" class="headerlink" title="6. 获得Servlet相关API"></a>6. 获得Servlet相关API</h3><p>SpringMVC支持使用原始ServletAPI对象作为控制器方法的参数进行注入：</p><ul><li>HttpServletRequest</li><li>HttpServletResponse</li><li>HttpSession</li></ul><h3 id="7-获得请求头"><a href="#7-获得请求头" class="headerlink" title="7. 获得请求头"></a>7. 获得请求头</h3><ol><li><h4 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h4></li></ol><p>注解属性如下：</p><ul><li>value：请求头的名称</li><li>required：是否必须携带此请求头</li></ul><ol start="2"><li><h4 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h4></li></ol><p>注解属性如下：</p><ul><li>value：指定 cookie 的名称</li><li>required：是否必须携带此 cookie</li></ul><h3 id="8-文件上传"><a href="#8-文件上传" class="headerlink" title="8. 文件上传"></a>8. 文件上传</h3><ol><li><h4 id="文件上传客户端三要素"><a href="#文件上传客户端三要素" class="headerlink" title="文件上传客户端三要素"></a>文件上传客户端三要素</h4><ul><li>表单项 type = “file”</li><li>表单的提交方式是 post</li><li>表单的 enctype 属性是多部分表单形式</li></ul></li><li><h4 id="单文件上传步骤"><a href="#单文件上传步骤" class="headerlink" title="单文件上传步骤"></a>单文件上传步骤</h4><ul><li><p>导入 fileupload 和 io 坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置文件上传解析器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    配置文件上传解析器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;500000&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写文件上传代码</p></li></ul></li><li><h4 id="多文件上传"><a href="#多文件上传" class="headerlink" title="多文件上传"></a>多文件上传</h4><p>避免重复步骤，将方法参数 MultipartFile 类型修改为 MultipartFile[] 即可</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC数据响应</title>
      <link href="/2022/01/31/9-SpringMVC%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94/"/>
      <url>/2022/01/31/9-SpringMVC%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringMVC数据响应"><a href="#SpringMVC数据响应" class="headerlink" title="SpringMVC数据响应"></a>SpringMVC数据响应</h2><span id="more"></span><h3 id="1-页面跳转"><a href="#1-页面跳转" class="headerlink" title="1. 页面跳转"></a>1. 页面跳转</h3><ol><li><h5 id="直接返回字符串"><a href="#直接返回字符串" class="headerlink" title="直接返回字符串"></a>直接返回字符串</h5></li></ol><p>此种方式会将返回的字符串与视图解析器的前后缀拼接后跳转</p><ol start="2"><li><h5 id="通过-ModelAndView-对象返回"><a href="#通过-ModelAndView-对象返回" class="headerlink" title="通过 ModelAndView 对象返回"></a>通过 ModelAndView 对象返回</h5></li></ol><h3 id="2-回写数据"><a href="#2-回写数据" class="headerlink" title="2. 回写数据"></a>2. 回写数据</h3><ol><li><h5 id="直接返回字符串-JSON"><a href="#直接返回字符串-JSON" class="headerlink" title="直接返回字符串 / JSON"></a>直接返回字符串 / JSON</h5><ul><li>通过 SpringMVC 框架注入的 response 对象，此时不需要视图跳转，方法返回值为 void</li><li>将需要回写的字符串直接返回，通过 <strong>@ResponseBody</strong> 注解告知 SpringMVC 框架</li></ul></li><li><h5 id="返回对象或集合"><a href="#返回对象或集合" class="headerlink" title="返回对象或集合"></a>返回对象或集合</h5></li></ol><p>通过 SpringMVC 进行 JSON 字符串的转换并回写，为处理器适配器配置消息转化参数，</p><p>指定使用 jackson 进行转换，因此需要在 spring-mvc.xml 中进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;messageConverters&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在方法上添加 @ResponseBody 就可以返回 json 格式的字符串，但是配置比较繁琐，</p><p>因此，可以使用<strong>注解驱动代替上述配置：<code>&lt;mvc:annotation-driven/&gt;</code></strong></p><p><strong>处理器映射器、处理器适配器、视图解析器成为 SpringMVC 的三大组件</strong>，</p><p>上述注解驱动默认底层就会集成 jackson 进行对象或集合的 json格式字符串的转换。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC基础</title>
      <link href="/2022/01/31/8-SpringMVC%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/01/31/8-SpringMVC%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringMVC基础"><a href="#SpringMVC基础" class="headerlink" title="SpringMVC基础"></a>SpringMVC基础</h2><span id="more"></span><h3 id="1-SpringMVC概述"><a href="#1-SpringMVC概述" class="headerlink" title="1. SpringMVC概述"></a>1. SpringMVC概述</h3><p>SpringMVC 是一种基于 Java 的实现 MVC设计模型的请求驱动类型的轻量级 Web 框架</p><ol><li>前端控制器：DispatcherServlet</li><li>处理器映射器：HandlerMapping</li><li>处理器适配器：HandlerAdapter</li><li>处理器：Handler</li><li>视图解析器：ViewResolver</li><li>视图：View</li></ol><h3 id="2-SpringMVC步骤"><a href="#2-SpringMVC步骤" class="headerlink" title="2. SpringMVC步骤"></a>2. SpringMVC步骤</h3><p>需求：客户端发起请求，服务器端接受请求，执行逻辑并进行视图跳转</p><ol><li>导入 SpringMVC 相关坐标</li><li>配置 SpringMVC 核心控制器 DispatcherServlet</li><li>创建 Controller 类和视图页面</li><li>使用注解配置 Controller 类中业务方法的映射地址</li><li>配置 SpringMVC 核心文件 spring-mvc.xml</li><li>客户端发起请求测试</li></ol><h3 id="3-SpringMVC执行流程"><a href="#3-SpringMVC执行流程" class="headerlink" title="3. SpringMVC执行流程"></a>3. SpringMVC执行流程</h3><ol><li><p>用户发送请求至前端控制器 DispatcherServlet</p></li><li><p>DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器</p></li><li><p>处理器映射器找到具体的处理器，生成处理器对象以及处理器拦截器，</p><p>一并返回给 DispatcherServlet</p></li><li><p>DispatcherServlet 调用 HandlerAdapter 处理器适配器</p></li><li><p>HandlerAdapter 经过适配器调用具体的处理器</p></li><li><p>Controller 执行完成后返回 ModelAndView</p></li><li><p>HandlerAdapter 将 ModelAndView 返回给 DispatcherServlet</p></li><li><p>DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器</p></li><li><p>ViewReslover 解析后返回具体 View</p></li><li><p>DispatcherServlet 根据 View 进行渲染视图后响应用户</p></li></ol><h3 id="4-SpringMVC注解解析"><a href="#4-SpringMVC注解解析" class="headerlink" title="4. SpringMVC注解解析"></a>4. SpringMVC注解解析</h3><ol><li><strong>@RequestMapping</strong></li></ol><p>作用：用于建立请求 URL 和 处理请求方法之间的对应关系</p><p>位置：</p><ul><li>类上，请求 URL 的第一级访问目录</li><li>方法上，请求 URL 的第二级访问目录</li></ul><p>属性：</p><ul><li>value：用于指定请求的 URL</li><li>method：用于指定请求的方式</li><li>params：用于指定限制请求参数的条件，支持简单的表达式</li></ul><h3 id="5-SpringMVC的XML配置解析"><a href="#5-SpringMVC的XML配置解析" class="headerlink" title="5. SpringMVC的XML配置解析"></a>5. SpringMVC的XML配置解析</h3><ol><li>mvc 命名空间引入和组件扫描</li><li>配置内部资源视图解析器</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring与Web环境集成</title>
      <link href="/2022/01/31/7-Spring%E4%B8%8EWeb%E7%8E%AF%E5%A2%83%E9%9B%86%E6%88%90/"/>
      <url>/2022/01/31/7-Spring%E4%B8%8EWeb%E7%8E%AF%E5%A2%83%E9%9B%86%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring与Web环境集成"><a href="#Spring与Web环境集成" class="headerlink" title="Spring与Web环境集成"></a>Spring与Web环境集成</h2><span id="more"></span><h3 id="1-ApplicationContext应用上下文获取方式"><a href="#1-ApplicationContext应用上下文获取方式" class="headerlink" title="1. ApplicationContext应用上下文获取方式"></a>1. ApplicationContext应用上下文获取方式</h3><p>应用上下文对象是通过 <code>new ClassPathXmlApplicationContext(Spring配置文件)</code>方式获取，</p><p>但是每次从容器中获得 Bean 时都要编写，会导致配置文件加载多次，应用上下文创建多次。</p><p>在 Web 项目中，可以使用 <code>ServletContextListener</code> 监听 Web 应用的启动，当应用启动时，</p><p>就加载 Spring 的配置文件，创建应用上下文对象，并将其存储到 <code>servletContext</code> 域中，</p><p>这样就可以在任意位置从域中获得应用上下文对象 <code>ApplicationContext</code> 对象。</p><h3 id="2-Spring提供获取应用上下文的工具"><a href="#2-Spring提供获取应用上下文的工具" class="headerlink" title="2. Spring提供获取应用上下文的工具"></a>2. Spring提供获取应用上下文的工具</h3><p>Spring 提供监听器 <code>ContextLoaderListener</code> 对上述功能封装，</p><p>该监听器内部加载 Spring 配置文件，创建应用上下文对象，并存储到 <code>servletContext</code> 域中，</p><p>提供了一个客户端工具 <code>WebApplicationContextUtils</code> 供获得应用上下文对象。</p><ol><li>在 web.xml 中配置 ContextLoaderListener 监听器<strong>（导入 spring-web 坐标）</strong></li><li>使用 WebApplicationContextUtils 获得应用上下文对象</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring集成Junit</title>
      <link href="/2022/01/31/6-Spring%E9%9B%86%E6%88%90Junit/"/>
      <url>/2022/01/31/6-Spring%E9%9B%86%E6%88%90Junit/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring集成Junit"><a href="#Spring集成Junit" class="headerlink" title="Spring集成Junit"></a>Spring集成Junit</h2><span id="more"></span><h3 id="1-原始-Junit-测试-Spring-的问题"><a href="#1-原始-Junit-测试-Spring-的问题" class="headerlink" title="1. 原始 Junit 测试 Spring 的问题"></a>1. 原始 Junit 测试 Spring 的问题</h3><p>在测试类中，每个测试方法都有一下两行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">IAccountService as = ac.getBean(<span class="string">&quot;accountService&quot;</span>, IAccountService.class);</span><br></pre></td></tr></table></figure><h3 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2. 解决办法"></a>2. 解决办法</h3><ul><li>让 SpringJunit 负责创建 Spring 容器，但是需要将配置文件的名称告之；</li><li>将需要进行测试 Bean 直接在测试类中进行注入；</li></ul><h3 id="3-Spring-集成-Junit-步骤"><a href="#3-Spring-集成-Junit-步骤" class="headerlink" title="3. Spring 集成 Junit 步骤"></a>3. Spring 集成 Junit 步骤</h3><ol><li>导入 Spring 集成 Junit 的坐标</li><li>使用 @RunWith 注解替换原来的运行期</li><li>使用 @ContextConfiguration 指定配置文件或配置类</li><li>使用 @Autowired 注入需要测试的对象</li><li>创建测试方法进行测试</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring注解开发</title>
      <link href="/2022/01/31/5-Spring%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/"/>
      <url>/2022/01/31/5-Spring%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring注解开发"><a href="#Spring注解开发" class="headerlink" title="Spring注解开发"></a>Spring注解开发</h2><span id="more"></span><p>Spring 是轻代码而重配置的框架，配置比较繁重，影响开发效率，</p><p>所以注解是一种开发趋势，注解代替 <code>xml</code> 配置文件可以简化配置，提高开发效率。</p><h3 id="1-原始注解"><a href="#1-原始注解" class="headerlink" title="1. 原始注解"></a>1. 原始注解</h3><p>Spring 原始注解主要是替代 &lt;Bean&gt; 的配置</p><table><thead><tr><th>注解</th><th align="left">说明</th></tr></thead><tbody><tr><td>@Component</td><td align="left">使用在类上实例化 Bean</td></tr><tr><td>@Controller</td><td align="left">使用在 web 层类上实例化 Bean</td></tr><tr><td>@Service</td><td align="left">使用在 service 层类上实例化 Bean</td></tr><tr><td>@Repository</td><td align="left">使用在 dao 层类上实例化 Bean</td></tr><tr><td>@Autowired</td><td align="left">使用在字段上用于根据类型依赖注入</td></tr><tr><td>@Qualifier</td><td align="left">结合 @Autowired 用于根据名称依赖注入</td></tr><tr><td>@Resource</td><td align="left">相当于 @Autowired + @Qualifier</td></tr><tr><td>@Value</td><td align="left">注入普通属性</td></tr><tr><td>@Scope</td><td align="left">标注 Bean 的作用范围</td></tr><tr><td>@PostConstruct</td><td align="left">标注方法上表明是 Bean 的初始化方法</td></tr><tr><td>@PreDestory</td><td align="left">标注方法上表明是 Bean 的销毁方法</td></tr></tbody></table><p><strong>注意：</strong></p><ol><li><p>使用注解进行开发时，需要在 <code>xml</code> 中配置组件扫描，其作用是：</p><p>指定哪个包及其子包下的 <code>Bean</code> 需要进行扫描以便识别使用注解配置的类、字段和方法；</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p><code>@Autowired</code> 根据数据类型从 <code>Spring</code> 容器中进行匹配</p><p><code>@Qualifier</code> 根据 <code>id</code> 值从容器中进行匹配，但是需要结合 <code>@Autowired</code> 使用；</p></li><li><p>使用 <code>prototype</code> 时 <code>Spring</code> 不会负责销毁容器对象，将 <code>scope</code> 改为 <code>singleton</code> 才会生效 <code>destroy</code> 方法；</p></li></ol><h3 id="2-新注解"><a href="#2-新注解" class="headerlink" title="2. 新注解"></a>2. 新注解</h3><ul><li>非自定义的 <code>Bean</code> 配置：&lt;bean&gt;</li><li>加载外部 <code>properties</code> 文件的配置：&lt;context:property-placeholder&gt;</li><li>组件扫描的配置：&lt;context:component-scan&gt;</li><li>引入其他文件：&lt;import&gt;</li></ul><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Configuration</td><td>用于指定当前类是一个 Spring 核心配置类</td></tr><tr><td>@ComponentScan</td><td>用于指定 Spring 在初始化容器时要扫描的包</td></tr><tr><td>@Bean</td><td>使用在方法上，将该方法的返回值存储到容器中</td></tr><tr><td>@PropertySource</td><td>用于加载 properties 文件</td></tr><tr><td>@Import</td><td>用于导入其他配置类</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring配置数据源</title>
      <link href="/2022/01/31/4-Spring%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E6%BA%90/"/>
      <url>/2022/01/31/4-Spring%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring配置数据源"><a href="#Spring配置数据源" class="headerlink" title="Spring配置数据源"></a>Spring配置数据源</h2><span id="more"></span><h3 id="1-数据源（连接池）的作用"><a href="#1-数据源（连接池）的作用" class="headerlink" title="1. 数据源（连接池）的作用"></a>1. 数据源（连接池）的作用</h3><ul><li>提高程序性能</li><li>事先实例化数据源，初始化部分连接资源</li><li>使用连接资源时从数据源中获取</li><li>使用完毕后连接资源归还给数据源</li></ul><p>常见的数据源：DBCP、C3P0、BoneCP、Druid等</p><h3 id="2-数据源的开发步骤"><a href="#2-数据源的开发步骤" class="headerlink" title="2. 数据源的开发步骤"></a>2. 数据源的开发步骤</h3><ol><li>导入数据源的坐标和数据库驱动坐标</li><li>创建数据源对象</li><li>设置数据源的基本连接数据</li><li>使用数据源获取连接资源和归还连接资源</li></ol><h3 id="3-Spring-配置数据源"><a href="#3-Spring-配置数据源" class="headerlink" title="3. Spring 配置数据源"></a>3. Spring 配置数据源</h3><p>可以将 DataSource 的创建权交由 Spring 容器完成</p><h4 id="抽取-jdbc-配置文件"><a href="#抽取-jdbc-配置文件" class="headerlink" title="抽取 jdbc 配置文件"></a>抽取 jdbc 配置文件</h4><p>applicationContext.xml 加载 jdbc.properties 配置文件获得连接信息。</p><ol><li><p>引入 context 命名空间和约束路径：</p><p>命名空间：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br></pre></td></tr></table></figure><p>约束路径：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://www.springframework.org/schema/context </span><br><span class="line">http://www.springframework.org/schema/context/spring-context.xsd</span><br></pre></td></tr></table></figure></li><li><p>Spring 容器加载 properties 文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;xx.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;key&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring相关API</title>
      <link href="/2022/01/31/3-Spring%E7%9B%B8%E5%85%B3API/"/>
      <url>/2022/01/31/3-Spring%E7%9B%B8%E5%85%B3API/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring相关API"><a href="#Spring相关API" class="headerlink" title="Spring相关API"></a>Spring相关API</h2><span id="more"></span><p>各个版本的 API 文档链接：<a href="https://docs.spring.io/spring-framework/docs/">https://docs.spring.io/spring-framework/docs/</a></p><h3 id="1-ApplicationContext-的继承体系"><a href="#1-ApplicationContext-的继承体系" class="headerlink" title="1. ApplicationContext 的继承体系"></a>1. ApplicationContext 的继承体系</h3><p>ApplicationContext：接口类型，代表应用上下文，可以通过其实例获得 Spring 容器中的 Bean 对象</p><h3 id="2-ApplicationContext-的实现类"><a href="#2-ApplicationContext-的实现类" class="headerlink" title="2. ApplicationContext 的实现类"></a>2. ApplicationContext 的实现类</h3><ul><li><p><strong>ClassPathXmlApplicationContext</strong></p><p>从类的根路径下加载配置文件<strong>（推荐使用）</strong></p></li><li><p><strong>FileSystemXmlApplicationContext</strong></p><p>从磁盘路径上加载配置文件，配置文件可以在磁盘上的任意位置</p></li><li><p><strong>AnnotationConfigApplicationContext</strong></p><p>当使用注解配置容器对象时，需要用此类创建容器，用来读取注解</p></li></ul><h3 id="3-getBean-方法"><a href="#3-getBean-方法" class="headerlink" title="3. getBean() 方法"></a>3. getBean() 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.<span class="function">Object <span class="title">getBean</span><span class="params">(java.lang.String name)</span> <span class="keyword">throws</span> BeansException</span></span><br><span class="line"><span class="function">&lt;T&gt; T <span class="title">getBean</span><span class="params">(java.lang.Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span></span><br></pre></td></tr></table></figure><ol><li><p>参数类型是字符串时，表示根据 Bean 的 id 从容器中获得实例，</p><p>返回时 Object，需要进行强制类型转换</p></li><li><p>参数类型是 Class 时，表示根据类型从容器中匹配 Bean 实例，</p><p>不需要强制类型转换，但是当有多个相同 Bean 时，会报错</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring配置文件</title>
      <link href="/2022/01/31/2-Spring%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/2022/01/31/2-Spring%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring配置文件"><a href="#Spring配置文件" class="headerlink" title="Spring配置文件"></a>Spring配置文件</h2><span id="more"></span><h3 id="1-Bean-标签基本配置"><a href="#1-Bean-标签基本配置" class="headerlink" title="1. Bean 标签基本配置"></a>1. Bean 标签基本配置</h3><ol><li><p>Bean 用于配置对象交由 Spring 来创建，<strong>默认情况下调用的是类中的无参构造函数</strong>，</p><p>如果没有无参构造函数则不能创建成功；</p></li><li><p>基本属性</p><ol><li><p><strong>id</strong>：Bean 实例在 Spring 容器中的唯一标识</p></li><li><p><strong>class</strong>：Bean 的全限定名称</p></li><li><p><strong>scope</strong>：Bean 的作用范围</p></li><li><p><strong>&lt;property&gt;</strong>标签：属性注入</p><ol><li>name 属性：属性名称</li><li>value 属性：注入的普通属性值</li><li>ref 属性：注入的对象引用值</li><li>&lt;list&gt;标签、&lt;map&gt;标签、&lt;properties&gt;标签</li></ol></li><li><p><strong>&lt;constructor-arg&gt;标签</strong></p></li></ol></li><li><p><strong>&lt;import&gt;标签</strong>：导入其他的 Spring 的分文件</p></li></ol><h3 id="2-Bean-标签范围配置"><a href="#2-Bean-标签范围配置" class="headerlink" title="2. Bean 标签范围配置"></a>2. Bean 标签范围配置</h3><table><thead><tr><th align="center">取值范围</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">singleton</td><td align="center">默认值、单例</td></tr><tr><td align="center">prototype</td><td align="center">多例</td></tr><tr><td align="center">request</td><td align="center">WEB项目中，存入到 request 域</td></tr><tr><td align="center">session</td><td align="center">WEB项目中，存入到 session 域</td></tr><tr><td align="center">global session</td><td align="center">WEB项目中，应用在 Portlet 环境</td></tr></tbody></table><ol><li><h4 id="当-scope-的取值为-singleton-时："><a href="#当-scope-的取值为-singleton-时：" class="headerlink" title="当 scope 的取值为 singleton 时："></a>当 scope 的取值为 singleton 时：</h4></li></ol><ul><li>Bean 的实例化个数：1个</li><li>Bean 的实例化时机：当 Spring 核心文件被加载时，实例化配置的 Bean 实例</li><li>Bean 的生命周期：<ol><li>对象创建：当应用加载，创建容器时，对象就被创建；</li><li>对象运行：只要容器在，对象就一直存在；</li><li>对象销毁：当应用卸载，销毁容器时，对象就被销毁；</li></ol></li></ul><ol start="2"><li><h4 id="当-scope-的取值为-prototype-时："><a href="#当-scope-的取值为-prototype-时：" class="headerlink" title="当 scope 的取值为 prototype 时："></a>当 scope 的取值为 prototype 时：</h4></li></ol><ul><li>Bean 的实例化个数：多个</li><li>Bean 的实例化时机：当调用 getBean() 方法时实例化 Bean</li><li>Bean 的生命周期：<ol><li>对象创建：当使用对象时，创建新的对象实例；</li><li>对象运行：只要对象在使用中，就一直存在；</li><li>对象销毁：当对象长时间不用，就被 Java 的垃圾回收期回收；</li></ol></li></ul><h3 id="3-Bean-生命周期配置"><a href="#3-Bean-生命周期配置" class="headerlink" title="3. Bean 生命周期配置"></a>3. Bean 生命周期配置</h3><ul><li><p>init-method：指定类中的初始化方法名称</p></li><li><p>destroy-method：指定类中的销毁方法名称</p><p><strong>注意：需要手动关闭容器，才能运行销毁方法</strong></p></li></ul><p><strong>特殊说明：</strong></p><p>当创建 ApplicationContext 对象时，不存在 close() 方法，有两种解决方法：</p><ol><li>更改为 AbstractApplicationContext 对象；</li><li><strong>向下强制转为 ConfigurableApplicationContext，即声明时的类型；</strong></li><li>在大多数情况下更加推荐第二种方法；</li><li>参考文章：<a href="https://stackoverflow.com/questions/14423980/how-to-close-a-spring-applicationcontext">java - How to close a spring ApplicationContext? - Stack Overflow</a></li></ol><h3 id="4-Bean-实例化三种方式"><a href="#4-Bean-实例化三种方式" class="headerlink" title="4. Bean 实例化三种方式"></a>4. Bean 实例化三种方式</h3><ul><li>无参构造方法实例化</li><li>工厂静态方法实例化</li><li>工厂实例方法实例化</li></ul><h3 id="5-Bean-依赖注入"><a href="#5-Bean-依赖注入" class="headerlink" title="5. Bean 依赖注入"></a>5. Bean 依赖注入</h3><ol><li><p><strong>依赖注入（Dependency Injection）: Spring框架核心 IOC 的具体实现</strong></p></li><li><p>依赖注入方式：</p><ul><li>构造方法</li><li>set 方法</li></ul></li><li><p>依赖注入的数据类型：</p><ul><li>普通数据类型</li><li>引用数据类型</li><li>集合数据类型</li></ul></li></ol><h3 id="6-引入其他配置文件（分模块开发）"><a href="#6-引入其他配置文件（分模块开发）" class="headerlink" title="6. 引入其他配置文件（分模块开发）"></a>6. 引入其他配置文件（分模块开发）</h3><p>实际开发中，Spring 的配置内容非常多，导致配置很繁杂并且体积大，</p><p>所以可以将部分配置拆解到其他配置文件中，而在 Spring 主配置文件中，</p><p>通过 import 标签进行加载。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring快速开始</title>
      <link href="/2022/01/31/1-Spring%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>/2022/01/31/1-Spring%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring快速开始"><a href="#Spring快速开始" class="headerlink" title="Spring快速开始"></a>Spring快速开始</h2><span id="more"></span><p><strong>PS：仅作为个人学习笔记，以后深入学习再补充</strong></p><p>Spring 学习笔记地址：<a href="https://github.com/Eminem-x/Spring">https://github.com/Eminem-x/Spring</a></p><p>SpringBoot学习笔记地址：<a href="https://github.com/Eminem-x/SpringBoot">https://github.com/Eminem-x/SpringBoot</a></p><p>推荐 Spring 学习视频：<a href="https://www.bilibili.com/video/BV1WZ4y1P7Bp?from=search&seid=9648668674109084850&spm_id_from=333.337.0.0">黑马程序员 SSM 框架教程</a></p><p>推荐 SpringBoot 学习视频：<a href="https://www.bilibili.com/video/BV19K4y1L7MT?from=search&seid=14164871616704737958&spm_id_from=333.337.0.0">尚硅谷 雷神 SpringBoot 学习</a></p><p>SpringBoot 学习参考：<a href="http://www.ityouknow.com/springboot/2016/01/06/spring-boot-quick-start.html">ityouknow-SpringBoot学习</a></p><hr><h3 id="1-Spring程序开发步骤"><a href="#1-Spring程序开发步骤" class="headerlink" title="1. Spring程序开发步骤"></a>1. Spring程序开发步骤</h3><ol><li>导入 Spring 开发的基本包坐标（通过Maven）；</li><li>创建 Bean；</li><li>创建 Spring 核心配置文件；</li><li>在 Spring 配置文件中进行配置；</li><li>使用 Spring 的 API 获得 Bean 实例；</li></ol><h3 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2. 基本概念"></a>2. 基本概念</h3><ol><li><p>Dao 是数据访问层，Service 是业务层；</p></li><li><p>Dao 的作用是封装对数据库的访问：CRUD，不涉及业务逻辑；</p></li><li><p>Service 则专注业务逻辑，对于其中需要的数据库操作，通过 Dao 实现；</p></li><li><p>这样的分层是<strong>基于 MVC 架构</strong>而言：</p><p>M是指业务模型（model），V是指用户界面（view），C则是控制器（controller），</p><p>使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。</p></li><li><p>分层的作用是 <strong>解耦</strong>；</p></li><li><p><strong>对于 Spring 框架：</strong></p><p>（View\Web）表示层调用控制层（Controller），</p><p>控制层调用业务层（Service），</p><p>业务层调用数据访问层（Dao）。</p></li><li><p><strong>Bean 是一个被实例化，组装，并通过 Spring IoC 容器所管理的对象。</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis应用</title>
      <link href="/2022/01/31/4-Redis%E5%BA%94%E7%94%A8/"/>
      <url>/2022/01/31/4-Redis%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis应用"><a href="#Redis应用" class="headerlink" title="Redis应用"></a>Redis应用</h2><span id="more"></span><h3 id="1-秒杀"><a href="#1-秒杀" class="headerlink" title="1. 秒杀"></a>1. 秒杀</h3><ol><li><p><strong>关于 Postman 和 JMeter 的选择</strong></p><p>推荐选择 JMeter，因为 Postman 只能支持串行接口测试</p><p>JMeter 推荐参考文章：</p><ul><li><p><a href="https://www.jianshu.com/p/0e4daecc8122">JMeter入门教程 - 简书 (jianshu.com)</a></p></li><li><p><a href="https://www.cnblogs.com/summerstore/p/11529105.html">如何使用JMeter进行并发测试 - 你安静了夏天 - 博客园 (cnblogs.com)</a></p></li></ul><p>Postman 关于能否并发：<a href="https://www.zhihu.com/question/280155125">https://www.zhihu.com/question/280155125</a></p></li><li><p><strong>出现的问题</strong></p><ul><li><p>超时：节省每次连接 Redis 服务带来的消耗，使用连接池解决</p></li><li><p>超卖：使用乐观锁，事务提交，解决超出库存的问题</p></li><li><p>库存遗留问题：由于乐观锁的机制造成仍有库存遗留</p><p><strong>通过 LUA 脚本解决争抢问题</strong>，实际上是 Redis 利用其单线程的特性，</p><p>用任务队列的方式解决多任务并发问题</p></li></ul></li></ol><hr><h3 id="2-缓存穿透"><a href="#2-缓存穿透" class="headerlink" title="2. 缓存穿透"></a>2. 缓存穿透</h3><ol><li><p>概念</p><p>使用 Redis 大部分情况都是通过 key 查询对应的值，</p><p>假如发送的请求传进来的 key 是不存在 Redis 中的，</p><p>那么就查不到缓存，查不到缓存就会去数据库查询，</p><p>假如有大量这样的请求，这些请求像“穿透”了缓存一样直接打在数据库上。</p></li><li><p>解决方案</p><ol><li><p><strong>把无效的 key 存进 Redis 中</strong></p><p>如果Redis查不到数据，数据库也查不到，我们把这个 key 值保存进 Redis，</p><p>设置 value=”null”，当下次再通过这个 key 查询时就不需要再查询数据库，</p><p>这种方式是有问题的，若不存在的 Key 值每次都是随机的，存进Redis也没有意义。</p></li><li><p><strong>设置可访问的名单（白名单）</strong></p></li><li><p><strong>采用布隆过滤器（Boom Filter）</strong></p><p>布隆过滤器的作用是某个 key 不存在，那么就一定不存在，</p><p>它说某个 key 存在，那么很大可能是存在(存在一定的误判率)，</p><p>于是我们可以在缓存之前再加一层布隆过滤器，</p><p>在查询的时候先去布隆过滤器查询 key 是否存在，如果不存在就直接返回。</p></li><li><p><strong>进行实时监控</strong></p><p>当发现 Redis 的命中率开始急速降低时，需要排查访问对象和访问的数据，</p><p>以及运维人员配合，可以设置黑名单限制服务。</p></li></ol></li></ol><hr><h3 id="3-缓存击穿"><a href="#3-缓存击穿" class="headerlink" title="3. 缓存击穿"></a>3. 缓存击穿</h3><ol><li><p>概念</p><p>缓存击穿是一个热点的 key ，有大并发集中对其进行访问，</p><p>突然间这个 key 失效了，导致大并发全部打在数据库上，</p><p>导致数据库压力剧增，这种现象就叫做缓存击穿。</p></li><li><p>解决方案</p><ol><li><p><strong>预先设置热门数据</strong></p><p>如果业务允许的话，对于热点的 key 可以设置永不过期，</p><p>或者加大热门数据 key 的过期时长。</p></li><li><p><strong>实时调整</strong></p><p>现场监控哪些数据热门，实时调整 key 的过期时长。</p></li><li><p><strong>使用互斥锁</strong></p><p>如果缓存失效的情况，只有拿到锁才可以查询数据库，</p><p>降低了在同一时刻打在数据库上的请求，防止数据库打死，</p><p>当然这样会导致系统的性能变差。</p></li></ol></li></ol><hr><h3 id="4-缓存雪崩"><a href="#4-缓存雪崩" class="headerlink" title="4. 缓存雪崩"></a>4. 缓存雪崩</h3><ol><li><p>概念</p><p>当某一个时刻出现大规模的缓存失效的情况，</p><p>那么就会导致大量的请求直接打在数据库上面，导致数据库压力巨大，</p><p>如果在高并发的情况下，可能瞬间就会导致数据库宕机，</p><p>这时如果马上重启数据库，马上又会有新的流量把数据库打死，这就是缓存雪崩。</p></li><li><p>解决方案</p><ol><li><p><strong>构建多级缓存架构</strong></p><p>nginx + redis + 其他缓存</p></li><li><p><strong>使用锁或队列</strong></p><p>用加锁或队列的方式保证不会有大量的线程对数据库一次性读写，</p><p>从而避免失效时大量的并发请求落到底层存储系统上，不适用高并发情况</p></li><li><p><strong>设置过期标志更新缓存</strong></p><p>如果过期会触发通知另外的线程在后台去更新实际 key 的缓存</p></li><li><p><strong>将缓存失效时间分散</strong></p><p>在失效时间上加上一个随机值，避免因为相同的过期时间导致缓存雪崩</p></li><li><p><strong>熔断机制</strong></p><p>当流量到达一定的阈值时，就直接返回“系统拥挤”之类的提示，</p><p>防止过多的请求打在数据库上，至少能保证一部分用户是可以正常使用，</p><p>其他用户多刷新几次也能得到结果。</p></li></ol></li></ol><hr><h3 id="5-分布式锁"><a href="#5-分布式锁" class="headerlink" title="5. 分布式锁"></a>5. 分布式锁</h3><ol><li><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，</p><p>由于分布式系统多线程、多进程并且分布在不同机器上，</p><p>这使原单机部署情况下的并发控制锁策略失效，</p><p>单纯的 Java API 并不能提供分布式锁的能力，为了解决这个问题，</p><p>需要一种跨 JVM 的互斥机制来控制共享资源的访问</p></li><li><h5 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h5><ol><li>基于数据库实现分布式锁</li><li><strong>基于缓存（Redis 等）</strong></li><li>基于 Zookeeper</li></ol></li><li><h5 id="使用-redis-实现分布式锁"><a href="#使用-redis-实现分布式锁" class="headerlink" title="使用 redis 实现分布式锁"></a><strong>使用 redis 实现分布式锁</strong></h5><ol><li>设置锁和过期时间</li><li>UUID 防止误删</li><li>LUA 保证删除原子性</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis进阶</title>
      <link href="/2022/01/31/3-Redis%E8%BF%9B%E9%98%B6/"/>
      <url>/2022/01/31/3-Redis%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis进阶"><a href="#Redis进阶" class="headerlink" title="Redis进阶"></a>Redis进阶</h2><span id="more"></span><h3 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a><strong>RDB</strong>（Redis DataBase）</h3><ol><li><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>在指定时间间隔内将内存中的数据集快照写入磁盘</p></li><li><h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><p>Redis 会<strong>单独创建（fork）</strong>一个子进程来进行持久化，会先将数据写入到一个临时文件，</p><p>待持久化过程结束，再用临时文件替换上次持久化好的文件，<strong>默认 dump.rdb</strong></p></li><li><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p>优点：</p><ol><li><p>整个过程中，主进程不进行任何 IO 操作，这就确保了极高的性能</p></li><li><p>如果对数据恢复的完整性不敏感，那么比 AOF 更加高效。</p></li><li><p>节省磁盘空间，恢复速度快</p></li></ol><p>缺点：</p><ol><li>最后一次持久化后的数据可能丢失</li><li>虽然使用了写时复制技术，但是如果数据庞大还是比较消耗性能</li><li>Fork 的时候内存中的数据被克隆一份，大致 2 倍的膨胀性需要考虑</li></ol></li><li><h5 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h5><ol><li><p>Fork 的作用是复制一个与当前进程一样的进程，所有的数据均一致，</p><p>但是是一个全新的进程，并作为原进程的子进程</p></li><li><p><strong>写时复制技术</strong></p></li><li><p>一般情况父进程和子进程共用一段物理内存</p></li></ol></li></ol><hr><h3 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a><strong>AOF</strong>（Append Only File）</h3><ol><li><p><strong>概念</strong></p><p>以日志的形式来记录每个写操作（增量保存），</p><p>将 Redis 执行过的所有写指令记录下来（读操作不记录），</p><p>只许追加文件但不可以改写文件，Redis 启动时会读取文件重构数据</p></li><li><p><strong>流程</strong></p><ul><li>客户端的请求写命令会被 append 追加到 AOF 缓冲区内</li><li>AOF 缓存区根据 AOF 持久化策略将操作 sync 同步到磁盘 AOF 文件</li><li>AOF 文件大小超过重写策略或手动重写时，进行 rewrite 重写和压缩</li><li>Redis 服务启动时，会重新加载 AOF 文件中的写操作恢复数据</li></ul></li><li><p><strong>设置</strong></p><ol><li>AOF 默认不开启，需要在配置文件中将 <code>appendonly</code> 改为 <code>yes</code></li><li>AOF 和 RDB 同时开启时，系统默认取 AOF 的数据<strong>（数据不会存在丢失）</strong></li><li>异常通过 <code>redis-check-aof --fix appendonly,aof</code> 恢复文件，重启即可</li><li>同步频率设置 appendfsync：<ul><li>always：始终同步，每次 Redis 的写入都会立刻记入日志，完整性好但性能差</li><li>everysec：每秒同步，如果宕机，本秒的数据可能丢失</li><li>no：不主动进行同步，把同步时机交给操作系统</li></ul></li><li>Rewrite 压缩：避免 AOF 文件过大，采用重写机制，将内容压缩</li></ol></li><li><p><strong>优缺点</strong></p><p>优点：</p><ol><li>备份机制更稳健，丢失数据概率更低</li><li>可读的日志文本，可以处理误操作</li></ol><p>缺点：</p><ol><li>占用更多的磁盘空间</li><li>恢复备份速度慢</li><li>每次读写都同步的话，存在一定的性能压力</li><li>存在个别 bug，造成恢复不能</li></ol></li></ol><hr><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ol><li>官方推荐两个都启用</li><li>如果对数据不敏感，可以单独使用 RDB</li><li>不建议单独使用 AOF，可能会出现 bug</li><li>如果只是做纯内存缓存，可以都不用</li></ol><hr><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><ol><li><p><strong>概念</strong></p><p>主机数据更新后根据配置和策略，自动同步到备机的 <strong>master/slaver 机制，</strong></p><p>master 以写为主，slaver 以读为主，但是会存在<strong>复制延时</strong>的情况，</p><p>当系统繁忙或 slaver 机器数量增加的时候，延迟问题会更加严重</p></li><li><p><strong>作用</strong></p><ul><li>读写分离，性能拓展</li><li>容灾快速恢复</li></ul></li><li><p><strong>搭建简单的一主两从</strong></p><ol><li><p>创建 <code>/myRedis</code> 文件夹，拷贝 <code>redis.Windows.conf</code> 文件至目录下</p></li><li><p>配置一主两从，创建三个配置文件</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis6379.<span class="keyword">conf</span></span><br><span class="line">redis6380.<span class="keyword">conf</span></span><br><span class="line">redis6381.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure></li><li><p>在每个配置文件中写入以下内容（替换 6379 即可）</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> redis.windows.<span class="keyword">conf</span></span><br><span class="line">pidfile /<span class="keyword">var</span>/<span class="keyword">run</span>/redis_6379.pid</span><br><span class="line">port 6379</span><br><span class="line">dbfilename dump6379.rdb</span><br></pre></td></tr></table></figure></li><li><p>启动三个 Redis 服务</p><ul><li>查看当前主机运行状况</li><li>在从机上执行 <code>slaveof</code> 主机 ip 端口号</li><li><code>SLAVEOF 127.0.0.1 6379</code> 配置主从关系</li><li>验证主从的基本性质，master 以写为主，slaver 以读为主</li></ul></li></ol></li><li><p><strong>主从复制特点</strong></p><ul><li>一主二仆</li><li>薪火相传</li><li>反客为主</li></ul></li><li><p><strong>哨兵模式</strong></p><ol><li><p>反客为主的自动版，能够后台监控主机是否故障，根据投票数将从库转为主库</p></li><li><p>模拟案例</p><ol><li><p>建立一个简易的一主二仆模式</p></li><li><p>在 <code>/myRedis</code> 目录下建立 <code>sentinel.conf</code> 文件</p></li><li><p>写入 <code>sentinel monitor mymaster 127.0.0.1 6379 1</code> </p><p><code>mymaster</code> 为监控对象起的名称，<code>1</code> 为至少有多少个哨兵同意迁移的数量</p></li><li><p>如果你使用 <code>redis-sentinel</code> 可执行文件，你可以使用下面的命令来运行 <code>Sentinel</code>：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel <span class="regexp">/path/</span>to/sentinel.conf</span><br></pre></td></tr></table></figure><p>另外，你可以直接使用 <code>redis-server</code> 并以 <code>Sentinel</code> 模式来启动：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-<span class="keyword">server</span> /<span class="type">path</span>/<span class="keyword">to</span>/sentinel.conf <span class="comment">--sentinel</span></span><br></pre></td></tr></table></figure></li><li><p>将主机关闭，查看结果即可</p></li></ol></li><li><p>选择条件依次如下</p><ul><li>选择优先级靠前的（redis.conf 中的 slave-priority 值越小优先级越高）</li><li>选择偏移量最大的（获得最全原主机数据的从服务）</li><li>选择 runid 最小地从服务（每个 Redis 启动后随机生成的 40 位 runid）</li></ul></li></ol><hr><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><ol><li><h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h5><p>Redis 集群实现了对 Redis 的水平扩容，即启动 N 个 Redis 节点，</p><p>将整个数据库分布存储在这 N 个节点中，每个节点存储总数据的 1/N，</p><p>集群通过分区来提供一定程度的可用性，即使集群中有一部分节点失效或者无法进行通讯，</p><p>集群也可以继续处理命令请求</p></li><li><h5 id="搭建简易集群"><a href="#搭建简易集群" class="headerlink" title="搭建简易集群"></a>搭建简易集群</h5><ol><li><p>在目录下创建六份实例 <code>redis.conf</code></p></li><li><p>在主从的基础上，添加以下内容（替换 6379 即可）</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cluster</span>-enabled yes</span><br><span class="line"><span class="keyword">cluster</span>-config-<span class="keyword">file</span> nodes-6379.<span class="keyword">conf</span></span><br><span class="line"><span class="keyword">cluster</span>-node-timeout 15000</span><br></pre></td></tr></table></figure></li><li><p>启动六个 Redis 服务，将节点合成一个集群</p><p>启动服务后，确保所有的 <code>nodes-xxxx.conf</code> 文件生成正常</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create --cluster-replicas <span class="number">1 127.0.0</span>.<span class="number">1:6379 127</span>.<span class="number">0</span>.<span class="number">0.1:6380</span> <span class="number">127.0.0.1</span>:<span class="number">6381 127.0</span>.<span class="number">0.1:6389</span> <span class="number">127.0.0.1</span>:<span class="number">6390 127.0</span>.<span class="number">0.1:6391</span></span><br></pre></td></tr></table></figure><p>通过任意节点进入集群 <code>redis-cli.exe -p 6379</code></p><p>查看集群节点信息 <code>cluster nodes</code></p></li></ol></li><li><h5 id="如何分配节点"><a href="#如何分配节点" class="headerlink" title="如何分配节点"></a>如何分配节点</h5><p><code>--cluster-replicas 1</code> 表示为集群中的每个主节点创建一个从节点</p><p>分配原则尽量保证每个主数据库运行在不同的 IP 地址，每个主库和从库不在一个 IP 地址上</p></li><li><h5 id="插槽-Hash-Slot"><a href="#插槽-Hash-Slot" class="headerlink" title="插槽 Hash Slot"></a>插槽 Hash Slot</h5><p>一个集群包含 <code>16384</code> 个插槽，数据库中的每个键都属于其中一个，</p><p>集群使用公式 <code>CRC16(key) % 16384</code> 来计算 key 属于哪个槽，</p><p>而集群中的每个节点负责处理一部分插槽</p></li><li><p><strong>故障恢复</strong></p><ul><li><p>如果主节点宕机，从节点根据超时时间自动升为主节点</p></li><li><p>主节点恢复后，主节点变成从机</p></li><li><p>如果所有某段插槽的主从节点都宕机，</p><p>集群根据 <code>cluster-require-full-coverage</code> 是否宕机</p></li></ul></li><li><h5 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h5><p>优点：</p><ol><li>实现扩容</li><li>分摊压力</li><li>无中心配置相对简单</li></ol><p>缺点：</p><ol><li>多键操作是不支持的</li><li>多键的 Redis 事务是不被支持的，lua 脚本不被支持</li><li>出现较晚，目前整体迁移复杂度较大</li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis特性</title>
      <link href="/2022/01/31/2-Redis%E7%89%B9%E6%80%A7/"/>
      <url>/2022/01/31/2-Redis%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis特性"><a href="#Redis特性" class="headerlink" title="Redis特性"></a>Redis特性</h2><span id="more"></span><h3 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1. 配置文件"></a>1. 配置文件</h3><p>配置信息存储在 <code>redis.windows.conf</code> 文件</p><h3 id="2-发布订阅"><a href="#2-发布订阅" class="headerlink" title="2. 发布订阅"></a>2. 发布订阅</h3><ol><li><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>发布订阅（pub / sub）是一种消息通信模式：</p><p>发送者（pub）发送信息，订阅者（sub）接收信息，</p><p>Redis 客户端可以订阅任意数量的频道，发布的消息没有持久化</p></li><li><h5 id="命令行实现"><a href="#命令行实现" class="headerlink" title="命令行实现"></a>命令行实现</h5><ol><li><p>打开一个客户端订阅 channel1</p><p><code>subscribe channel1</code></p></li><li><p>打开另一个客户端，给 channel1 发布消息</p><p><code>public channel1 helloworld</code></p></li><li><p>打开第一个客户端可以接收到发送的信息</p></li></ol></li></ol><h3 id="3-新数据类型"><a href="#3-新数据类型" class="headerlink" title="3. 新数据类型"></a>3. 新数据类型</h3><ol><li><p><strong>Bitmaps</strong></p><p>   合理地使用操作位能够有效地提高内存使用率和开发效率</p><p>   Redis 提供 Bitmaps 实现对位的操作：</p><ul><li><p>本身不是一种数据类型，实际上就是字符串，不过可以对位进行操作</p></li><li><p>提供单独的一套命令，可以堪称一个以位为单位的数组</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setbit key <span class="keyword">offset</span> <span class="keyword">value</span>设置 Bitmaps 中某个偏移量的值</span><br><span class="line">getbit key <span class="keyword">offset</span>获取 Bitmaps 中某个偏移量的值</span><br><span class="line">bitcount key <span class="keyword">start</span> <span class="keyword">end</span>统计字符串被设置为 <span class="number">1</span> 的 bit 数</span><br><span class="line">bitop op dest src多功能符合操作</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>HyperLogLog</strong></p><p>工作当中，会遇到<strong>基数问题：</strong>求集合中不重复元素的个数，解决方案：</p><ol><li>数据存储在 MySQL 中，使用 <code>distinct count</code> 计算不重复个数</li><li>使用 Redis 提供的 hash、set、bitmaps 等数据结构来处理</li></ol><p>以上方案的结果准确，但是随着数据规模增加，导致占用空间非常大，</p><p><strong>而 HyperLogLog 可以降低一定的精度来平衡存储空间，用来做基数统计。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pfadd key element添加指定元素到 HyperLogLog 中</span><br><span class="line">pfcount key计算 HLL 近似基数值</span><br><span class="line">pfmerge dest src将一个或多个 HLL 合并后的结果存在 dest 中 </span><br></pre></td></tr></table></figure></li><li><p><strong>Geospatial</strong></p><p>对 GEO 类型的支持，<strong>GEO（Geographic）地理信息的缩写，二维坐标</strong></p><p>基于该类型，提供了经纬度设置、范围查询、距离查询等常见操作</p></li></ol><h3 id="5-事务和锁机制"><a href="#5-事务和锁机制" class="headerlink" title="5. 事务和锁机制"></a>5. 事务和锁机制</h3><ol><li><h5 id="事务概念"><a href="#事务概念" class="headerlink" title="事务概念"></a>事务概念</h5><p>Redis 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行，</p><p>事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p></li><li><h5 id="事务作用"><a href="#事务作用" class="headerlink" title="事务作用"></a>事务作用</h5><p>Redis 事务的主要作用就是串联多个命令防止别的命令插队</p></li><li><h5 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h5><ul><li>Multi：输入的命令依次进入命令队列中</li><li>Exec：将之前的命令队列中的命令依次执行</li><li>Discard：放弃组队</li></ul></li><li><h5 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h5><ol><li><h6 id="单独的隔离操作"><a href="#单独的隔离操作" class="headerlink" title="单独的隔离操作"></a><strong>单独的隔离操作</strong></h6><p>事务中的所有命令都会序列化、按顺序地执行，事务在执行的过程中，</p><p>不会被其他客户端发送来的命令请求所打断</p></li><li><h6 id="没有隔离级别的概念"><a href="#没有隔离级别的概念" class="headerlink" title="没有隔离级别的概念"></a><strong>没有隔离级别的概念</strong></h6><p>队列中的命令没有提交之前都不会实际被执行，</p><p>因为事务提交前任何指令都不会被实际执行</p></li><li><h6 id="不保证原子性"><a href="#不保证原子性" class="headerlink" title="不保证原子性"></a><strong>不保证原子性</strong></h6><p>事务中如果有一条命令执行失败，其后的命令仍然会被执行，不回滚</p></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础</title>
      <link href="/2022/01/31/1-Redis%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/01/31/1-Redis%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h2><span id="more"></span><h3 id="1-安装和使用"><a href="#1-安装和使用" class="headerlink" title="1. 安装和使用"></a>1. 安装和使用</h3><p>安装：<a href="https://www.runoob.com/redis/redis-install.html">Redis 安装 | 菜鸟教程 (runoob.com)</a></p><p>推荐视频：<a href="https://www.bilibili.com/video/BV1Rv41177Af?from=search&seid=8211878355588508937&spm_id_from=333.337.0.0">【尚硅谷】Redis 6 入门到精通 超详细 教程_哔哩哔哩_bilibili</a></p><p>使用：</p><ol><li><p>打开一个 <strong>cmd</strong> 窗口 使用 cd 命令切换目录到 <strong>C:\redis</strong> 运行</p><p><code>redis-server.exe redis.windows.conf</code></p></li><li><p>另启一个 <strong>cmd</strong> 窗口，原来的不要关闭，不然就无法访问服务端</p><p><code>redis-cli.exe -h 127.0.0.1 -p 6379</code></p></li></ol><h3 id="2-基础操作"><a href="#2-基础操作" class="headerlink" title="2. 基础操作"></a>2. 基础操作</h3><ol><li><p>默认 <code>16</code> 个数据库，初始默认使用 <code>0</code> 号库</p></li><li><p>统一密码管理，所有库的密码相同</p></li><li><p><code>key</code> 键操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">keys <span class="operator">*</span> 查看当前库所有 key </span><br><span class="line"><span class="keyword">exists</span> key判断是否存在某 key</span><br><span class="line">type key查看某 key 的类型</span><br><span class="line">del key删除指定的 key</span><br><span class="line">unlink key根据 <span class="keyword">value</span> 选择非阻塞删除</span><br><span class="line">expire key为给定 key 设置过期时间</span><br><span class="line">ttl key查看还有多少秒 key 过期<span class="number">-1</span>表示永不,<span class="number">-2</span>表示已过期</span><br><span class="line"><span class="keyword">select</span> key命令切换数据库</span><br><span class="line">dbsize查看当前数据库的 key 数量</span><br><span class="line">flushdb清空当前数据库</span><br><span class="line">flushall清空所有数据库</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-数据类型："><a href="#3-数据类型：" class="headerlink" title="3. 数据类型："></a>3. 数据类型：</h3><ol><li><h5 id="String-字符串类型"><a href="#String-字符串类型" class="headerlink" title="String 字符串类型"></a>String 字符串类型</h5><p>String 的数据结构为简单动态字符串 <strong>（Simple Dynamic String - SDS）</strong>，是可修改的字符串，</p><p>尽管 Redis 是用 C 写的，但是并未使用 C 的字符串表示，而是对char*进行了简单的包装，</p><p>采用预分配冗余空间的方式来减少内存的频繁分配，</p><p>扩容是加倍现有的空间，但是最大长度为 <strong>512M</strong></p><ul><li><p><a href="https://blog.csdn.net/qq_43561507/article/details/109148830">C语言字符串和 SDS 之间的区别</a></p></li><li><p><a href="https://blog.csdn.net/darker0019527/article/details/102995888">二者之间的详细对比</a></p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> key <span class="keyword">value</span> 添加键值对，重复则会覆盖</span><br><span class="line"><span class="keyword">get</span> key查询对应键值</span><br><span class="line">append key <span class="keyword">value</span>将给定的 <span class="keyword">value</span> 追加到原值的末尾</span><br><span class="line">strlen key获得值的长度</span><br><span class="line">setnx key <span class="keyword">value</span>只有在 key 不存在时，设置 key 的值</span><br><span class="line">incr<span class="operator">/</span>decr key将 key 中存储的数字增加<span class="operator">/</span>减少 <span class="number">1</span></span><br><span class="line">incrby<span class="operator">/</span>decrby key len将 key 中存储的数字值增减，自定义步长</span><br><span class="line">mset key1 value...同时设置一个或多个 key<span class="operator">-</span><span class="keyword">value</span> 对</span><br><span class="line">mget key1 key2...同时获取一个或多个 <span class="keyword">value</span></span><br><span class="line">msetnx key1 value...同时设置一个或多个 key<span class="operator">-</span><span class="keyword">value</span> 对，当且仅当所有给定 key 不存在</span><br><span class="line">getrange key <span class="keyword">start</span> <span class="keyword">end</span>获得值的范围</span><br><span class="line">setrange key pos <span class="keyword">value</span>从 pos 开始用 <span class="keyword">value</span> 复写 key 所存储的字符串值</span><br><span class="line">setex key <span class="type">time</span> <span class="keyword">value</span>设置键值的同时，设置过期时间，单位秒</span><br><span class="line">getset key <span class="keyword">value</span>以新换旧，设置新值的同时获得旧值</span><br></pre></td></tr></table></figure></li></ul></li><li><h5 id="List-列表类型"><a href="#List-列表类型" class="headerlink" title="List 列表类型"></a>List 列表类型</h5><p>List 的底层实际是双向链表，对两端的操作性能较高，但是查询索引性能较差，</p><p>数据结构为快速链表（<strong>quickList</strong>），列表元素较少的情况下会使用一块连续的内存存储，</p><p>这个结构称为压缩列表 <strong>（zipList）</strong>，当数据量较多时，多个压缩列表组成快速链表，</p><p>简单的字符串列表，按照插入顺序排序，可以在列表首尾添加元素</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lpush<span class="operator">/</span>rpush key value...在左<span class="operator">/</span>右边插入一个或多值</span><br><span class="line">lpop<span class="operator">/</span>rpop key从左<span class="operator">/</span>右边弹出一个值，值在键在，值光键亡</span><br><span class="line">rpoplpush key1 key2从 key1 列表右边弹出一个值查到 key2 列表左边</span><br><span class="line">lrange key <span class="keyword">start</span> <span class="keyword">end</span>按照索引下标获得元素（从左到右）</span><br><span class="line">lrange key <span class="number">0</span> <span class="number">-1</span>获取所有元素</span><br><span class="line">lindex key index按照索引下标获得元素（从左到右）</span><br><span class="line">llen key获得列表长度</span><br><span class="line">linsert key before v1 v2在 v1 的前面插入 v2</span><br><span class="line">lrem key n <span class="keyword">value</span>从左边删除 n 个 <span class="keyword">value</span></span><br><span class="line">lset key index <span class="keyword">value</span>将列表 key 下标为 index 的只替换为 <span class="keyword">value</span></span><br></pre></td></tr></table></figure></li><li><h5 id="Set-集合类型"><a href="#Set-集合类型" class="headerlink" title="Set 集合类型"></a>Set 集合类型</h5><p>Set 提供的功能整体与 List 类似，特殊之处在于 Set 可以<strong>自动排重</strong>，</p><p>并且提供了判断某个成员是否在一个集合内的接口，底层无序集合，hash 表实现，</p><p>所以添加、删除、查找的时间复杂度都是 O（1），<strong>数据结构是 dict 字典</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sadd key value...将一个或多个元素不重复地加入到集合</span><br><span class="line">smembers key取出该集合地所有值</span><br><span class="line">sismember key <span class="keyword">value</span>判断集合 key 是否含有该 <span class="keyword">value</span> 值,有 <span class="number">1</span> 无 <span class="number">0</span></span><br><span class="line">scard key返回该集合地元素个数</span><br><span class="line">srem key value...删除集合中一个或多个元素</span><br><span class="line">spop key从该集合中随机弹出一个元素</span><br><span class="line">srandmember key n从该集合中随机取出 n 个元素</span><br><span class="line">smove src des <span class="keyword">value</span>将集合中地某个元素移动到另一个集合</span><br><span class="line">sinter key1 key2返回两个集合的交集元素</span><br><span class="line">sunion key1 key2返回两个集合的并集元素</span><br><span class="line">sdiff key1 key2返回两个集合的差集元素</span><br></pre></td></tr></table></figure></li><li><h5 id="Hash-哈希类型"><a href="#Hash-哈希类型" class="headerlink" title="Hash 哈希类型"></a>Hash 哈希类型</h5><p>键值对集合，String 类型的 field 和 value 的映射表，适合用于存储对象</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hset key field <span class="keyword">value</span>给 key 中的 field 键赋值 <span class="keyword">value</span></span><br><span class="line">hget key field 从 key 中取出 field 的 <span class="keyword">value</span></span><br><span class="line">hmset key field value...批量设置 hash 值</span><br><span class="line">hexists key filed查看哈希表中，是否存在键 field</span><br><span class="line">hkeys key列出该 hash 集合中所有 field</span><br><span class="line">hvals key列出该 hash 集合中所有 <span class="keyword">value</span></span><br><span class="line">hincrby key field inc为 hash 中 field 的值上增量 <span class="number">1</span><span class="operator">/</span><span class="number">-1</span></span><br><span class="line">hsetnx key field <span class="keyword">value</span>当且仅当不存在设置键值对</span><br></pre></td></tr></table></figure></li><li><h5 id="Zset-有序集合"><a href="#Zset-有序集合" class="headerlink" title="Zset 有序集合"></a>Zset 有序集合</h5><p>Zset 与普通集合大体相似，不同之处在于有序集合的每个成员关联一个<strong>评分（score）</strong>，</p><p>评分被用来按照从低到高的方式排序集合中的成员，成员唯一，但是评分可以重复，</p><p>SortedSet（Zset）是一个非常特别的数据结构，<strong>底层使用两个数据结构：hash 和 跳跃表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">zadd key score value...将一个或多个元素及其 score 值加入到有序集中</span><br><span class="line">zrange key <span class="keyword">start</span> stop返回下标在 <span class="keyword">start</span> 和 pop 之间的元素</span><br><span class="line">zrangebyscore key min max返回 score 值介于 min 和 max 之间的元素</span><br><span class="line">zincrbykey inc <span class="keyword">value</span>为元素的 score 加上增量</span><br><span class="line">zrem key <span class="keyword">value</span>删除指定元素</span><br><span class="line">zcount key min max统计分数区间内的元素个数</span><br><span class="line">zrank key <span class="keyword">value</span>返回该值在集合中的排名</span><br></pre></td></tr></table></figure></li></ol><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回旋镖的数量</title>
      <link href="/2022/01/27/%E5%9B%9E%E6%97%8B%E9%95%96%E7%9A%84%E6%95%B0%E9%87%8F/"/>
      <url>/2022/01/27/%E5%9B%9E%E6%97%8B%E9%95%96%E7%9A%84%E6%95%B0%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="回旋镖的数量"><a href="#回旋镖的数量" class="headerlink" title="回旋镖的数量"></a>回旋镖的数量</h3><span id="more"></span><blockquote><p>题目详情参考：<a href="https://leetcode-cn.com/problems/number-of-boomerangs/">447. 回旋镖的数量 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><ol><li>遍历点数组，分别求出当前点与其他点的距离，存储在哈希表中</li><li>在哈希表中统计键值相同的数量，注意可以更换位置，即求两次</li><li>重复上述过程，得出结果，不过时间复杂度较高</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfBoomerangs</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] p : points) &#123;</span><br><span class="line">            Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] q : points) &#123;</span><br><span class="line">                <span class="keyword">int</span> dis = (p[<span class="number">0</span>] - q[<span class="number">0</span>]) * (p[<span class="number">0</span>] - q[<span class="number">0</span>]) + (p[<span class="number">1</span>]- q[<span class="number">1</span>]) * (p[<span class="number">1</span>]- q[<span class="number">1</span>]);</span><br><span class="line">                map.put(dis,map.getOrDefault(dis,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">                <span class="keyword">int</span> m = entry.getValue();</span><br><span class="line">                ans += m * (m - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 哈希 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>检测正方形</title>
      <link href="/2022/01/27/%E6%A3%80%E6%B5%8B%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
      <url>/2022/01/27/%E6%A3%80%E6%B5%8B%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="检测正方形"><a href="#检测正方形" class="headerlink" title="检测正方形"></a>检测正方形</h3><span id="more"></span><blockquote><p>题目详情参考：<a href="https://leetcode-cn.com/problems/detect-squares/">2013. 检测正方形 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><p><strong>题目的思路比较明确，但是处理的方法需要注意：哈希嵌套</strong></p><ol><li>将每个点按照纵坐标的值，存储在哈希表中</li><li>在哈希表的基础上，将 <code>value</code> 值也使用哈希表存储</li><li>当检测某个点时，只需查看相同纵坐标下，彼此点之间的距离</li><li>点之间的距离即为待检测正方形的边长，随后分类讨论左右是否存在</li><li>与此同时，需要注意点的个数，统计重复正方形</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetectSquares</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; cnt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DetectSquares</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt = <span class="keyword">new</span> HashMap&lt;Integer, Map&lt;Integer, Integer&gt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>[] point)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = point[<span class="number">0</span>], y = point[<span class="number">1</span>];</span><br><span class="line">        cnt.putIfAbsent(y, <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;());</span><br><span class="line">        Map&lt;Integer, Integer&gt; yCnt = cnt.get(y);</span><br><span class="line">        yCnt.put(x, yCnt.getOrDefault(x, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span>[] point)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x = point[<span class="number">0</span>], y = point[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (!cnt.containsKey(y)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; yCnt = cnt.get(y);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Map&lt;Integer, Integer&gt;&gt; entry : cnt.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> col = entry.getKey();</span><br><span class="line">            Map&lt;Integer, Integer&gt; colCnt = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (col != y) &#123;</span><br><span class="line">                <span class="comment">// 根据对称性，这里可以不用取绝对值</span></span><br><span class="line">                <span class="keyword">int</span> d = col - y;</span><br><span class="line">                res += colCnt.getOrDefault(x, <span class="number">0</span>) * </span><br><span class="line">                   yCnt.getOrDefault(x + d, <span class="number">0</span>) * colCnt.getOrDefault(x + d, <span class="number">0</span>);</span><br><span class="line">                res += colCnt.getOrDefault(x, <span class="number">0</span>) * </span><br><span class="line">                   yCnt.getOrDefault(x - d, <span class="number">0</span>) * colCnt.getOrDefault(x - d, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 哈希 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏中弱角色的数量</title>
      <link href="/2022/01/24/%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/"/>
      <url>/2022/01/24/%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="游戏中弱角色的数量（数学）"><a href="#游戏中弱角色的数量（数学）" class="headerlink" title="游戏中弱角色的数量（数学）"></a>游戏中弱角色的数量（数学）</h3><span id="more"></span><blockquote><blockquote><p>题目详情参考：<a href="https://leetcode-cn.com/problems/the-number-of-weak-characters-in-the-game/">1996. 游戏中弱角色的数量 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote></blockquote><p>如何对数组进行合适的排序，可以使该问题的答案更为简洁</p><p>首先需要明确以下两点：</p><ol><li>如果一个角色为弱角色，那么它只会被统计一次</li><li>同等级的攻击不会出现弱角色</li><li><strong>lambda 表达式的写法，简化排序 </strong></li></ol><p><strong>不妨对数组按照攻击降序，防御升序的方式排序</strong></p><p>然后遍历数组，不断更新最高防御值，统计弱角色的数量，</p><p>因为排序后，攻击必定前者大于后者，只需要比较防御即可</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfWeakCharacters</span><span class="params">(<span class="keyword">int</span>[][] properties)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(properties, (v1, v2) -&gt; v1[<span class="number">0</span>] != v2[<span class="number">0</span>] ? v2[<span class="number">0</span>] - v1[<span class="number">0</span>] : v1[<span class="number">1</span>] - v2[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> maxDefense = properties[<span class="number">0</span>][<span class="number">1</span>], ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; properties.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (properties[i][<span class="number">1</span>] &lt; maxDefense) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxDefense = Math.max(maxDefense, properties[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>访问完所有房间的第一天</title>
      <link href="/2022/01/24/%E8%AE%BF%E9%97%AE%E5%AE%8C%E6%89%80%E6%9C%89%E6%88%BF%E9%97%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
      <url>/2022/01/24/%E8%AE%BF%E9%97%AE%E5%AE%8C%E6%89%80%E6%9C%89%E6%88%BF%E9%97%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h3 id="访问完所有房间的第一天（动态规划）"><a href="#访问完所有房间的第一天（动态规划）" class="headerlink" title="访问完所有房间的第一天（动态规划）"></a>访问完所有房间的第一天（动态规划）</h3><span id="more"></span><blockquote><blockquote><p>题目详情参考：<a href="https://leetcode-cn.com/problems/first-day-where-you-have-been-in-all-the-rooms/">1997. 访问完所有房间的第一天 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote></blockquote><p><strong>在解题前，需要确定两个非常重要的信息条件：</strong></p><ol><li>第一个位置的元素必须是 <code>0</code></li><li>任意位置的元素不可以大于当前位置，即：<code>0 ≤ nextVisit[i] ≤ i</code></li></ol><p>那么可以从题意得到一个非常重要的信息：</p><p><strong>如果第一次到达位置 <code>x</code> ,那么在其之前的所有位置，访问次数必定是偶数</strong></p><p>成立的前提如下分析：</p><ol><li>因为第二个条件可以得出，不可能跳转位置，即必须累加</li><li>那么想要到达 <code>x</code>，必须从 <code>x-1</code> 位置前进一位到达</li><li>以此类推，前面的所有位置都必须为偶数</li></ol><p>那么由上述条件，又可以得知一个重要推论：</p><p><strong>从某一位置到达 <code>x</code> 所需要的天数，即为二者之差</strong></p><p>不妨设数组 <code>dp</code>，<code>dp[i]</code> 表示第一次到达当前位置所需的天数</p><p><strong>那么从 <code>y</code> 到 <code>x</code> 所需天数即为：<code>dp[x] - dp[y]</code></strong></p><p>进一步地，可以得到动态规划转移方程：<br>$$<br>\begin{align}<br>&amp;dp[i]=(dp[i-1] + 1) + (dp[i-1] - dp[nextVisit[i-1]] + 1) \\<br>&amp;dp[i]=2×dp[i-1]-dp[nextVisit[i-1]] + 2<br>\end{align}<br>$$<br>上述动态方程的证明如下：</p><ol><li>从 <code>i-1</code> 的位置到 <code>i</code> 需要加一天</li><li>但是第一次到达 <code>i-1</code> 的位置时，还会跳转到其所存储的位置</li><li>因此需要额外加上跳转位置重新到达 <code>i-1</code> 所需天数</li><li><strong>额外加上的天数，实际上就是从跳转位置到 <code>i-1</code> 的路径重走一遍</strong></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstDayBeenInAllRooms</span><span class="params">(<span class="keyword">int</span>[] nextVisit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">long</span>[] dp = <span class="keyword">new</span> <span class="keyword">long</span>[nextVisit.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nextVisit.length; i++) &#123;</span><br><span class="line">            dp[i] = (<span class="number">2</span> * dp[i - <span class="number">1</span>] - dp[nextVisit[i - <span class="number">1</span>]] + <span class="number">2</span>) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)((dp[dp.length - <span class="number">1</span>] + MOD) % MOD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>除此之外，需要注意：为什么最后需要 + MOD ？</strong></p><p>并不是仅仅因为溢出的问题，因为已经将数组声明为 <code>long</code>，</p><p>实际上是因为在减法过程中，由于不断地 mod 导致后面的值不一定大于前面的值，</p><p>造成会出现负数的情况，所以需要 + MOD 重新取余的额外步骤</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回文串</title>
      <link href="/2022/01/09/%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
      <url>/2022/01/09/%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="回文字符串"><a href="#回文字符串" class="headerlink" title="回文字符串"></a>回文字符串</h3><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格雷编码</title>
      <link href="/2022/01/08/%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81/"/>
      <url>/2022/01/08/%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h3 id="格雷编码（-数学-）"><a href="#格雷编码（-数学-）" class="headerlink" title="格雷编码（ 数学 ）"></a><strong>格雷编码（ 数学 ）</strong></h3><span id="more"></span><blockquote><blockquote><p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。</p><p>给定一个代表编码总位数的非负整数 <em>n</em>，打印其格雷编码序列。</p><p>即使有多个不同答案，你也只需要返回其中一种。</p><p>格雷编码序列必须以 0 开头。</p><p>题目详情参考：<a href="https://leetcode-cn.com/problems/gray-code/submissions/">89. 格雷编码 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote></blockquote><h3 id="解法一：对称生成"><a href="#解法一：对称生成" class="headerlink" title="解法一：对称生成"></a>解法一：对称生成</h3><p><em>题目解释：</em></p><p>给定编码总位数为 n 的格雷编码序列，其长度为 2<sup>n</sup>。当 n = 0 时，长度为 2<sup>0</sup> = 1。</p><p> 因此，当 n = 0 时，其格雷编码序列为 [0]。</p><p><em><strong>举例说明：</strong></em></p><p>n = 0 时，0</p><p>n = 1 时，0    1</p><p>n = 2 时，00    01    11    10</p><p>n = 3 时，000    001    011    010    110    111    101    100</p><p>与此同时，格雷编码对应的十进制数字为：</p><p>n = 0 时， 0</p><p>n = 1 时， 0    1</p><p>n = 2 时， 0    1    3    2</p><p>n = 3 时， 0    1    3    2    6    7    5    4</p><p><em><strong>那么我们可以看出格雷编码存在规律如下：</strong></em></p><p>不妨设在当前 n 值下，格雷编码为 <em>G(n)<em>，那么当 n - 1时，格雷编码为</em>G(n - 1)</em> ;</p><ul><li>在 <em>G(n-1)</em> 前每个元素加上 0 </li><li>镜像获得 <em>G<sup>‘</sup>(n-1)</em>，即将 <em>G(n-1)</em> 逆序存储，在 <em>G<sup>‘</sup>(n-1)</em> 前每个元素加上 1</li></ul><p>综上可得：<em>G(n) = 0+G(n-1) ∪ G<sup>‘</sup>(n-1)+1</em></p><p><em><strong>那么对应的十进制值不为 + 1，而应当是 + 2<sup> n-1</sup></strong></em></p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">grayCode</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ans.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> length = ans.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                ans.add(length + ans.get(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(2^n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p><p><strong>注意事项：</strong></p><p>如果将 <code>ArrayList</code> 改为 <code>LinkedList</code>，时间复杂度会提高很多，</p><p>因为需要遍历表得到对应下标的元素，相比于添加，遍历更费时；</p><hr><h3 id="解法二：二进制转格雷码"><a href="#解法二：二进制转格雷码" class="headerlink" title="解法二：二进制转格雷码"></a>解法二：二进制转格雷码</h3><p>如果有一个二进制数序列，也可以将它直接转换成格雷码序列。</p><p>假设 <code>n</code> 位二进制数为 <code>b</code>，对应的格雷码为 <code>g</code>，转换规则如下：<br>$$<br>\begin{align}<br>&amp;g(i) = b(i) \oplus b(i+1) \ \ 0≤i＜n<br>\end{align}<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">grayCode</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i++) &#123;</span><br><span class="line">            ans.add((i &gt;&gt; <span class="number">1</span>) ^ i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(2^n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串的加乘</title>
      <link href="/2022/01/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8A%A0%E4%B9%98/"/>
      <url>/2022/01/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8A%A0%E4%B9%98/</url>
      
        <content type="html"><![CDATA[<h3 id="字符串的加乘"><a href="#字符串的加乘" class="headerlink" title="字符串的加乘"></a>字符串的加乘</h3><span id="more"></span><h3 id="加一"><a href="#加一" class="headerlink" title="加一"></a>加一</h3><blockquote><p>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：digits = [4,3,2,1]</span><br><span class="line">&gt;输出：[4,3,2,2]</span><br></pre></td></tr></table></figure><p>题目详情参考：<a href="https://leetcode-cn.com/problems/plus-one/">66. 加一 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><ol><li>从末尾开始加一即可，如果不产生进位，返回结果，否则向前加一；</li><li>如果直到最高位仍未结束，那么说明该数为 <code>9...9</code> ，所以单独处理。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = digits.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            digits[i]++;</span><br><span class="line">            <span class="keyword">if</span> (digits[i] == <span class="number">10</span>) &#123;</span><br><span class="line">                digits[i] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[digits.length + <span class="number">1</span>];</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p><hr><h3 id="字符串的相加"><a href="#字符串的相加" class="headerlink" title="字符串的相加"></a>字符串的相加</h3><blockquote><blockquote><p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。</p><p>你不能使用任何內建的用于处理大整数的库（比如 BigInteger），</p><p>也不能直接将输入的字符串转换为整数形式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：num1 = &quot;456&quot;, num2 = &quot;77&quot;</span><br><span class="line">&gt;输出：&quot;533&quot;</span><br></pre></td></tr></table></figure><p>题目详情参考：<a href="https://leetcode-cn.com/problems/add-strings/">415. 字符串相加 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote></blockquote><ol><li>模拟<strong>竖式相加</strong>的过程即可，需要注意位数不同和进位的情况；</li><li>等价于<strong>对位数较短的数字进行了补零操作</strong>。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>, add = <span class="number">0</span>;</span><br><span class="line">        StringBuffer ans = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i &gt;= <span class="number">0</span> ? num1.charAt(i) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y = j &gt;= <span class="number">0</span> ? num2.charAt(j) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> result = x + y + add;</span><br><span class="line">            ans.append(result % <span class="number">10</span>);</span><br><span class="line">            add = result / <span class="number">10</span>;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算完以后的答案需要翻转过来</span></span><br><span class="line">        ans.reverse();</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p><hr><h3 id="字符串的相乘"><a href="#字符串的相乘" class="headerlink" title="字符串的相乘"></a>字符串的相乘</h3><blockquote><blockquote><p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，</p><p>返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;</span><br><span class="line">输出: &quot;56088&quot;</span><br></pre></td></tr></table></figure><p>题目详情参考：<a href="https://leetcode-cn.com/problems/multiply-strings/">43. 字符串相乘 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote></blockquote><h4 id="解法一：做加法"><a href="#解法一：做加法" class="headerlink" title="解法一：做加法"></a>解法一：做加法</h4><ol><li><code>num2</code> 从最低位依次去相乘 <code>num1</code> ，而后将每次的结果累加；</li><li><strong>用位相乘时，需要注意补 0</strong>，可以参考日常的乘法竖式计算；</li><li>结果的累加，参考<strong>字符串的相加</strong>。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num1.equals(<span class="string">&quot;0&quot;</span>) || num2.equals(<span class="string">&quot;0&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String ans = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> m = num1.length(), n = num2.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// num2某一位与num1相乘</span></span><br><span class="line">            StringBuffer curr = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="keyword">int</span> add = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 列式乘法时 末尾补0</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">                curr.append(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟乘法过程</span></span><br><span class="line">            <span class="keyword">int</span> y = num2.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = num1.charAt(j) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">int</span> product = x * y + add;</span><br><span class="line">                curr.append(product % <span class="number">10</span>);</span><br><span class="line">                add = product / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (add != <span class="number">0</span>) &#123;</span><br><span class="line">                curr.append(add % <span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 累加</span></span><br><span class="line">            ans = addStrings(ans, curr.reverse().toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>, add = <span class="number">0</span>;</span><br><span class="line">        StringBuffer ans = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i &gt;= <span class="number">0</span> ? num1.charAt(i) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y = j &gt;= <span class="number">0</span> ? num2.charAt(j) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> result = x + y + add;</span><br><span class="line">            ans.append(result % <span class="number">10</span>);</span><br><span class="line">            add = result / <span class="number">10</span>;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.reverse();</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O((m + n)×n)<br>&amp;空间复杂度:O(m + n)<br>\end{align}<br>$$</p><hr><h4 id="解法二：做乘法"><a href="#解法二：做乘法" class="headerlink" title="解法二：做乘法"></a>解法二：做乘法</h4><ol><li>方法一的做法是从右往左遍历乘数，将乘数的每一位与被乘数相乘得到对应的结果，</li><li>再将每次得到的结果累加，整个过程中涉及到较多字符串相加的操作。</li><li>如果使用数组代替字符串存储结果，则可以减少对字符串的操作。</li><li><code>num1</code> 和 <code>num2</code> 的乘积的最大长度为 <code>m+n</code>，故创建长度为 <code>m+n</code> 的数组 <code>ansArr</code> 用于存储乘积；</li><li>具体计算过程中，先算每一位的累计值，最后在数组上进行进位化简操作。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num1.equals(<span class="string">&quot;0&quot;</span>) || num2.equals(<span class="string">&quot;0&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = num1.length(), n = num2.length();</span><br><span class="line">        <span class="keyword">int</span>[] ansArr = <span class="keyword">new</span> <span class="keyword">int</span>[m + n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = num1.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> y = num2.charAt(j) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                ansArr[i + j + <span class="number">1</span>] += x * y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m + n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            ansArr[i - <span class="number">1</span>] += ansArr[i] / <span class="number">10</span>;</span><br><span class="line">            ansArr[i] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = ansArr[<span class="number">0</span>] == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        StringBuffer ans = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> (index &lt; m + n) &#123;</span><br><span class="line">            ans.append(ansArr[index]);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(mn)<br>&amp;空间复杂度:O(m + n)<br>\end{align}<br>$$</p><hr><h3 id="一个区间内所有数乘积的缩写"><a href="#一个区间内所有数乘积的缩写" class="headerlink" title="一个区间内所有数乘积的缩写"></a>一个区间内所有数乘积的缩写</h3><blockquote><p>题目详情参考：<a href="https://leetcode-cn.com/problems/abbreviating-the-product-of-a-range/">2117. 一个区间内所有数乘积的缩写 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><p><strong>说明：题目在最开始周赛测试时存在标程问题，但是后来官方降低了数的长度。</strong></p><ol><li>不能使用字符串相乘的方法去处理，会超出时间复杂度；</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 代码来自68场双周赛第一名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">abbreviateProduct</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> two = <span class="number">0</span>, five = <span class="number">0</span>, min = <span class="number">0</span>, flag = <span class="number">0</span>, last = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = left, j; (j = i) &lt;= right; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (; j % <span class="number">2</span> == <span class="number">0</span>; j /= <span class="number">2</span>, two++) &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (; j % <span class="number">5</span> == <span class="number">0</span>; j /= <span class="number">5</span>, five++) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">two = five = min = Math.min(two, five);</span><br><span class="line"><span class="keyword">double</span> first = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (last *= i; last % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; two-- &gt; <span class="number">0</span>; last /= <span class="number">2</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (; last % <span class="number">5</span> == <span class="number">0</span> &amp;&amp; five-- &gt; <span class="number">0</span>; last /= <span class="number">5</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> (last &gt; <span class="number">10000000000L</span>) &#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">last %= <span class="number">10000000000L</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (first *= i; first &gt; <span class="number">100000</span>; first /= <span class="number">10</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (flag == <span class="number">0</span> ? last : (<span class="keyword">int</span>) first + <span class="string">&quot;...&quot;</span> + String.format(<span class="string">&quot;%05d&quot;</span>, last % <span class="number">100000</span>)) + <span class="string">&quot;e&quot;</span> + min;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>约瑟夫环</title>
      <link href="/2022/01/02/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"/>
      <url>/2022/01/02/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h3><span id="more"></span><h2 id="约瑟夫环的基础问题："><a href="#约瑟夫环的基础问题：" class="headerlink" title="约瑟夫环的基础问题："></a>约瑟夫环的基础问题：</h2><blockquote><p><a href="https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/">1823. 找出游戏的获胜者 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><h3 id="解法一：状态模拟"><a href="#解法一：状态模拟" class="headerlink" title="解法一：状态模拟"></a>解法一：状态模拟</h3><p>思路：开辟一个数组，表示当前人的状态，而后循环模拟退圈过程。</p><h4 id="第一种状态模拟："><a href="#第一种状态模拟：" class="headerlink" title="第一种状态模拟："></a>第一种状态模拟：</h4><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTheWinner</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[] arr = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">int</span> count = k;</span><br><span class="line">        <span class="keyword">while</span> (!isOne(arr)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">0</span> &amp;&amp; !arr[i]) &#123;</span><br><span class="line">                    arr[i] = <span class="keyword">true</span>;</span><br><span class="line">                    count = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!arr[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 额外开辟了一个循环 但是便于理解</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOne</span><span class="params">(<span class="keyword">boolean</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!arr[i]) &#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第二种状态模拟："><a href="#第二种状态模拟：" class="headerlink" title="第二种状态模拟："></a>第二种状态模拟：</h4><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTheWinner</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] arr = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, num = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (count != n - <span class="number">1</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span> (index &gt; n) &#123;</span><br><span class="line">                index = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!arr[index]) &#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num == k) &#123;</span><br><span class="line">                arr[index] = <span class="keyword">true</span>;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!arr[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n^2)<br>&amp;空间复杂度:O(n)<br>\end{align}<br>$$</p><hr><h3 id="解法二：迭代递推"><a href="#解法二：迭代递推" class="headerlink" title="解法二：迭代递推"></a>解法二：迭代递推</h3><ol><li><p>为了方便处理，人数从 <code>0</code> 开始至 <code>n - 1</code>，并且从 <code>0</code> 开始报数至 <code>k - 1</code> ;</p></li><li><p>第一次淘汰的人编号为 <code>(m - 1) mod n</code> ；</p></li><li><p>那么剩下的 <code>n - 2</code> 人从 <code>m mod n</code> 开始报数，组成一个新的约瑟夫环：</p><p>k、k + 1、… 、k - 2 对应为 0、1、… 、n - 2；</p></li><li><p>若这个新问题的解为 <code>x</code> ，那么原问题的解也为此，但是需要将编号映射为原位置：</p><p>x<sup>‘</sup> = (x + k) mod n</p></li><li><p>因此得到递归关系如下，其中 <code>f[i]</code> 表示人数为 <code>i</code> 时的解：<br>$$<br>f[i]=(f[i - 1] + m) mod (i - 1)<br>$$</p></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTheWinner</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            f = (f + k) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ++f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p><hr><h2 id="约瑟夫环的进阶问题："><a href="#约瑟夫环的进阶问题：" class="headerlink" title="约瑟夫环的进阶问题："></a>约瑟夫环的进阶问题：</h2><p>其实有很多改编的题目，比如调整数据规模，O（n）降为 O（logn）；</p><p>下面一题，尽管并不应用约瑟夫环的解法，但仍为一种递归求解数学问题。</p><blockquote><p><a href="https://leetcode-cn.com/problems/elimination-game/">390. 消除游戏 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><h3 id="解法一：等差数列模拟"><a href="#解法一：等差数列模拟" class="headerlink" title="解法一：等差数列模拟"></a>解法一：等差数列模拟</h3><ol><li>每次都将整数列表进行间隔删除，因此每次删除后剩余的整数列表都是等差数列；</li><li>首先创建变量 <code>numOfCircles</code> ，用来确定正向或者反向遍历；</li><li>当正向遍历的时候，需要确定当前整数列表的长度，因为奇偶不一致，处理也不一样；</li><li>反向遍历亦然如此，即分类讨论；</li><li>每次循环结束时，需要将等差 <code>d</code> 扩大一倍，数列长度 <code>n</code> 缩小一倍；</li><li>退出循环的条件为：数列长度为 <code>1</code> 。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a1 = <span class="number">1</span>, an = n, d = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> numOfCircles = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numOfCircles % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                a1 = a1 + d;</span><br><span class="line">                an = (n % <span class="number">2</span> == <span class="number">0</span>) ? an : an - d;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                an = an - d;</span><br><span class="line">                a1 = (n % <span class="number">2</span> == <span class="number">0</span>) ? a1 : a1 + d;</span><br><span class="line">            &#125;</span><br><span class="line">            d = d &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            numOfCircles++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(logn)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p><hr><h3 id="解法二：递归模拟"><a href="#解法二：递归模拟" class="headerlink" title="解法二：递归模拟"></a>解法二：递归模拟</h3><blockquote><p>参见题解：<a href="https://leetcode-cn.com/problems/elimination-game/solution/gong-shui-san-xie-yue-se-fu-huan-yun-yon-x60m/">【宫水三叶】约瑟夫环运用题 - 消除游戏 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><h4 id="尾递归的概念："><a href="#尾递归的概念：" class="headerlink" title="尾递归的概念："></a>尾递归的概念：</h4><p>参考链接：</p><ol><li><a href="https://baike.baidu.com/item/%E5%B0%BE%E9%80%92%E5%BD%92/554682">尾递归_百度百科 (baidu.com)</a></li><li><a href="https://blog.csdn.net/Vermont_/article/details/84557065">(20条消息) 详解什么是尾递归（通俗易懂，示例讲解）_Vermont_的博客-CSDN博客_尾递归</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吃苹果的最大数目</title>
      <link href="/2021/12/24/%E5%90%83%E8%8B%B9%E6%9E%9C%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/"/>
      <url>/2021/12/24/%E5%90%83%E8%8B%B9%E6%9E%9C%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="吃苹果的最大数目（-贪心-优先队列-）"><a href="#吃苹果的最大数目（-贪心-优先队列-）" class="headerlink" title="吃苹果的最大数目（ 贪心 | 优先队列 ）"></a>吃苹果的最大数目（ 贪心 | 优先队列 ）</h3><span id="more"></span><blockquote><p>题目详情参考：<a href="https://leetcode-cn.com/problems/maximum-number-of-eaten-apples/">1705. 吃苹果的最大数目 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><p>思路：每天只能吃一个苹果，最大数量一定是每次吃最先腐烂的，因此贪心算法，</p><p>除此之外，如何保证苹果顺序，采用优先队列结构，解决问题。</p><ol><li><p><strong>使用贪心策略，在尚未腐烂的苹果中优先选择腐烂日期最早的苹果；</strong></p></li><li><p>计算吃苹果的最大数目分成两个阶段：</p><p>第一阶段是第 0 天到第 n−1 天，即天数在数组下标范围内，</p><p>第二阶段是第 n 天及以后，即天数在数组下标范围外；</p></li><li><p>每天取出一个，直到数目为 0 或者已经腐烂；</p></li></ol><p><strong>需要注意的地方：</strong></p><ol><li><p><strong>特殊的例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：apples = [1,0,0,0,0], days = [0,0,0,0,0]</span><br><span class="line">输入：apples = [1,0,0,0,0], days = [1,0,0,0,0]</span><br><span class="line">输出：apples = [2,0,0,0,0], days = [1,0,0,0,0]</span><br></pre></td></tr></table></figure><p>即当天如果有苹果，但是当天就会腐烂，那么会优先吃掉。</p></li><li><p><strong>两个阶段既可以分开考虑，也可以合并考虑：</strong></p><p>分开考虑：第二阶段不需要累加，而是叠加，降低时间复杂度；</p><p>合并考虑：第二阶段思路不变，但是会增加时间复杂度；</p></li><li><p><strong>优先队列添加和取元素操作的时间复杂度是O( logn )；</strong></p></li><li><p><strong>在处理队首元素时，由于数组是引用型，所以原地修改 peek 元素即可；</strong></p></li></ol><h3 id="分阶段考虑："><a href="#分阶段考虑：" class="headerlink" title="分阶段考虑："></a>分阶段考虑：</h3><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eatenApples</span><span class="params">(<span class="keyword">int</span>[] apples, <span class="keyword">int</span>[] days)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> currDay = <span class="number">0</span>;</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o1[<span class="number">1</span>] - o2[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">while</span> (currDay &lt; days.length) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!pq.isEmpty() &amp;&amp; pq.peek()[<span class="number">1</span>] &lt;= currDay) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> count = apples[currDay];</span><br><span class="line">            <span class="keyword">int</span> rottenDay = days[currDay] + currDay;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;count, rottenDay&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!pq.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] arr = pq.peek();</span><br><span class="line">                arr[<span class="number">0</span>]--;</span><br><span class="line">                <span class="keyword">if</span> (arr[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                    pq.poll();</span><br><span class="line">                &#125;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            currDay++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!pq.isEmpty() &amp;&amp; pq.peek()[<span class="number">1</span>] &lt;= currDay) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pq.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span>[] arr = pq.poll();</span><br><span class="line">            <span class="keyword">int</span> curr = Math.min(arr[<span class="number">1</span>] - currDay, arr[<span class="number">0</span>]);</span><br><span class="line">            ans += curr;</span><br><span class="line">            currDay += curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并处理"><a href="#合并处理" class="headerlink" title="合并处理"></a>合并处理</h3><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eatenApples</span><span class="params">(<span class="keyword">int</span>[] apples, <span class="keyword">int</span>[] days)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> currDay = <span class="number">0</span>;</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o1[<span class="number">1</span>] - o2[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">while</span> (currDay &lt; days.length || !pq.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!pq.isEmpty() &amp;&amp; pq.peek()[<span class="number">1</span>] &lt;= currDay) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(currDay &lt; days.length) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = apples[currDay];</span><br><span class="line">                <span class="keyword">int</span> rottenDay = days[currDay] + currDay;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;count, rottenDay&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!pq.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] arr = pq.peek();</span><br><span class="line">                arr[<span class="number">0</span>]--;</span><br><span class="line">                <span class="keyword">if</span> (arr[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                    pq.poll();</span><br><span class="line">                &#125;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            currDay++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(nlogn)<br>&amp;空间复杂度:O(n)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 贪心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>供暖器</title>
      <link href="/2021/12/20/%E4%BE%9B%E6%9A%96%E5%99%A8/"/>
      <url>/2021/12/20/%E4%BE%9B%E6%9A%96%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="供暖器（-贪心-双指针-）"><a href="#供暖器（-贪心-双指针-）" class="headerlink" title="供暖器（ 贪心 | 双指针 ）"></a>供暖器（ 贪心 | 双指针 ）</h3><span id="more"></span><blockquote><p>冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。</p><p>在加热器的加热半径范围内的每个房屋都可以获得供暖。</p><p>现在，给出位于一条水平线上的房屋 houses 和供暖器 heaters 的位置，</p><p>请你找出并返回可以覆盖所有房屋的最小加热半径。</p><p>说明：所有供暖器都遵循你的半径标准，加热的半径也一样。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: houses = [1,2,3], heaters = [2]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p>题目详情参考：<a href="https://leetcode-cn.com/problems/heaters/">475. 供暖器 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><h3 id="解法一：贪心-二分搜索"><a href="#解法一：贪心-二分搜索" class="headerlink" title="解法一：贪心 +二分搜索"></a>解法一：贪心 +二分搜索</h3><p>思路：考虑房屋和供暖器，那么<strong>一定是房屋距离最近的供暖器，使得当前半径最小，</strong></p><p>因此，遍历所有的房屋，得到其所有距离的最大值，即为覆盖所有房屋的最小加热半径。</p><ol><li>首先对 <code>heaters</code> 数组排序，便于二分搜索；</li><li><strong>二分搜索过程中，如果未搜索到，需要对左右比较，得到最小距离；</strong></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRadius</span><span class="params">(<span class="keyword">int</span>[] houses, <span class="keyword">int</span>[] heaters)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(heaters);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; houses.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = binarySearch(heaters, houses[i]);</span><br><span class="line">            <span class="keyword">int</span> dis = Math.abs(houses[i] - index);</span><br><span class="line">            System.out.println(dis);</span><br><span class="line">            ans = Math.max(ans, dis);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[mid];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[--left];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target - nums[left - <span class="number">1</span>] &gt; nums[left] - target) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[left - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(nlogn)<br>&amp;空间复杂度:O(logn)\\<br>&amp;空间复杂度主要取决于排序算法<br>\end{align}<br>$$</p><hr><h3 id="解法二：贪心-双指针"><a href="#解法二：贪心-双指针" class="headerlink" title="解法二：贪心 + 双指针"></a>解法二：贪心 + 双指针</h3><p>思路：基于解法一，同时对 <code>houses</code> 数组排序，那么可以简化搜索过程。</p><ol><li><p>对于 <code>houses[i]</code> ，从左到右遍历 <code>heaters</code> ，用变量 <code>j</code> 记录位置；</p></li><li><p>如果当前房屋和当前加热器的距离大于下一个加热器的距离，那么 <code>j++</code>;</p></li><li><p>否则的话，说明当前距离就是最小距离，同时更新结果；</p></li><li><p><strong>在查找下一个房屋时，不需要从 <code>j=0</code> 开始，因为两个数组都已排序，</strong></p><p><strong>不可能存在已经遍历的加热器比当前 <code>j</code> 位置的更近；</strong></p></li><li><p>因此从当前 <code>j</code> 的值开始继续遍历，重复上述过程即可。</p></li></ol><p><strong>注意：双指针遍历两个数组的时间复杂度是 O(m + n)！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRadius</span><span class="params">(<span class="keyword">int</span>[] houses, <span class="keyword">int</span>[] heaters)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(houses);</span><br><span class="line">        Arrays.sort(heaters);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; houses.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> currDis = Math.abs(heaters[j] - houses[i]);</span><br><span class="line">            <span class="keyword">while</span> (j &lt; heaters.length - <span class="number">1</span> &amp;&amp; </span><br><span class="line">                   currDis &gt;= Math.abs(heaters[j + <span class="number">1</span>] - houses[i])) &#123;</span><br><span class="line">                currDis = Math.abs(heaters[++j] - houses[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, currDis);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(mlogm + nlogn)<br>&amp;空间复杂度:O(logm +logn)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 贪心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分搜索</title>
      <link href="/2021/12/20/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"/>
      <url>/2021/12/20/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="二分搜索（-双指针-）"><a href="#二分搜索（-双指针-）" class="headerlink" title="二分搜索（ 双指针 ）"></a>二分搜索（ 双指针 ）</h3><span id="more"></span><blockquote><blockquote><p>总结一下二分搜索的特性，处理问题时总遇到怎么确定 left 或者 right 的情况；</p><p>因此总结一下基本的用法，方便以后使用。</p></blockquote></blockquote><h3 id="第一种判定方式：left-≤-right"><a href="#第一种判定方式：left-≤-right" class="headerlink" title="第一种判定方式：left ≤ right"></a>第一种判定方式：<code>left ≤ right</code></h3><p>如果有的题目需要得到不存在时，应在数组中的位置：</p><ol><li><strong>如果以 <code>left</code> 为基准，那么最终 <code>left</code> 指向的位置在 <code>target</code> 右边；</strong></li><li>如果以 <code>right</code> 为基准，那么最终 <code>right</code> 指向的位置在 <code>target</code> 左边；</li><li>以第一种情况为例：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果仅用来搜索是否存在</span></span><br><span class="line">        <span class="comment">// return -1;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断位置</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[--left];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断左右那个值得差更小</span></span><br><span class="line">        <span class="keyword">if</span> (target - nums[left - <span class="number">1</span>] &lt; nums[left] - target) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[left - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二种判定方式：left-lt-right"><a href="#第二种判定方式：left-lt-right" class="headerlink" title="第二种判定方式：left &lt; right"></a>第二种判定方式：<code>left &lt; right</code></h3><p>在得到 <code>mid</code> 时，常用得方法有两种：</p><ol><li><code>mid = (right - left) / 2 + left</code> ，避免溢出；</li><li><strong><code>mid = (right + left) &gt;&gt; 1</code> 运算更快，推荐；</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] != target) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(logn)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长递增子序列</title>
      <link href="/2021/12/19/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/2021/12/19/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="最长递增子序列（-动态规划-贪心-）"><a href="#最长递增子序列（-动态规划-贪心-）" class="headerlink" title="最长递增子序列（ 动态规划 | 贪心 ）"></a>最长递增子序列（ 动态规划 | 贪心 ）</h3><span id="more"></span><blockquote><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。</p><p>例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>题目详情参考：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><h3 id="解法一：动态规划"><a href="#解法一：动态规划" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h3><p>思路：找到最优子结构和动态转移方程。</p><ol><li><p>不妨设数组 <code>dp</code> ，其中 <code>dp[i]</code> 表示以 <code>i</code> 结尾时，当前的最长严格递增子序列，</p><p><strong>注意：一定包含 <code>nums[i]</code> ;</strong></p></li><li><p>因此对于 <code>dp[i]</code> ，可得动态转移方程：</p></li></ol><p>$$<br>dp[i] = max \lbrace dp[j] \rbrace, \ 0≤j&lt;i \ 并且\  nums[j] &lt; nums[i]<br>$$</p><ol start="3"><li><strong>最终答案即为：max{ dp[ i ] }，0 ≤ i &lt; nums.length - 1；</strong></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[j] + <span class="number">1</span>, dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(dp[i], ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n^2)<br>&amp;空间复杂度:O(n)<br>\end{align}<br>$$</p><hr><h3 id="解法二：贪心-二分搜索"><a href="#解法二：贪心-二分搜索" class="headerlink" title="解法二：贪心 + 二分搜索"></a>解法二：贪心 + 二分搜索</h3><p>思路：<strong>如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，</strong></p><p>​           <strong>因此我们希望每次在上升子序列最后加上的那个数尽可能的小。</strong></p><ol><li><p>基于上面的贪心思路，不妨维护一个数组 <code>incresingSeque[i]</code> ，</p><p>表示长度为 <code>i</code> 的最长上升子序列的末尾元素的最小值；</p></li><li><p>并且声明一个变量 <code>currLen</code> 记录当前最长上升子序列的长度；</p></li><li><p>可以证明数组 <code>incresingSeque</code> 是一个单调递增的数组：</p><p>不妨设 <code>incresingSeque[i]</code> &lt; <code>incresingSeque[j]</code> &amp;&amp; <code>i</code> &gt; <code>j</code>，</p><p>那么在数组末尾删除 <code>i - j</code> 个元素，</p><p>那么就找到了一个长度为 <code>j</code> 的最长上升子序列，且末尾元素比 <code>d[j]</code> 小，矛盾，证明完毕；</p></li><li><p>遍历数组，更新 <code>incresingSeque[i]</code> 的值以及 <code>currLen</code>：</p><ol><li>当遇到值大于目前末尾时，将其添加至末尾，并且 <code>currLen++</code> ;</li><li>当遇到值不大于时，在数组<strong>通过二分搜索找到合适位置</strong>，更新数组；</li></ol></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> currLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] incresingSeque = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        incresingSeque[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (incresingSeque[currLen] &lt; nums[i]) &#123;</span><br><span class="line">                incresingSeque[++currLen] = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> left = <span class="number">1</span>, right = currLen, pos = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">                    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (incresingSeque[mid] &lt; nums[i]) &#123;</span><br><span class="line">                        pos = mid;</span><br><span class="line">                        left = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        right = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                incresingSeque[pos + <span class="number">1</span>] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(nlogn)<br>&amp;空间复杂度:O(n)<br>\end{align}<br>$$</p><hr><h3 id="变式：使数组-K-递增的最少操作次数"><a href="#变式：使数组-K-递增的最少操作次数" class="headerlink" title="变式：使数组 K 递增的最少操作次数"></a>变式：<a href="https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-k-increasing/">使数组 K 递增的最少操作次数</a></h3><p>说明：LeetCode 272周赛最后一题，当时没有采用时间复杂度 nlogn 的算法，导致超时。</p><p>思路：该题目仔细思考就能看出来 LIS 的变式，相当于 <code>K</code> 个数组的最长子序列，然后变化即可；</p><p>细节：该题目为非严格递增，因此判断条件改为 <code>≤</code> 即可；</p><p><strong>重点：时空复杂度需要认真思考！</strong></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kIncreasing</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; arr.length) &#123;</span><br><span class="line">                list.add(arr[j]);</span><br><span class="line">                j += k;</span><br><span class="line">            &#125;</span><br><span class="line">            Integer[] nums = list.toArray(<span class="keyword">new</span> Integer[list.size()]);</span><br><span class="line">            <span class="keyword">int</span> temp = lengthOfLIS(nums);</span><br><span class="line">            ans += nums.length - temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(Integer[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>, n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] d = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        d[len] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt;= d[len]) &#123;</span><br><span class="line">                d[++len] = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> l = <span class="number">1</span>, r = len, pos = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (d[mid] &lt;= nums[i]) &#123;</span><br><span class="line">                        pos = mid;</span><br><span class="line">                        l = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        r = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                d[pos + <span class="number">1</span>] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(nlog\frac nk) \\<br>&amp;空间复杂度:O(\frac nk)<br>\\&amp;每个序列的长度为\ (\frac nk),LIS的时间复杂度\ O(\frac nklog\frac nk),\\&amp;一共有k个序列，因此总时间复杂度为\ O(nlog\frac nk).<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用最小花费爬楼梯</title>
      <link href="/2021/12/17/%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
      <url>/2021/12/17/%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="使用最小花费爬楼梯（-动态规划-）"><a href="#使用最小花费爬楼梯（-动态规划-）" class="headerlink" title="使用最小花费爬楼梯（ 动态规划 ）"></a>使用最小花费爬楼梯（ 动态规划 ）</h3><span id="more"></span><blockquote><p>数组的每个下标作为一个阶梯，</p><p>第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。</p><p>每当你爬上一个阶梯你都要花费对应的体力值，</p><p>一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p><p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [10, 15, 20]</span><br><span class="line">输出：15</span><br><span class="line">解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。</span><br></pre></td></tr></table></figure><p>题目详情参考：<a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><p><strong>补充说明：达到楼顶意味着超出数组，即最后一个阶梯是倒数第一个或者倒数第二个。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">体力值  10  15  20    </span><br><span class="line">水平线   0   1   2  楼层顶部</span><br></pre></td></tr></table></figure><p>思路：入门的动态规划，先找出转移方程，在求解。</p><ol><li>不妨设数组 <code>dp</code> ，<code>dp[i]</code> 表示当前阶梯的最小体力花费；</li><li>显而易见，想要达到 <code>i</code> 层阶梯，只能通过 <code>i-1</code> ，或者 <code>i-2</code> 阶梯到达；</li><li>可得如下动态转移方程：</li></ol><p>$$<br>dp[i] = max\lbrace dp[i-1],dp[i-2] \rbrace + cost[i]<br>$$</p><ol start="4"><li>最后结果即为倒数第二层或者倒数第一层的最小值。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[cost.length];</span><br><span class="line">        dp[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; cost.length; i++) &#123;</span><br><span class="line">            dp[i] = Math.min(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>]) + cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(dp[cost.length - <span class="number">1</span>], dp[cost.length - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(n)<br>\end{align}<br>$$</p><p><strong>实际上每次更新两个值，因此可以使用滚动数组减少数组的空间开销：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> first = cost[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> second = cost[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; cost.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = second;</span><br><span class="line">            second = Math.min(second, first) + cost[i];</span><br><span class="line">            first = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(first, second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>换酒问题</title>
      <link href="/2021/12/17/%E6%8D%A2%E9%85%92%E9%97%AE%E9%A2%98/"/>
      <url>/2021/12/17/%E6%8D%A2%E9%85%92%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="换酒问题（-数学-）"><a href="#换酒问题（-数学-）" class="headerlink" title="换酒问题（ 数学 ）"></a>换酒问题（ 数学 ）</h3><span id="more"></span><blockquote><p>小区便利店正在促销，用 numExchange 个空酒瓶可以兑换一瓶新酒。</p><p>你购入了 numBottles 瓶酒，如果喝掉了酒瓶中的酒，那么酒瓶就会变成空的。</p><p>请你计算 最多 能喝到多少瓶酒。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：numBottles = 9, numExchange = 3</span><br><span class="line">输出：13</span><br></pre></td></tr></table></figure><p>题目详情参考：<a href="https://leetcode-cn.com/problems/water-bottles/">1518. 换酒问题 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><p>思路：经典的数学问题，用迭代解决。</p><ol><li>额外定义变量 <code>emptyBottles</code> ，表示在喝完一次后，所剩的空酒瓶数量；</li><li>判断结束的条件是：手中的空酒瓶和酒瓶的总数量不小于 <code>numExchange</code> ；</li><li>因为最开始手中有酒，所以采用 <code>do&#123;&#125; while()</code> 结构。</li></ol><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWaterBottles</span><span class="params">(<span class="keyword">int</span> numBottles, <span class="keyword">int</span> numExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> emptyBottles = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ans += numBottles;</span><br><span class="line">            emptyBottles += numBottles;</span><br><span class="line">            numBottles = emptyBottles / numExchange;</span><br><span class="line">            emptyBottles -= numBottles * numExchange;</span><br><span class="line">        &#125; <span class="keyword">while</span>(emptyBottles + numBottles &gt;= numExchange);</span><br><span class="line">        <span class="keyword">return</span> ans + numBottles;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可见点的最大数目</title>
      <link href="/2021/12/16/%E5%8F%AF%E8%A7%81%E7%82%B9%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/"/>
      <url>/2021/12/16/%E5%8F%AF%E8%A7%81%E7%82%B9%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="可见点的最大数目（-图-数学）"><a href="#可见点的最大数目（-图-数学）" class="headerlink" title="可见点的最大数目（ 图 | 数学）"></a>可见点的最大数目（ 图 | 数学）</h3><span id="more"></span><blockquote><p>题目详情参考：<a href="https://leetcode-cn.com/problems/maximum-number-of-visible-points/">1610. 可见点的最大数目 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><p>该题目建立在数学基础上，需要对每一步都了解，层层递进。</p><h3 id="解法一：二分搜索"><a href="#解法一：二分搜索" class="headerlink" title="解法一：二分搜索"></a>解法一：二分搜索</h3> <img src="/2021/12/16/%E5%8F%AF%E8%A7%81%E7%82%B9%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/整体思路.png" alt="整体思路" style="zoom:33%;"><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[2,1],[2,2],[3,3]], angle = 90, location = [1,1]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p>不妨以这个示例，另外额外在图中添加一个样例点，说明一下整体思路：</p><ol><li>在本题中视角可转换为相对于 <code>location</code> 的<a href="[极角_百度百科 (baidu.com)](https://baike.baidu.com/item/极角/12726003?fr=aladdin)">极角</a>；</li><li>将所有点 <code>point</code> 的坐标转化为相对于 <code>location</code> 的极角；</li><li>如何通过数学计算得到极角：</li></ol> <img src="/2021/12/16/%E5%8F%AF%E8%A7%81%E7%82%B9%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/极角计算.png" alt="极角计算" style="zoom:33%;"><p>​        在程序中，<strong>采用 <a href="[Math (Java SE 9 & JDK 9 ) (oracle.com)](https://docs.oracle.com/javase/9/docs/api/java/lang/Math.html#atan2-double-double-)"><code>atan2</code></a> 方法来计算，因为其值域为 [ -Π，Π ]；</strong></p><ol start="4"><li><p>不妨设当前 <code>point</code> 的极角为 <code>polarDegree</code> ，(如下简称为  d<sub>p</sub> )</p><p> <strong>那么找到坐标的极角处于区间 [d<sub>p</sub>, d<sub>p</sub> + angle]的最大数量即可</strong>;</p></li></ol> <img src="/2021/12/16/%E5%8F%AF%E8%A7%81%E7%82%B9%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/视角内数量.png" style="zoom:33%;"><ol start="5"><li><p>第三步的处理很妙，即如何确定视角范围内的数量，通过极角的大小关系即可；</p></li><li><p>在具体计算中，<strong>需要特殊处理和 <code>location</code> 相同的点，</strong></p><p>因为 <code>atan2</code> 的两个参数不能同时为 0；</p></li><li><p><strong>对所有点的极角排序，然后在范围内二分搜索得到数量值</strong>，但是可能会出现下面情况：</p><p>d<sub>p</sub> + angle &gt; 180°，导致范围内无解，这是因为 <code>atan2</code> 所得的范围是 [-180°，180°]；</p><p>因此将所有的极角加上 360° 再添加到原序列后面，不会影响大小排序，可以避免上述情况；</p></li><li><p><strong>注意程序中的数据是采用弧度制计算的。</strong></p></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">visiblePoints</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; points, <span class="keyword">int</span> angle, List&lt;Integer&gt; location)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sameCnt = <span class="number">0</span>;</span><br><span class="line">        List&lt;Double&gt; polarDegrees = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> locationX = location.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> locationY = location.get(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = points.get(i).get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> y = points.get(i).get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (x == locationX &amp;&amp; y == locationY) &#123;</span><br><span class="line">                sameCnt++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Double degree = Math.atan2(y - locationY, x - locationX);</span><br><span class="line">            polarDegrees.add(degree);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(polarDegrees);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = polarDegrees.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            polarDegrees.add(polarDegrees.get(i) + <span class="number">2</span> * Math.PI);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxCnt = <span class="number">0</span>;</span><br><span class="line">        Double toDegree = angle * Math.PI / <span class="number">180</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> iteration = binarySearch(polarDegrees, polarDegrees.get(i) + toDegree);</span><br><span class="line">            maxCnt = Math.max(maxCnt, iteration - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxCnt + sameCnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;Double&gt; nums, Double target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = nums.size();</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums.get(mid) &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n×logn)<br>&amp;空间复杂度:O(n)<br>\end{align}<br>$$</p><hr><h3 id="解法二：滑动窗口"><a href="#解法二：滑动窗口" class="headerlink" title="解法二：滑动窗口"></a>解法二：滑动窗口</h3><p>整体思路同一，尽管整体的时间复杂度没变，但是优化了搜索过程：</p><p><strong>搜索过程的时间复杂度从 O(2n × log2n) 降低为 O(2n × 2n)</strong></p> <img src="/2021/12/16/%E5%8F%AF%E8%A7%81%E7%82%B9%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/时空复杂度.png" alt="复杂度对比" style="zoom: 80%;"><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">visiblePoints</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; points, <span class="keyword">int</span> angle, List&lt;Integer&gt; location)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sameCnt = <span class="number">0</span>;</span><br><span class="line">        List&lt;Double&gt; polarDegrees = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> locationX = location.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> locationY = location.get(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = points.get(i).get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> y = points.get(i).get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (x == locationX &amp;&amp; y == locationY) &#123;</span><br><span class="line">                sameCnt++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Double degree = Math.atan2(y - locationY, x - locationX);</span><br><span class="line">            polarDegrees.add(degree);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(polarDegrees);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = polarDegrees.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            polarDegrees.add(polarDegrees.get(i) + <span class="number">2</span> * Math.PI);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> toDegree = angle * Math.PI / <span class="number">180</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            Double curr = polarDegrees.get(i) + toDegree;</span><br><span class="line">            <span class="keyword">while</span> (right &lt; polarDegrees.size() &amp;&amp; polarDegrees.get(right) &lt;= curr) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            maxCnt = Math.max(maxCnt, right - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxCnt + sameCnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n×logn)<br>&amp;空间复杂度:O(n)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单词拆分</title>
      <link href="/2021/12/15/%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/"/>
      <url>/2021/12/15/%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h3 id="单词拆分（-动态规划-）"><a href="#单词拆分（-动态规划-）" class="headerlink" title="单词拆分（ 动态规划 ）"></a>单词拆分（ 动态规划 ）</h3><span id="more"></span><blockquote><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典，</p><p>判定 s 是否可以由空格拆分为一个或多个在字典中出现的单词。</p><p>说明：拆分时可以重复使用字典中的单词。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>题目详情参考：<a href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><h3 id="解法一：模拟遍历（错误）"><a href="#解法一：模拟遍历（错误）" class="headerlink" title="解法一：模拟遍历（错误）"></a>解法一：模拟遍历（错误）</h3><p>思路：</p><ol><li>将字典中的单词放入哈希表中，创建变量记录当前字符串；</li><li>遍历字符串，当哈希表中含有此单词，那么清空当前字符串，否则继续；</li><li>在遍历过程中，变量 <code>ans</code> ，记录当前的真值。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String word : wordDict) &#123;</span><br><span class="line">            set.add(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> ans = <span class="keyword">true</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();                 </span><br><span class="line">        <span class="keyword">while</span>(index &lt;= s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(sb.toString())) &#123;</span><br><span class="line">                sb.delete(<span class="number">0</span>, sb.length());</span><br><span class="line">                ans = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(index &lt; s.length()) &#123;</span><br><span class="line">                sb.append(s.charAt(index));</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>错误原因：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;aaaaaaa&quot;, wordDict = [&quot;aaa&quot;, &quot;aaaa&quot;]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>对于上述用例时，就会出错，因为会先处理 <code>aaa</code> 的情况，导致结果出错。</p><hr><h3 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h3><p>思路：如果当前字符串能够被拆分，一定存在空格位置，使其分割。</p><ol><li>创建数组 <code>dp</code> ，<code>dp[i]</code> 表示以 <code>i</code> 下标结尾的子串是否在字典中含有；</li><li>依然用哈希表存储字典中的单词，以便快速查询；</li><li>那么对于 <code>dp[i]</code> 而言，如果其能够被拆分，那么不妨设被拆分的点为 <code>j</code> ：</li></ol><p>$$<br>dp[i] = dp[j]\  \&amp; \&amp; \ check(s[j，i-1])<br>$$</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; wordDictSet = <span class="keyword">new</span> HashSet(wordDict);</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] &amp;&amp; wordDictSet.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n^2)<br>&amp;空间复杂度:O(n)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>喧闹和富有</title>
      <link href="/2021/12/15/%E5%96%A7%E9%97%B9%E5%92%8C%E5%AF%8C%E6%9C%89/"/>
      <url>/2021/12/15/%E5%96%A7%E9%97%B9%E5%92%8C%E5%AF%8C%E6%9C%89/</url>
      
        <content type="html"><![CDATA[<h3 id="喧闹和富有（-DFS-拓扑排序-）"><a href="#喧闹和富有（-DFS-拓扑排序-）" class="headerlink" title="喧闹和富有（ DFS | 拓扑排序 ）"></a>喧闹和富有（ DFS | 拓扑排序 ）</h3><span id="more"></span><blockquote><p>题目详情参考：<a href="https://leetcode-cn.com/problems/loud-and-rich/">851. 喧闹和富有 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><p>心得：第一次遇见和学习有关图的问题，日复一日，必有精进。</p><h3 id="解法一：深度优先搜索"><a href="#解法一：深度优先搜索" class="headerlink" title="解法一：深度优先搜索"></a>解法一：深度优先搜索</h3><p>思路：建立一个有向图，然后从当前点出发搜索满足题意的点。</p><ol><li>每一个人的位置看成一个点，如果 <code>x</code> 比 <code>y</code> 更有钱，那么就从 <code>y</code> 向 <code>x</code> 连一条有向边；</li><li>根据题目所给数组，构建一个有向图，并且由题可知，不存在环；</li><li>因此从图上任意一点（设为 <code>x</code> ）出发，沿着有向边所能访问到的点，都比 <code>x</code> 更有钱；</li><li>题目需要计算拥有的钱肯定不少于 <code>x</code> 的人中，最安静的人，包括两种人：<ol><li>拥有的钱等于 <code>x</code> ，比如 <code>x</code> 本身；</li><li>拥有的钱大于 <code>x</code> ，有向边所能访问的点；</li></ol></li><li>因此搜索所能到达的点，寻找答案；</li><li>如果当前位置已经计算出最安静的人，那么就不再搜索，减少搜索。</li></ol> <img src="/2021/12/15/%E5%96%A7%E9%97%B9%E5%92%8C%E5%AF%8C%E6%9C%89/示例图.png" alt="示例图" style="zoom: 33%;"><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] loudAndRich(<span class="keyword">int</span>[][] richer, <span class="keyword">int</span>[] quiet) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = quiet.length;</span><br><span class="line">        List&lt;Integer&gt;[] graph = <span class="keyword">new</span> List[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] value : richer) &#123;</span><br><span class="line">            graph[value[<span class="number">1</span>]].add(value[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(ans, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dfs(i, quiet, graph, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span>[] quiet, List&lt;Integer&gt;[] graph, <span class="keyword">int</span>[] ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[x] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[x] = x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> next : graph[x]) &#123;</span><br><span class="line">            dfs(next, quiet, graph, ans);</span><br><span class="line">            <span class="keyword">if</span> (quiet[ans[next]] &lt; quiet[ans[x]]) &#123;</span><br><span class="line">                ans[x] = ans[next];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(n)<br>\end{align}<br>$$</p><hr><h3 id="解法二：拓扑排序"><a href="#解法二：拓扑排序" class="headerlink" title="解法二：拓扑排序"></a>解法二：拓扑排序</h3><p>思路：与思路一不同之处在于，有向图的方向为钱多指向钱少。</p><ol><li>每一个人的位置看成一个点，<strong>如果 <code>x</code> 比 <code>y</code> 更有钱，那么就从 <code>x</code> 向 <code>y</code> 连一条有向边；</strong></li><li>与此同时，<strong>记录每一个点的入度，</strong>以便后续处理；</li><li>从图上任意一点（设为 <code>x</code> ）出发，沿着有向边所能访问到的点，都没有 <code>x</code> 有钱；</li><li>因此可以在计算出 <code>ans[x]</code> 后，用 <code>ans[x]</code> 去更新 x 所能访问到的点的 <code>ans</code> 值</li><li>具体开始时，依次遍历入度为 0 的点，访问更新值，并且减少已经访问点的入度；</li></ol> <img src="/2021/12/15/%E5%96%A7%E9%97%B9%E5%92%8C%E5%AF%8C%E6%9C%89/拓扑排序.png" alt="示例图" style="zoom: 33%;"><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] loudAndRich(<span class="keyword">int</span>[][] richer, <span class="keyword">int</span>[] quiet) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = quiet.length;</span><br><span class="line">        List&lt;Integer&gt;[] graph = <span class="keyword">new</span> List[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] inDeg = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] value : richer) &#123;</span><br><span class="line">            graph[value[<span class="number">0</span>]].add(value[<span class="number">1</span>]);</span><br><span class="line">            inDeg[value[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> next : graph[x]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (quiet[ans[x]] &lt; quiet[ans[next]]) &#123;</span><br><span class="line">                    ans[next] = ans[x];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (--inDeg[next] == <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.offer(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(n)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跳跃游戏</title>
      <link href="/2021/12/14/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
      <url>/2021/12/14/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="跳跃游戏（-贪心-）"><a href="#跳跃游戏（-贪心-）" class="headerlink" title="跳跃游戏（ 贪心 ）"></a>跳跃游戏（ 贪心 ）</h3><span id="more"></span><h3 id="跳跃游戏Ⅰ"><a href="#跳跃游戏Ⅰ" class="headerlink" title="跳跃游戏Ⅰ"></a>跳跃游戏Ⅰ</h3><blockquote><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>题目详情参考：<a href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><p>思路：只需要判断是否能够跳到最终位置即可，那么不妨直接求总体跳跃的最大距离即可。</p><ol><li>定义一个变量 <code>visitedEnd</code> 表示遍历过程中得到的总体跳跃最大距离；</li><li>循环遍历数组，更新上述变量，最后判断是否超过终点即可。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> visitedEnd = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visitedEnd &gt;= nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= visitedEnd) &#123;</span><br><span class="line">            visitedEnd = Math.max(i + nums[i], visitedEnd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p><hr><h3 id="跳跃游戏Ⅱ"><a href="#跳跃游戏Ⅱ" class="headerlink" title="跳跃游戏Ⅱ"></a>跳跃游戏Ⅱ</h3><blockquote><p>给你一个非负整数数组 nums ，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>假设你总是可以到达数组的最后一个位置。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>题目详情参考：<a href="https://leetcode-cn.com/problems/jump-game-ii/">45. 跳跃游戏 II - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><p>思路：和跳跃游戏Ⅰ不同之处在于，该题需要求解最少跳跃次数。</p><ol><li><strong>首先明确一个准则，如果能够跳跃至终点，那么路径上的任何一点都可以到达；</strong></li><li>因此，只需要从终点往前求出最远的跳跃位置即可，然后更新终点；</li><li>以此类推，直至终点和起点相同即可；</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (begin + nums[begin] &gt;= end) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            end = begin;</span><br><span class="line">            begin = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            begin++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 贪心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打家劫舍系列问题</title>
      <link href="/2021/12/13/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98/"/>
      <url>/2021/12/13/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="打家劫舍系列问题（-动态规划-）"><a href="#打家劫舍系列问题（-动态规划-）" class="headerlink" title="打家劫舍系列问题（ 动态规划 ）"></a>打家劫舍系列问题（ 动态规划 ）</h3><span id="more"></span><h3 id="打家劫舍Ⅰ"><a href="#打家劫舍Ⅰ" class="headerlink" title="打家劫舍Ⅰ"></a>打家劫舍Ⅰ</h3><blockquote><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，</p><p>影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，</p><p>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，</p><p>计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p>题目详情参考：<a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><p>思路：动态规划的经典题目，<strong>一定要先找到动态转移方程！</strong></p><ol><li>不妨设一维数组 <code>dp</code> ，<strong>其中 <code>dp[i]</code> 表示在从 <code>0</code> 到 <code>i</code> 时，所能偷取的最大金额；</strong></li><li>那么根据题意可知，所偷的房子不能相邻，因此得到如下转移方程：</li></ol><p>$$<br>dp[i] = max\lbrace dp[i - 1],dp[i - 2] + nums[i] \rbrace<br>$$</p><ol start="3"><li>即在当前位置，有两种选择：<ol><li>不偷当前位置的房子，那么相当于偷前一个房子；</li><li>偷当前位置的房子，那么相当于不偷前一个房子；</li></ol></li><li><strong>补充：也可以使用滚动数组降低空间复杂度！</strong></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> ans = Math.max(dp[<span class="number">0</span>], dp[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">            ans = Math.max(dp[i], ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(n)<br>\end{align}<br>$$</p><hr><h3 id="打家劫舍Ⅱ"><a href="#打家劫舍Ⅱ" class="headerlink" title="打家劫舍Ⅱ"></a>打家劫舍Ⅱ</h3><blockquote><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。</p><p>这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。</p><p>同时，相邻的房屋装有相互连通的防盗系统，</p><p>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，</p><p>计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p><p>题目详情参考：<a href="https://leetcode-cn.com/problems/house-robber-ii/">213. 打家劫舍 II - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><p>思路：该题和第一题的不同之处在于，这次房屋不是直线而是闭合的环。</p><ol><li>如果偷了第一家，那么偷的范围应为 <code>0 ~ length - 1</code>；</li><li>如果不偷第一家，那么偷的范围应为 <code>1 ~ length</code>；</li><li><strong>这两个解集的并集，包括所有情况，可以仔细思考一下；</strong></li><li>其余思路和第一问相同。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="comment">// get max value from 0 to length - 1</span></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> ans = Math.max(dp[<span class="number">0</span>], dp[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">            ans = Math.max(dp[i], ans);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get max value from 1 to length</span></span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>] = Math.max(nums[<span class="number">1</span>], nums[<span class="number">2</span>]);</span><br><span class="line">        ans = Math.max(ans, Math.max(dp[<span class="number">1</span>], dp[<span class="number">2</span>]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">            ans = Math.max(dp[i], ans);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(n)<br>\end{align}<br>$$</p><hr><h3 id="变形题：删除并获得点数"><a href="#变形题：删除并获得点数" class="headerlink" title="变形题：删除并获得点数"></a>变形题：删除并获得点数</h3><blockquote><p>给你一个整数数组 nums ，你可以对它进行一些操作。</p><p>每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。</p><p>之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。</p><p>开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,3,3,3,4]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure><p>题目详情参考：<a href="https://leetcode-cn.com/problems/delete-and-earn/">740. 删除并获得点数 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><p>思路：将该题转变为上面两题，二者的整体思路相差不多。</p><ol><li><p><strong>采用Map统计</strong>数组中各自元素的值和数量，以便后续求点数；</p></li><li><p>不妨设二维数组 <code>dp</code> ，</p><ul><li><p><code>dp[i][0]</code> 表示当前位置的元素；</p></li><li><p><code>dp[i][1]</code> 表示当前位置下元素的个数；</p></li><li><p><code>dp[i][2]</code> <strong>表示从开始至当前位置下所能获得最大点数；</strong></p></li></ul></li><li><p>对 <code>dp</code> 进行排序，那么对于 <code>dp[i]</code> 可以得到下面的情况：</p><ol><li>如果 <code>dp[i - 1][0] + 1</code> 等于 <code>dp[i][0]</code> ；</li><li>如果 <code>dp[i - 1][0] + 1</code> 不等于 <code>dp[i][0]</code> ；</li><li><strong>上述两种情况等价于第一题中的房子是否相邻！</strong></li></ol></li><li><p>那么可以得到动态转移方程：</p></li></ol><p>$$<br>dp[i][2]=\begin{cases}max\lbrace dp[i - 1][2],dp[i-2][2]+dp[i][0]×dp[i][1] \rbrace &amp;dp[i-1][0] + 1=dp[i][0] \\ dp[i-1][2]+dp[i][0]×dp[i][1] &amp;反之\end{cases}<br>$$</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteAndEarn</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = getElementNumArray(nums);</span><br><span class="line">        Arrays.sort(dp, (o1, o2) -&gt; o1[<span class="number">0</span>] - o2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = dp[<span class="number">0</span>][<span class="number">0</span>] * dp[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (dp.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[<span class="number">1</span>][<span class="number">0</span>] == dp[<span class="number">0</span>][<span class="number">0</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">2</span>] = Math.max(dp[<span class="number">0</span>][<span class="number">2</span>], dp[<span class="number">1</span>][<span class="number">0</span>] * dp[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">2</span>] = dp[<span class="number">0</span>][<span class="number">2</span>] + dp[<span class="number">1</span>][<span class="number">0</span>] * dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(dp[<span class="number">0</span>][<span class="number">2</span>], dp[<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">if</span> (dp.length == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i][<span class="number">0</span>] == dp[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">2</span>] = dp[i - <span class="number">2</span>][<span class="number">2</span>] + dp[i][<span class="number">0</span>] * dp[i][<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>] + dp[i][<span class="number">0</span>] * dp[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(dp[i][<span class="number">2</span>], ans);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] getElementNumArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[map.size()][<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            arr[index][<span class="number">0</span>] = entry.getKey();</span><br><span class="line">            arr[index][<span class="number">1</span>] = entry.getValue();</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(n)<br>\end{align}<br>$$</p><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树的基本操作</title>
      <link href="/2021/12/11/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2021/12/11/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="二叉搜索树的基本操作"><a href="#二叉搜索树的基本操作" class="headerlink" title="二叉搜索树的基本操作"></a>二叉搜索树的基本操作</h3><span id="more"></span> <img src="/2021/12/11/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/示例图.png" alt="示例图" style="zoom:67%;"><p>如上图所示的一棵树，左孩子以及其子树小于父亲，右孩子以及其子树大于父亲的结构。</p><h3 id="二叉搜索树中的搜索"><a href="#二叉搜索树中的搜索" class="headerlink" title="二叉搜索树中的搜索"></a>二叉搜索树中的搜索</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; val) &#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.left, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; val) &#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二叉搜索树的插入操作"><a href="#二叉搜索树的插入操作" class="headerlink" title="二叉搜索树的插入操作"></a>二叉搜索树的插入操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &gt; root.val) &#123;</span><br><span class="line">            root.right = insertIntoBST(root.right, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.left = insertIntoBST(root.left, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二叉搜索树的验证"><a href="#二叉搜索树的验证" class="headerlink" title="二叉搜索树的验证"></a>二叉搜索树的验证</h3><h4 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h4><p>不仅仅需要保证当前结构下的左右孩子满足搜索树，</p><p><strong>还要保证左右孩子不破坏整体的搜索树结构</strong>，因此记录父亲结点的父亲值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode node, <span class="keyword">long</span> lower, <span class="keyword">long</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.val &lt;= lower || node.val &gt;= upper) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> isLeftCorrect = isValidBST(node.left, lower, node.val);</span><br><span class="line">        <span class="keyword">boolean</span> isRightCorrect = isValidBST(node.right, node.val, upper);</span><br><span class="line">        <span class="keyword">return</span> isLeftCorrect &amp;&amp; isRightCorrect;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解法二：中序遍历"><a href="#解法二：中序遍历" class="headerlink" title="解法二：中序遍历"></a>解法二：中序遍历</h4><p><strong>二叉搜索树的中序遍历是递增的</strong>，根据此性质判断即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">double</span> inorder = -Double.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">              <span class="comment">// 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树</span></span><br><span class="line">            <span class="keyword">if</span> (root.val &lt;= inorder) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            inorder = root.val;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合</title>
      <link href="/2021/12/10/%E7%BB%84%E5%90%88/"/>
      <url>/2021/12/10/%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><span id="more"></span><blockquote><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p></blockquote><h3 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>找到一个长度为 <code>n</code> 的序列 <code>a</code> 的所有子序列，代码框架如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == n + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 记录答案</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 考虑选择当前位置</span></span><br><span class="line">    temp.push_back(cur);</span><br><span class="line">    dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">    temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 考虑不选择当前位置</span></span><br><span class="line">    dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于本题，加上一些改进和优化：</p><ol><li>剪枝：如果当前 <code>temp</code> 内的元素数量和后续待选的总和小于所求，返回；</li><li>不判断 <code>curr == n + 1</code>，判断当前解集是否正确满足即可。</li></ol><p><strong>为什么记录合法的答案时为<code>ans.add(new ArrayList&lt;&gt;(temp))</code>？</strong></p><p>如果是<code>ans.add(temp)</code>，那么<strong>放入的是一个引用类型，其值在递归过程中一直变化，</strong></p><p>导致最终存储的数据也发生变化，因此需要重新开辟，再放入解集中。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        dfs(<span class="number">1</span>, n, k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 剪枝：temp 长度加上区间 [cur, n] 的长度小于 k，不可能构造出长度为 k 的 temp</span></span><br><span class="line">        <span class="keyword">if</span> (temp.size() + (n - cur + <span class="number">1</span>) &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录合法的答案</span></span><br><span class="line">        <span class="keyword">if</span> (temp.size() == k) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑选择当前位置</span></span><br><span class="line">        temp.add(cur);</span><br><span class="line">        dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">        temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 考虑不选择当前位置</span></span><br><span class="line">        dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(C^k_n×k)<br>&amp;空间复杂度:O(n+k)=O(n)<br>\end{align}<br>$$</p><hr><h3 id="解法二：字典序法"><a href="#解法二：字典序法" class="headerlink" title="解法二：字典序法"></a>解法二：字典序法</h3><p>思路：希望通过合适的手段，消除递归栈带来的额外空间代价。</p><p><strong>考虑一个二进制数数字 x，它由 k 个 1 和 n − k 个 0 组成</strong></p><ol><li>用含 k 个 1 的二进制数表示方案，1 表示选取 0 表示不选取，下图为例</li></ol><table><thead><tr><th align="center">原序列中被选的数</th><th align="center">对应的二进制数</th><th align="center">方案</th></tr></thead><tbody><tr><td align="center">4 3 [2] [1]</td><td align="center">0011</td><td align="center">1 2</td></tr><tr><td align="center">4 [3] 2 [1]</td><td align="center">0101</td><td align="center">1 3</td></tr><tr><td align="center">4 [3] [2] 1</td><td align="center">0110</td><td align="center">2 3</td></tr><tr><td align="center">[4] 3 2 [1]</td><td align="center">1001</td><td align="center">1 4</td></tr><tr><td align="center">[4] 3 [2] 1</td><td align="center">1010</td><td align="center">2 4</td></tr><tr><td align="center">[4] [3] 2 1</td><td align="center">1100</td><td align="center">3 4</td></tr></tbody></table><ol start="2"><li><p>如何获得二进制数的字典序，即从小到大，如下两个规则：</p><ol><li><p>如果当前最低位为 1，不妨设末尾由 t 个连续的 1 组成，</p><p>直接将倒数第 t 位的 1 和倒数第 t + 1 位的 0 替换即可；</p><p>比如：1001111 → 1010111</p></li><li><p>如果当前最低位为 0，不妨设末尾由 t 个连续的 0 组成，而这之前有 m 个连续的 1，</p><p>将倒数第 t + m 位置的 1 和倒数第 t + m + 1 位的 0 对换，</p><p>然后把倒数第 t + 1 位到倒数第 t + m − 1 位的 1 移动到最低位；</p><p>比如：1011100 → 1100011</p></li><li><p><strong>实际上规则一是规则二 t 为 0 的特殊情况。</strong></p></li></ol></li></ol><h4 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        initTemp(n, k);</span><br><span class="line">        <span class="keyword">while</span> (!isEnd(k)) &#123;</span><br><span class="line">            getMappingElement(temp);</span><br><span class="line">            getNewTemp();</span><br><span class="line">        &#125;</span><br><span class="line">        getMappingElement(temp);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initTemp</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            temp.add(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k + <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            temp.add(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEnd</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = temp.size() - <span class="number">1</span>; i &gt;= temp.size() - k; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.get(i) != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getMappingElement</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list.get(i) == <span class="number">1</span>) &#123;</span><br><span class="line">                temp.add(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getNewTemp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = getConstantZeroSum();</span><br><span class="line">        <span class="keyword">int</span> m = getConstantOneSum(t);</span><br><span class="line">        temp.set(t + m - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        temp.set(t + m, <span class="number">1</span>);</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i &lt; t + m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            list.add(temp.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line">            list.add(temp.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = t + m - <span class="number">1</span>; i &lt; temp.size(); i++) &#123;</span><br><span class="line">            list.add(temp.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        temp = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getConstantZeroSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> constanZeroSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.get(i) == <span class="number">0</span>) &#123;</span><br><span class="line">                constanZeroSum++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> constanZeroSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getConstantOneSum</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> constantOneSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i &lt; temp.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.get(i) == <span class="number">1</span>) &#123;</span><br><span class="line">                constantOneSum++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> constantOneSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化处理："><a href="#优化处理：" class="headerlink" title="优化处理："></a>优化处理：</h4><p>不通过存储一个二进制序列迭代得到方案，而是直接在方案本身上操作；</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="comment">// 将 temp 中 [0, k - 1] 每个位置 i 设置为 i + 1，即 [0, k - 1] 存 [1, k]</span></span><br><span class="line">        <span class="comment">// 末尾加一位 n + 1 作为哨兵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">            temp.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        temp.add(n + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(temp.subList(<span class="number">0</span>, k)));</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 寻找第一个 temp[j] + 1 != temp[j + 1] 的位置 t</span></span><br><span class="line">            <span class="comment">// 我们需要把 [0, t - 1] 区间内的每个位置重置成 [1, t]</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; k &amp;&amp; temp.get(j) + <span class="number">1</span> == temp.get(j + <span class="number">1</span>)) &#123;</span><br><span class="line">                temp.set(j, j + <span class="number">1</span>);</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// j 是第一个 temp[j] + 1 != temp[j + 1] 的位置</span></span><br><span class="line">            temp.set(j, temp.get(j) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(C^k_n×k)<br>&amp;空间复杂度:O(k)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01矩阵</title>
      <link href="/2021/12/09/01%E7%9F%A9%E9%98%B5/"/>
      <url>/2021/12/09/01%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="01矩阵（-动态规划-）"><a href="#01矩阵（-动态规划-）" class="headerlink" title="01矩阵（ 动态规划 ）"></a>01矩阵（ 动态规划 ）</h3><span id="more"></span><blockquote><p>给定一个由 0 和 1 组成的矩阵 mat ，请输出一个大小相同的矩阵，</p><p>其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。</p><p>两个相邻元素间的距离为 1 。</p><p>题目详情参考：<a href="https://leetcode-cn.com/problems/01-matrix/">542. 01 矩阵 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><p>思路：首先该题也可以广度优先搜索，但是这次尝试动态规划解决问题。</p><ol><li>首先明确一点：<strong>一个点到另一个点的最近距离移动方式</strong>一定是以下四种：<ol><li>只有水平向左移动和竖直向上移动</li><li>只有水平向左移动和竖直向下移动</li><li>只有水平向右移动和竖直向上移动</li><li>只有水平向右移动和竖直向下移动</li></ol></li><li>创建一个二维数组 <em>dp[i][j]</em> ,其值表示当前点到最近 <code>0</code> 的距离；</li><li>那么以<strong><em>只有水平向左移动和竖直向上移动 </em></strong>来举例说明转移方程：</li></ol><p>$$<br>dp[i][j]=\begin{cases}1+min\lbrace dp[i][j-1],dp[i-1][j]\rbrace&amp;当前位置元素为\ 1\\<br>0&amp;当前位置元素为\ 0\end{cases}<br>$$</p><ol start="4"><li>因此只需要对这四种方式都进行一次动态规划转移方程即可；</li><li><strong>需要注意动态规划的计算顺序：从移动方式的对角开始遍历！</strong></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp;</span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] mat) &#123;</span><br><span class="line">        initDpArray(mat);</span><br><span class="line">        moveByDirs();</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initDpArray</span><span class="params">(<span class="keyword">int</span>[][] mat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.row = mat.length;</span><br><span class="line">        <span class="keyword">this</span>.col = mat[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">this</span>.dp = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], Integer.MAX_VALUE / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mat[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveByDirs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        moveLeftOrUp();</span><br><span class="line">        moveLeftOrDown();</span><br><span class="line">        moveRightOrUp();</span><br><span class="line">        moveRightOrDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveLeftOrUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveLeftOrDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; row) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i + <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveRightOrUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = col - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt; col) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i][j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveRightOrDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = col - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; row) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i + <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt; col) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i][j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(m×n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的层序遍历</title>
      <link href="/2021/12/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/2021/12/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h3><span id="more"></span> <img src="/2021/12/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/示例图.png" alt="示例图" style="zoom:67%;"><p><code>以上图为例: [[A],[B,C],[D,E,F,G],[H,I],[J]]</code></p><p>思路：</p><ol><li><p>遍历结点，将结点放入队列中，刚好按层处理；</p></li><li><p>这里有个细节，如何按层处理：</p><p><strong>每次处理时，处理当前队列中的所有结点，这些结点一定是同层！</strong></p></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> currentSize = queue.size();</span><br><span class="line">            List&lt;Integer&gt; layer = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; currentSize; i++) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    layer.add(node.val);</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(layer.size() != <span class="number">0</span>) &#123;</span><br><span class="line">                ans.add(layer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(n)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>定长子数组的最大和</title>
      <link href="/2021/12/08/%E5%AE%9A%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
      <url>/2021/12/08/%E5%AE%9A%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="定长子数组的最大和（-滑动窗口-）"><a href="#定长子数组的最大和（-滑动窗口-）" class="headerlink" title="定长子数组的最大和（ 滑动窗口 ）"></a>定长子数组的最大和（ 滑动窗口 ）</h3><span id="more"></span><blockquote><p>给你一个整数数组 nums 和一个整数 k ，找出三个长度为 k 、互不重叠、</p><p>且 3 * k 项的和最大的子数组，并返回这三个子数组。</p><p>以下标的数组形式返回结果，数组中的每一项分别指示每个子数组的起始位置（下标从 0 开始）。</p><p>如果有多个结果，返回字典序最小的一个。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：nums = [1,2,1,2,6,7,5,1], k = 2</span><br><span class="line">&gt;输出：[0,3,5]</span><br></pre></td></tr></table></figure><p>题目详情参考：<a href="https://leetcode-cn.com/problems/maximum-sum-of-3-non-overlapping-subarrays/">689. 三个无重叠子数组的最大和 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><h3 id="解法一：滑动窗口"><a href="#解法一：滑动窗口" class="headerlink" title="解法一：滑动窗口"></a>解法一：滑动窗口</h3><p>思路：三个长度为 k 且不互相重叠的子数组最大和，先考虑一个、两个的情况。</p><h4 id="模型一：单个长度为-k-的子数组最大和"><a href="#模型一：单个长度为-k-的子数组最大和" class="headerlink" title="模型一：单个长度为 k 的子数组最大和"></a>模型一：单个长度为 k 的子数组最大和</h4><p>思路：规定一个长度为 k 的窗口，向右滑动，寻找最大和。</p><ol><li>求和时不需要每次都重新求和，这样会增加时间复杂度；</li><li>窗口向右滑动过程中，减去左值，加上新值，即为这一段数组和；</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSumOfOneSubarray(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> sum1 = <span class="number">0</span>, maxSum1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            sum1 += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sum1 &gt; maxSum1) &#123;</span><br><span class="line">                    maxSum1 = sum1;</span><br><span class="line">                    ans[<span class="number">0</span>] = i - k + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sum1 -= nums[i - k + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p><h4 id="模型二：两个长度为-k-的不重叠子数组最大和"><a href="#模型二：两个长度为-k-的不重叠子数组最大和" class="headerlink" title="模型二：两个长度为 k 的不重叠子数组最大和"></a>模型二：两个长度为 k 的不重叠子数组最大和</h4><p>思路：规定两个长度为 k 的不重叠窗口，第一个从 [0,k-1]开始，第二个从[k,2k - 1]开始；</p><ol><li>两个窗口同时向右滑动，滑动过程中，记录更新第一个窗口的最大和值 <code>maxSum1</code>；</li><li>每次记录更新 <code>maxSum1</code> + <code>sum2</code> 的最大值，并存储下标信息即对应位置；</li></ol><p>思路正确性的说明：</p><ol><li>对于窗口二而言，每次加上的一定是前面不与自己重叠的最大窗口值；</li><li>而对于整体而言，两个窗口和的最大值也在不断随之更新。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSumOfTwoSubarrays(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> sum1 = <span class="number">0</span>, maxSum1 = <span class="number">0</span>, maxSum1Idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum2 = <span class="number">0</span>, maxSum12 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            sum1 += nums[i - k];</span><br><span class="line">            sum2 += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k * <span class="number">2</span> - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sum1 &gt; maxSum1) &#123;</span><br><span class="line">                    maxSum1 = sum1;</span><br><span class="line">                    maxSum1Idx = i - k * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (maxSum1 + sum2 &gt; maxSum12) &#123;</span><br><span class="line">                    maxSum12 = maxSum1 + sum2;</span><br><span class="line">                    ans[<span class="number">0</span>] = maxSum1Idx;</span><br><span class="line">                    ans[<span class="number">1</span>] = i - k + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sum1 -= nums[i - k * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">                sum2 -= nums[i - k + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p><h4 id="该题目的解析："><a href="#该题目的解析：" class="headerlink" title="该题目的解析："></a>该题目的解析：</h4><p>思路：规定两个长度为 k 的不重叠窗口，分别从[0,k-1]、[k,2k - 1]、[2k,3k-1]开始，；</p><ol><li>我们同时向右滑动这三个窗口，按照模型二的方法并维护 maxSum12 及其对应位置；</li><li>每次滑动时，计算当前 maxSum12 与 sum3之和；</li><li>统计这一过程中的 maxSum12 + sum3 的最大值及其对应位置；</li><li>当且仅当最大和值大于记录时，才更新下标，保证字典序。</li></ol><p><strong>细节：在更新 maxSum12 时也更新两个窗口的起始位置，因为第一个窗口最大时，不意味着和最大。</strong></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSumOfThreeSubarrays(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> sum1 = <span class="number">0</span>, maxSum1 = <span class="number">0</span>, maxSum1Index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum2 = <span class="number">0</span>, maxSum12 = <span class="number">0</span>, maxSum2Index1 = <span class="number">0</span>, maxSum2Index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum3 = <span class="number">0</span>, maxTotal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * k; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum1 += nums[i - <span class="number">2</span> * k];</span><br><span class="line">            sum2 += nums[i - k];</span><br><span class="line">            sum3 += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">3</span> * k - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sum1 &gt; maxSum1) &#123;</span><br><span class="line">                    maxSum1 = sum1;</span><br><span class="line">                    maxSum1Index = i - <span class="number">3</span> * k + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sum2 + maxSum1 &gt; maxSum12) &#123;</span><br><span class="line">                    maxSum12 = sum2 + maxSum1;</span><br><span class="line">                    maxSum2Index1 = maxSum1Index;</span><br><span class="line">                    maxSum2Index2 = i - <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sum3 + maxSum12 &gt; maxTotal) &#123;</span><br><span class="line">                    maxTotal = sum3 + maxSum12;</span><br><span class="line">                    ans[<span class="number">0</span>] = maxSum2Index1;</span><br><span class="line">                    ans[<span class="number">1</span>] = maxSum2Index2;</span><br><span class="line">                    ans[<span class="number">2</span>] = i - k + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sum1 -= nums[i - k * <span class="number">3</span> + <span class="number">1</span>];</span><br><span class="line">                sum2 -= nums[i - k * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">                sum3 -= nums[i - k + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动零</title>
      <link href="/2021/12/06/%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
      <url>/2021/12/06/%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="移动零（-双指针-）"><a href="#移动零（-双指针-）" class="headerlink" title="移动零（ 双指针 ）"></a>移动零（ 双指针 ）</h3><span id="more"></span><blockquote><blockquote><p>给定数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="解法一：模拟遍历"><a href="#解法一：模拟遍历" class="headerlink" title="解法一：模拟遍历"></a>解法一：模拟遍历</h3><p>思路：遍历数组，每次遇到 <code>0</code> ，将此位置后的所有元素前移，然后数组末尾补 <code>0</code> ；</p><p>细节：特殊情况 <code>0 0 1 0 3 2</code> → <code>0 1 0 3 2 0</code>，此时下标已经向前移动了，会越过 <code>0</code> 。</p><ol><li>每次移动数组后，向后遍历，如果全为 <code>0</code> 则退出；</li><li>如果不全为 <code>0</code>，并且此时 <code>i</code> 下标的元素为 <code>0</code>，那么回退一步；</li><li>上面都不满足，继续遍历，不需要更改循环。</li></ol><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 遇到 0,位置后的所有元素前移，末尾补 0 </span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; nums.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                    nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                nums[nums.length - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 防止出现移动后,少处理0的情况</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                        i--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果全是0,则结束</span></span><br><span class="line">                <span class="keyword">if</span>(j == nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n^2)<br>&amp;空间复杂度:O(n)<br>\end{align}<br>$$</p><hr><h3 id="解法二：双指针"><a href="#解法二：双指针" class="headerlink" title="解法二：双指针"></a>解法二：双指针</h3><p>思路：使用双指针，<strong>左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。</strong></p><ol><li><p>右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。</p></li><li><p>注意到以下性质：</p><ol><li><p>左指针左边均为非零数；</p></li><li><p>右指针左边直到左指针处均为零。</p></li></ol></li><li><p>因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。</p></li></ol><p><strong>难点说明：</strong></p><ol><li>如果当前左右指针相等，那么二者同时移动，即均加一；</li><li>当遇到 <code>0</code> 时，快指针继续向前寻找非零元素，慢指针则停留在 <code>0</code> 处等待； </li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[slow];</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">                nums[fast++] = temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fast++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环形链表</title>
      <link href="/2021/12/06/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/12/06/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="环形链表（-双指针-）"><a href="#环形链表（-双指针-）" class="headerlink" title="环形链表（ 双指针 ）"></a>环形链表（ 双指针 ）</h3><span id="more"></span><blockquote><blockquote><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>题目详情参考：<a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote></blockquote><h3 id="解法一：数学"><a href="#解法一：数学" class="headerlink" title="解法一：数学"></a>解法一：数学</h3><p>思路：因为该题目的链表长度有上限，所以遍历链表，记录节点数，如果大于上限，那么一定存在环。</p><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count &gt; <span class="number">100001</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p><hr><h3 id="解法二：哈希表"><a href="#解法二：哈希表" class="headerlink" title="解法二：哈希表"></a>解法二：哈希表</h3><p>思路：遍历过程中哈希表记录即可，出现重复即存在环。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(head)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(n)<br>\end{align}<br>$$</p><hr><h3 id="解法三：双指针"><a href="#解法三：双指针" class="headerlink" title="解法三：双指针"></a>解法三：双指针</h3><p>思路：基于<strong>Floyd判圈算法（龟兔赛跑算法）</strong></p><ol><li>定义两个指针：快指针、慢指针，并且快指针移动比慢指针快；</li><li>快指针每次移动两个结点，慢指针每次移动一个结点；</li><li>如果快指针和慢指针对应的结点相同，那么说明存在环。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速幂</title>
      <link href="/2021/12/06/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
      <url>/2021/12/06/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<h3 id="快速幂（-数学-）"><a href="#快速幂（-数学-）" class="headerlink" title="快速幂（ 数学 ）"></a>快速幂（ 数学 ）</h3><span id="more"></span><h3 id="基础快速幂"><a href="#基础快速幂" class="headerlink" title="基础快速幂"></a>基础快速幂</h3><blockquote><blockquote><p>实现 pow(x , n) ，即计算 x 的 n 次幂函数（即，x<sup>n</sup> )。</p><p>题目详情参考：<a href="https://leetcode-cn.com/problems/powx-n/solution/powx-n-by-leetcode-solution/">Pow(x, n) - Pow(x, n) - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote></blockquote><p>思路：分治算法，不去累乘，减少计算量。</p><p>比如计算 x<sup>64</sup>，如果累乘需要计算64次，但是如果按照下面的方法：</p><p>x → x<sup>2</sup> → x<sup>4</sup> → x<sup>8</sup> → x<sup>16</sup> → x<sup>32</sup> → x<sup>64</sup>  只需要计算6次，大大减少了计算量。</p><p><strong>迭代比递归节省了空间，因为递归过程中会使用栈空间。</strong></p><h4 id="递归-代码如下："><a href="#递归-代码如下：" class="headerlink" title="递归    代码如下："></a>递归    代码如下：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> pow(x * x, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> pow(x * x, n / <span class="number">2</span>) * x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            n = Math.abs(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pow(x,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(logn)<br>&amp;空间复杂度:O(logn)<br>\end{align}<br>$$</p><h4 id="迭代-代码如下："><a href="#迭代-代码如下：" class="headerlink" title="迭代    代码如下："></a>迭代    代码如下：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// 贡献的初始值为 x</span></span><br><span class="line">        <span class="keyword">double</span> x_contribute = x;</span><br><span class="line">        <span class="comment">// 在对 N 进行二进制拆分的同时计算答案</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span></span><br><span class="line">                ans *= x_contribute;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将贡献不断地平方</span></span><br><span class="line">            x_contribute *= x_contribute;</span><br><span class="line">            <span class="comment">// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span></span><br><span class="line">            N /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(logn)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p><hr><h3 id="进阶快速幂"><a href="#进阶快速幂" class="headerlink" title="进阶快速幂"></a>进阶快速幂</h3><blockquote><blockquote><p>你的任务是计算 <code>a<sup>b</sup></code> 对 <code>1337</code> 取模，<code>a</code> 是一个正整数，<code>b</code> 是一个非常大的正整数且会以数组形式给出。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = 2, b = [3]</span><br><span class="line">输出：8</span><br></pre></td></tr></table></figure><p>题目详情参考：<a href="https://leetcode-cn.com/problems/super-pow/">372. 超级次方 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote></blockquote><p>思路：依然用到快速幂，但是需要数学推导，推导如下：</p><p><img src="/2021/12/06/%E5%BF%AB%E9%80%9F%E5%B9%82/%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC.png" alt="公式推导"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            ans = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) ans * pow(a, b[i]) % MOD);</span><br><span class="line">            a = pow(a, <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                res = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) res * x % MOD);</span><br><span class="line">            &#125;</span><br><span class="line">            x = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) x * x % MOD);</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(\sum\limits_{i=0}^{m-1}logb_i)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p><p><strong>上述方法是倒序遍历，该题还有一种正序遍历解法：秦九韶算法</strong></p><p>感兴趣可以参考下面题解：<a href="https://leetcode-cn.com/problems/super-pow/solution/chao-ji-ci-fang-by-leetcode-solution-ow8j/">超级次方 - 超级次方 - 力扣（LeetCode） (leetcode-cn.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的三种遍历</title>
      <link href="/2021/12/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86/"/>
      <url>/2021/12/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h3 id="二叉树的三种遍历"><a href="#二叉树的三种遍历" class="headerlink" title="二叉树的三种遍历"></a>二叉树的三种遍历</h3><span id="more"></span><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>给定一棵二叉树的结构如下图所示，分别给出 前序、中序、后序遍历的三种结果：</p> <img src="/2021/12/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86/示例图.png" alt="示例二叉树" style="zoom:67%;"><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">前序：A B D E H C F I J G</span><br><span class="line"></span><br><span class="line">中序：D B H E A J I F C G</span><br><span class="line"></span><br><span class="line">后序：D H E B J I F G C A</span><br></pre></td></tr></table></figure><p><strong>1. 三种方式得到遍历结果</strong></p><p>​    递归、迭代、Morris算法</p><p><strong>2. 先序遍历得到根节点到某一结点的路径</strong></p><p>​    比如上述 A → I ：R L R</p><p><strong>不要使用String，因为String是定长的，因此可能会超出内存限制，使用StringBuilder代替。</strong></p><hr><h3 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h3><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    StringBuilder path = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先序遍历以及给出某一结点路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorderDfs</span><span class="params">(TreeNode root,StringBuilder path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果查询到指定结点值 返回路径</span></span><br><span class="line">        <span class="keyword">if</span>(root.val == res.val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.path.append(path.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先放入根节点</span></span><br><span class="line">        res.add(root.val);</span><br><span class="line">        preorderDfs(root.left,path.append(<span class="string">&#x27;L&#x27;</span>));</span><br><span class="line">        path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">        preorderDfs(root.right,path.append(<span class="string">&#x27;R&#x27;</span>));</span><br><span class="line">        path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorderDfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先放入左节点</span></span><br><span class="line">        inorderDfs(root.left);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        inorderDfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorderDfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postorderDfs(root.left);</span><br><span class="line">        postorderDfs(root.right);</span><br><span class="line">        <span class="comment">// 最后放入根节点</span></span><br><span class="line">        res.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">traversal</span><span class="params">(TreeNode root,<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value; </span><br><span class="line">        preorderDfs(root,<span class="keyword">new</span> StringBuilder())</span><br><span class="line">        inorderDfs(root);</span><br><span class="line">        postorderDfs(root)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(n)<br>\end{align}<br>$$</p><hr><h3 id="迭代遍历"><a href="#迭代遍历" class="headerlink" title="迭代遍历"></a>迭代遍历</h3><p>可以用迭代的方式实现方法一的递归函数，两种方式是等价的，</p><p><strong>区别在于递归的时候隐式地维护了一个栈，在迭代的时候需要显式地将这个栈模拟出来，</strong></p><p>其余的实现与细节都相同。</p><p><strong>迭代遍历相较于递归的优势：可以快速退出遍历。</strong></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                res.add(node.val);</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            ans.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (root.right == <span class="keyword">null</span> || root.right == prev) &#123;</span><br><span class="line">                ans.add(root.val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(n)<br>\end{align}<br>$$</p><hr><h3 id="Morris算法"><a href="#Morris算法" class="headerlink" title="Morris算法"></a>Morris算法</h3>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>房屋间收集雨水</title>
      <link href="/2021/12/04/%E6%88%BF%E5%B1%8B%E9%97%B4%E6%94%B6%E9%9B%86%E9%9B%A8%E6%B0%B4/"/>
      <url>/2021/12/04/%E6%88%BF%E5%B1%8B%E9%97%B4%E6%94%B6%E9%9B%86%E9%9B%A8%E6%B0%B4/</url>
      
        <content type="html"><![CDATA[<h3 id="房屋间收集雨水（-贪心-）"><a href="#房屋间收集雨水（-贪心-）" class="headerlink" title="房屋间收集雨水（ 贪心 ）"></a>房屋间收集雨水（ 贪心 ）</h3><span id="more"></span><blockquote><p>给你一个下标从 0 开始的字符串 street 。</p><p>street 中每个字符要么是表示房屋的 ‘H’ ，要么是表示空位的 ‘.’ 。</p><p>你可以在 空位 放置水桶，从相邻的房屋收集雨水。</p><p>位置在 i - 1 或者 i + 1 的水桶可以收集位置为 i 处房屋的雨水。</p><p>一个水桶如果相邻两个位置都有房屋，那么它可以收集 两个 房屋的雨水。</p><p>在确保每个房屋旁边都至少有一个水桶的前提下，请你返回需要的 最少 水桶数。如果无解请返回 -1 。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：street = &quot;H..H&quot;</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p>题目详情参考：<a href="https://leetcode-cn.com/problems/minimum-number-of-buckets-required-to-collect-rainwater-from-houses/">2086. 从房屋收集雨水需要的最少水桶数 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><p>思路：<strong>如果房屋周围可以收集雨水，那么先判断是否左边可以共享，不行的话尽可能使用右边空间。</strong></p><ol><li>创建变量 <code>index</code> 记录可以被共享的位置，遍历更新即可；</li><li>先判断左边是否存在空位以及是否已被使用，如果可以，那么跳过；</li><li>反之，判断右边是否存在空位，如果可以，记录位置并且更新结果；</li><li>如果左右均没有空位，返回 <code>-1</code>;</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumBuckets</span><span class="params">(String street)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = street.length();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录可以被共享的位置</span></span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(street.charAt(i) == <span class="string">&#x27;H&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 先判断左边是否可以共享</span></span><br><span class="line">                <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; street.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(index != i - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">// 如果左边没有被共享过 优先选择右边</span></span><br><span class="line">                        <span class="keyword">if</span>(i + <span class="number">1</span> &lt; len &amp;&amp; street.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                            index = i + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ans++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i + <span class="number">1</span> &lt; len &amp;&amp; street.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    index = i + <span class="number">1</span>;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 贪心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓄水</title>
      <link href="/2021/12/04/%E8%93%84%E6%B0%B4/"/>
      <url>/2021/12/04/%E8%93%84%E6%B0%B4/</url>
      
        <content type="html"><![CDATA[<h3 id="蓄水（-贪心-）"><a href="#蓄水（-贪心-）" class="headerlink" title="蓄水（ 贪心 ）"></a>蓄水（ 贪心 ）</h3><span id="more"></span><blockquote><blockquote><p>给定 N 个无限容量且初始均空的水缸，每个水缸配有一个水桶用来打水，</p><p>第 i 个水缸配备的水桶容量记作 bucket[i]。</p><p>有以下两种操作：</p><p>升级水桶：选择任意一个水桶，使其容量增加为 bucket[i]+1<br>蓄水：将全部水桶接满水，倒入各自对应的水缸<br>每个水缸对应最低蓄水量记作 vat[i]，返回至少需要多少次操作可以完成所有水缸蓄水要求。</p><p>注意：实际蓄水量 达到或超过 最低蓄水量，即完成蓄水要求。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：bucket = [1,3], vat = [6,8]</span><br><span class="line">&gt;输出：4</span><br><span class="line">&gt;解释：</span><br><span class="line">&gt;第 1 次操作升级 bucket[0]；</span><br><span class="line">&gt;第 2 ~ 4 次操作均选择蓄水，即可完成蓄水要求。</span><br></pre></td></tr></table></figure><p>题目详情参考：<a href="https://leetcode-cn.com/problems/o8SXZn/">LCP 33. 蓄水 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote></blockquote><p>思路：<strong>如果要升级水桶容量，那么就尽早升级，这一定是次数最少的情况。</strong></p><ol><li>题目数据规模不大，枚举出尽可能大的情况，得到最优解；</li><li><strong>（升级次数 + 初始蓄水量）× 倒水次数 = 容量</strong>；</li><li><strong>总次数 = 倒水次数 + 总升级次数</strong>；</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">storeWater</span><span class="params">(<span class="keyword">int</span>[] bucket, <span class="keyword">int</span>[] vat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">10001</span>;</span><br><span class="line">        <span class="comment">// 枚举倒水次数1-10000</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> pour = <span class="number">0</span>; pour &lt;= <span class="number">10000</span>; pour++) &#123; </span><br><span class="line">            <span class="keyword">if</span> (pour &gt;= ans) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">int</span> upgrade = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 枚举每个水桶，计算总升级次数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vat.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 贪心 先升级必定减少次数</span></span><br><span class="line">                <span class="comment">// （升级次数 + 初始蓄水量）* 倒水次数 = 容量</span></span><br><span class="line">                <span class="keyword">int</span> cur = (<span class="keyword">int</span>)Math.ceil((<span class="keyword">double</span>)vat[i] / pour - bucket[i]); </span><br><span class="line">                upgrade += cur &gt; <span class="number">0</span> ? cur : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (upgrade &gt;= ans) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 总次数 = 倒水次数 + 总升级次数</span></span><br><span class="line">            ans = Math.min(ans, upgrade + pour); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(10^4×n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 贪心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>螺旋矩阵</title>
      <link href="/2021/12/03/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
      <url>/2021/12/03/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="螺旋矩阵（数学）"><a href="#螺旋矩阵（数学）" class="headerlink" title="螺旋矩阵（数学）"></a>螺旋矩阵（数学）</h3><span id="more"></span><blockquote><blockquote><p>总结螺旋矩阵的三种问题：</p><ol><li>由外到内，如何构造螺旋矩阵</li><li>由内到位，如何输出螺旋矩阵</li><li>如何确定螺旋矩阵的位置元素</li></ol></blockquote></blockquote><h3 id="螺旋矩阵Ⅰ"><a href="#螺旋矩阵Ⅰ" class="headerlink" title="螺旋矩阵Ⅰ"></a>螺旋矩阵Ⅰ</h3><blockquote><blockquote><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><p>题目详情参考：<a href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote></blockquote><p>思路：模拟出 <code>顺时针螺旋顺序</code></p><ol><li>创建一个  <code>visited</code> 矩阵，用来判断是否被选取过；</li><li>创建方向数组 <code>dirs</code>，用来改变螺旋的方向；</li><li>创建变量 <code>currX</code>、<code>currY</code>，用来记录当前位置；</li><li><strong>当模拟遍历时，如果出界或者该位置已被遍历过，那么改变方向。</strong></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[row][col];</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> currX = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> currY = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> currDir = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (ans.size() != row * col) &#123;</span><br><span class="line">            <span class="keyword">if</span> (currX &gt;= <span class="number">0</span> &amp;&amp; currY &gt;= <span class="number">0</span> &amp;&amp; currX &lt; row </span><br><span class="line">                &amp;&amp; currY &lt; col &amp;&amp; !visited[currX][currY]) &#123;</span><br><span class="line">                ans.add(matrix[currX][currY]);</span><br><span class="line">                visited[currX][currY] = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                currX -= dirs[currDir][<span class="number">0</span>];</span><br><span class="line">                currY -= dirs[currDir][<span class="number">1</span>];</span><br><span class="line">                currDir++;</span><br><span class="line">                currDir %= <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            currX += dirs[currDir][<span class="number">0</span>];</span><br><span class="line">            currY += dirs[currDir][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(m×n)<br>&amp;空间复杂度:O(m×n)<br>\end{align}<br>$$</p><hr><h3 id="螺旋矩阵Ⅱ"><a href="#螺旋矩阵Ⅱ" class="headerlink" title="螺旋矩阵Ⅱ"></a>螺旋矩阵Ⅱ</h3><blockquote><blockquote><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n × n</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p>题目详情参考：<a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote></blockquote><p>思路：</p><ol><li><p>与螺旋矩阵Ⅰ的思路大体相似，不过是生成螺旋矩阵；</p></li><li><p>创建变量 <code>num</code> 填充并记录螺旋矩阵元素，遍历即可。</p></li></ol><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> currX = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> currY = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> currDir = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (num &lt;= n * n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (currX &gt;= <span class="number">0</span> &amp;&amp; currY &gt;= <span class="number">0</span> &amp;&amp; currX &lt; n </span><br><span class="line">                &amp;&amp; currY &lt; n &amp;&amp; !visited[currX][currY]) &#123;</span><br><span class="line">                ans[currX][currY] = num++;</span><br><span class="line">                visited[currX][currY] = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                currX -= dirs[currDir][<span class="number">0</span>];</span><br><span class="line">                currY -= dirs[currDir][<span class="number">1</span>];</span><br><span class="line">                currDir++;</span><br><span class="line">                currDir %= <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            currX += dirs[currDir][<span class="number">0</span>];</span><br><span class="line">            currY += dirs[currDir][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(m×n)<br>&amp;空间复杂度:O(m×n)<br>\end{align}<br>$$</p><hr><h3 id="螺旋矩阵Ⅲ"><a href="#螺旋矩阵Ⅲ" class="headerlink" title="螺旋矩阵Ⅲ"></a>螺旋矩阵Ⅲ</h3><blockquote><blockquote><p>在 R 行 C 列的矩阵上，我们从 (r0, c0) 面朝东面开始</p><p>这里，网格的西北角位于第一行第一列，网格的东南角位于最后一行最后一列。</p><p>现在，我们以顺时针按螺旋状行走，访问此网格中的每个位置。</p><p>每当我们移动到网格的边界之外时，我们会继续在网格之外行走（但稍后可能会返回到网格边界）。</p><p>最终，我们到过网格的所有 R * C 个空间。</p><p>按照访问顺序返回表示网格位置的坐标列表。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：R = 1, C = 4, r0 = 0, c0 = 0</span><br><span class="line">&gt;输出：[[0,0],[0,1],[0,2],[0,3]]</span><br></pre></td></tr></table></figure></blockquote></blockquote><p>思路：前面两个螺旋矩阵都是由外向内旋转，而此矩阵是由内向外旋转</p><ol><li>首先扩充该矩阵为 <code>n × n</code>  的方形矩阵，其中 <code>n</code> 为选中位置距离边界的最大距离；</li><li><strong>模拟遍历可知，最后的终点是拓展矩阵的右上角位置，那么可以反方向旋转求解；</strong></li><li>至此，已经转化为前两个问题，不过仍有需要注意的地方：<ol><li>起始位置和方向发生改变</li><li>需要记录拓展矩阵中哪些是需要记录的元素</li><li>如何确定原矩阵的位置</li></ol></li></ol><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] spiralMatrixIII(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> rStart, <span class="keyword">int</span> cStart) &#123;</span><br><span class="line">        <span class="keyword">int</span> nums = rows * cols;</span><br><span class="line">        <span class="keyword">boolean</span>[][] matrix = getExpendedMatrix(rows, cols, rStart, cStart);</span><br><span class="line">        <span class="keyword">int</span> sideLength = getSideLength(rows, cols, rStart, cStart);</span><br><span class="line">        <span class="keyword">return</span> getSipralOrder(matrix, nums, sideLength - rStart, sideLength - cStart);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][] getExpendedMatrix(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> rStart, <span class="keyword">int</span> cStart) &#123;</span><br><span class="line">        <span class="keyword">int</span> sideLength = getSideLength(rows, cols, rStart, cStart);</span><br><span class="line">        <span class="keyword">int</span> matrixSize = sideLength * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">boolean</span>[matrixSize][matrixSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = sideLength - rStart; i &lt; sideLength - rStart + rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = sideLength - cStart; j &lt; sideLength - cStart + cols; j++) &#123;</span><br><span class="line">                matrix[i][j] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSideLength</span><span class="params">(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> rStart, <span class="keyword">int</span> cStart)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxRow = Math.max(rStart, rows - <span class="number">1</span> - rStart);</span><br><span class="line">        <span class="keyword">int</span> maxCol = Math.max(cStart, cols - <span class="number">1</span> - cStart);</span><br><span class="line">        <span class="keyword">int</span> sideLength = Math.max(maxRow, maxCol);</span><br><span class="line">        <span class="keyword">return</span> sideLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] getSipralOrder(<span class="keyword">boolean</span>[][] matrix, <span class="keyword">int</span> nums, <span class="keyword">int</span> deltaX, <span class="keyword">int</span> deltaY) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = matrix.length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[size][size];</span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[nums][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> currX = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> currY = size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> currDir = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (index != nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (currX &gt;= <span class="number">0</span> &amp;&amp; currY &gt;= <span class="number">0</span> &amp;&amp; currX &lt; size </span><br><span class="line">                &amp;&amp; currY &lt; size &amp;&amp; !visited[currX][currY]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[currX][currY]) &#123;</span><br><span class="line">                    ans[nums - index - <span class="number">1</span>][<span class="number">0</span>] = currX - deltaX;</span><br><span class="line">                    ans[nums - index - <span class="number">1</span>][<span class="number">1</span>] = currY - deltaY;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">                visited[currX][currY] = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                currX -= dirs[currDir][<span class="number">0</span>];</span><br><span class="line">                currY -= dirs[currDir][<span class="number">1</span>];</span><br><span class="line">                currDir++;</span><br><span class="line">                currDir %= <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            currX += dirs[currDir][<span class="number">0</span>];</span><br><span class="line">            currY += dirs[currDir][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(m×n)<br>&amp;空间复杂度:O(m×n)<br>\end{align}<br>$$</p><hr><h3 id="螺旋矩阵Ⅳ"><a href="#螺旋矩阵Ⅳ" class="headerlink" title="螺旋矩阵Ⅳ"></a>螺旋矩阵Ⅳ</h3><blockquote><blockquote><p>给定一个 <code>n * n</code> 的矩阵，螺旋排列，如何确定某一位置的元素？</p><p>题目详情参考：<a href="https://leetcode-cn.com/problems/SNJvJP/">LCP 29. 乐团站位 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote></blockquote><p><img src="/2021/12/03/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E5%9B%BE.png" alt="示例图"></p><ol><li>将矩阵按圈的循环进行分割，再将圈，按照上述形式分割；</li><li>当前坐标为 <em>( xPos , yPos )</em>，首先获得该点所在的圈数，然后进行计算；</li><li>计算当前圈数前所有的点数，一个简单的等差数列求和；</li><li>分类讨论当前点所在圈的位置情况，计算总数，取余即为答案。</li></ol><p><strong>注意事项：</strong></p><ol><li>数据过大，将所有变量声明为 <code>long</code>；</li><li>结果取余时，为 <code>0</code> 时需要特殊考虑；</li><li>分类讨论时，不需要加上边界限制；</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">orchestraLayout</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> xPos, <span class="keyword">int</span> yPos)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 得到当前所在圈数 圈数从 0 开始</span></span><br><span class="line">        <span class="keyword">long</span> numOfTurns = Math.min(xPos, yPos);</span><br><span class="line">        numOfTurns = Math.min(num - <span class="number">1</span> - yPos, numOfTurns);</span><br><span class="line">        numOfTurns = Math.min(num - <span class="number">1</span> - xPos, numOfTurns);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算先前所有的点数和，以及当前圈的边长</span></span><br><span class="line">        <span class="keyword">long</span> preSum = (<span class="number">4</span> * (<span class="keyword">long</span>) num - <span class="number">4</span> * numOfTurns) * numOfTurns;</span><br><span class="line">        <span class="keyword">long</span> sideLength = num - <span class="number">2</span> * numOfTurns - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分类讨论得到目前点数和</span></span><br><span class="line">        <span class="keyword">long</span> currNum;</span><br><span class="line">        <span class="keyword">if</span> (xPos == numOfTurns) &#123;</span><br><span class="line">            currNum = preSum + yPos - numOfTurns + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (yPos == num - <span class="number">1</span> - numOfTurns) &#123;</span><br><span class="line">            currNum = preSum + sideLength + xPos - numOfTurns + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xPos == num - <span class="number">1</span> - numOfTurns) &#123;</span><br><span class="line">            currNum = preSum + sideLength * <span class="number">3</span> - yPos + numOfTurns + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            currNum = preSum + sideLength * <span class="number">4</span> - xPos + numOfTurns + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        currNum %= <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> currNum == <span class="number">0</span> ? <span class="number">9</span> : (<span class="keyword">int</span>) currNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(1)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大子数组和</title>
      <link href="/2021/12/01/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
      <url>/2021/12/01/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="最大子数组和（-动态规划-线段树-）"><a href="#最大子数组和（-动态规划-线段树-）" class="headerlink" title="最大子数组和（ 动态规划 | 线段树 ）"></a>最大子数组和（ 动态规划 | 线段树 ）</h3><span id="more"></span><blockquote><blockquote><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），</p><p>返回其最大和。<strong>子数组</strong> 是数组中的一个连续部分。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">&gt;输出：6</span><br><span class="line">&gt;解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="解法一：动态规划"><a href="#解法一：动态规划" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h3><p>假设数组长度为 <code>n</code> , 下标从 <em>0 ~ n - 1</em>,</p><p>不妨设 <em>f( i )</em> 表示以下标 <em>i</em> 结尾的连续子数组的最大和，那么所求答案即为：<br>$$<br>\max \limits_{0≤i≤n-1} \lbrace f(i) \rbrace<br>$$<br>那么可以得到转移方程：<br>$$<br>f(i) = max \lbrace f(i-1) + nums[i],nums[i] \rbrace<br>$$<br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> preSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            preSum = Math.max(preSum + nums[i], nums[i]);</span><br><span class="line">            ans = Math.max(preSum, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p><hr><h3 id="解法二：线段树"><a href="#解法二：线段树" class="headerlink" title="解法二：线段树"></a>解法二：线段树</h3><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(n)<br>&amp;空间复杂度:O(logn)<br>\end{align}<br>$$</p><hr><h3 id="变式：环形子数组最大和"><a href="#变式：环形子数组最大和" class="headerlink" title="变式：环形子数组最大和"></a>变式：环形子数组最大和</h3><p>题目详情参考：<a href="https://leetcode-cn.com/problems/maximum-sum-circular-subarray/">918. 环形子数组的最大和 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>思路：</p><ol><li>首先按照子数组最大和的方式得到最大值；</li><li>然后考虑环形数组的情况，即首尾一定被选取：<ol><li>正向得到最大数组和；</li><li>反向得到最大数组和；</li></ol></li><li><strong>但是不便于处理，因此求反面，按照子数组最大和的方式得到最小值；</strong></li><li>求最小值时，数组的范围谨慎处理。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubarraySumCircular</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> preSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ansMax = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            preSum = Math.max(preSum + nums[i], nums[i]);</span><br><span class="line">            ansMax = Math.max(preSum, ansMax);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ansMax;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        preSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ansMin = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            preSum = Math.min(preSum + nums[i], nums[i]);</span><br><span class="line">            ansMin = Math.min(preSum, ansMin);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Math.max(ansMax, sum - ansMin);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无限整数序列中定位数字</title>
      <link href="/2021/11/30/%E6%97%A0%E9%99%90%E6%95%B4%E6%95%B0%E5%BA%8F%E5%88%97%E4%B8%AD%E5%AE%9A%E4%BD%8D%E6%95%B0%E5%AD%97/"/>
      <url>/2021/11/30/%E6%97%A0%E9%99%90%E6%95%B4%E6%95%B0%E5%BA%8F%E5%88%97%E4%B8%AD%E5%AE%9A%E4%BD%8D%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h3 id="第-N-位数字（数学）"><a href="#第-N-位数字（数学）" class="headerlink" title="第 N 位数字（数学）"></a>第 N 位数字（数学）</h3><span id="more"></span><blockquote><blockquote><p>给你一个整数 <code>n</code> ，请你在无限的整数序列 <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...]</code> 中找出并返回第 <code>n</code> 位上的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">11</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="解法一：模拟查找"><a href="#解法一：模拟查找" class="headerlink" title="解法一：模拟查找"></a>解法一：模拟查找</h3><p>思路：将所有数字用字符串拼接，然后直接定位 <code>n</code> 返回当前下标的数字即可。</p><p>错误：因为 <code>n</code> 的取值范围是 <code>1 &lt;= n &lt;= 2^31 - 1</code>，会超出时间限制，无法解答，</p><p>​            实际上经过测试，当数据规模超过 10<sup>6</sup> 的规模时，就会超出时间限制。</p><hr><h3 id="解法二：数学定位"><a href="#解法二：数学定位" class="headerlink" title="解法二：数学定位"></a>解法二：数学定位</h3><p>思路：如果能够确定第 <code>n</code> 位上的数字，所在数字的位数，那么就可以进行定位求解。</p><ol><li><p><code>x</code> 位共计有 9 × 10<sup> x - 1</sup>个数字，共计有 <code>x</code> × 9 × 10<sup> x - 1</sup>位数字；</p></li><li><p>使用 <em>d</em> 和 <em>count</em> 分别表示当前遍历到的位数和当前位数下的所有整数的位数之和；</p></li><li><p>初始时 <code>d = 1</code>、<code>count = 9</code>，而后随之变化；</p></li><li><p>每次将 <em>n</em> 减去 <em>d×count</em>，然后将 <em>d</em> 加 <em>1</em>，将 <em>count</em> 乘 <em>10</em>，直到 <em>n ≤ d×count</em> ;</p></li><li><p>此时的 <code>d</code> 即为第 <code>n</code> 位上数字所在的数字位数，<em>n</em> 是所有 <em>d</em> 位数中从第一位到目标数字的位数；</p></li><li><p>使用目标数字在所有 <em>d</em> 位数中的下标进行计算，下标从 <em>0</em> 开始计数，</p><p>令  <em>index=n−1</em>，则 <em>index</em> 即为目标数字在所有 <em>d</em> 位数中的下标，<em>index</em> 的最小可能取值是 <em>0</em> ;</p></li><li><p>第 <em>n</em> 位数字是第 <em>m</em> 个 <em>d</em> 位数的第  <em>index mod d</em> 位，<strong>注意编号都从 <em>0</em> 开始</strong>;</p></li><li><p>由于最小的 <em>d</em> 位数是 <em>10<sup>d - 1</sup></em>，因此第 <em>n</em> 位数字所在的整数是 <em>10<sup>d - 1</sup> + m</em>，</p><p>该整数的右边第 <em>d − ( index mod d ) − 1</em> 位（计数从 <em>0</em> 开始）即为无限整数序列中的第 <em>n</em> 位。<br>$$<br>m = [\frac{index}{d}]<br>$$</p></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">1</span>, count = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; (<span class="keyword">long</span>) d * count) &#123;</span><br><span class="line">            n -= d * count;</span><br><span class="line">            d++;</span><br><span class="line">            count *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start = (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, d - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> num = start + index / d;</span><br><span class="line">        <span class="keyword">int</span> digitIndex = index % d;</span><br><span class="line">        <span class="keyword">int</span> digit = (num / (<span class="keyword">int</span>)(Math.pow(<span class="number">10</span>, d - digitIndex - <span class="number">1</span>))) % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> digit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(log_{10}n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p><hr><h3 id="解法三：二分优化"><a href="#解法三：二分优化" class="headerlink" title="解法三：二分优化"></a>解法三：二分优化</h3><p>思路：如果范围更广一些，可以对查找 <code>d</code> 的部分进行优化，采用二分查找。</p><p>结合解法二的从 <code>1</code> 开始遍历，当遍历到 <code>9</code> 时，即第九位个数时可知：<br>$$<br>9 × 9 × 10^8 = 8.1 × 10^9 ＞ 2^{31} - 1<br>$$<br>因此只需要在 <code>1 - 9</code> 之间进行二分查找即可。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">1</span>, high = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">if</span> (totalDigits(mid) &lt; n) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> d = low;</span><br><span class="line">        <span class="keyword">int</span> prevDigits = totalDigits(d - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> index = n - prevDigits - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start = (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, d - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> num = start + index / d;</span><br><span class="line">        <span class="keyword">int</span> digitIndex = index % d;</span><br><span class="line">        <span class="keyword">int</span> digit = (num / (<span class="keyword">int</span>) (Math.pow(<span class="number">10</span>, d - digitIndex - <span class="number">1</span>))) % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> digit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalDigits</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> digits = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curLength = <span class="number">1</span>, curCount = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">while</span> (curLength &lt;= length) &#123;</span><br><span class="line">            digits += curLength * curCount;</span><br><span class="line">            curLength++;</span><br><span class="line">            curCount *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(log_{10}n×loglog_{10}n)<br>&amp;空间复杂度:O(1)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Next的界面优化</title>
      <link href="/2021/11/29/Hexo%E7%9A%84%E7%95%8C%E9%9D%A2%E4%BC%98%E5%8C%96/"/>
      <url>/2021/11/29/Hexo%E7%9A%84%E7%95%8C%E9%9D%A2%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="Hexo-Next的界面优化"><a href="#Hexo-Next的界面优化" class="headerlink" title="Hexo Next的界面优化"></a>Hexo Next的界面优化</h3><span id="more"></span><h3 id="如何将页面背景改为黑色模式？"><a href="#如何将页面背景改为黑色模式？" class="headerlink" title="如何将页面背景改为黑色模式？"></a>如何将页面背景改为黑色模式？</h3><p>修改 Next 主题下的 _config.yml 配置文件：将 darkmode 的值修改为 true 。</p><p>如果主界面已经设置了 hexo-tag-cloud 标签云的展示，那么修改博客站点的配置文件，</p><p>_config.yml 中标签云模块下的 textColor 更改为 ‘#FFFFFF’ # 白色，或者其他颜色即可。</p><hr><h3 id="如何为页面添加当前浏览进度？"><a href="#如何为页面添加当前浏览进度？" class="headerlink" title="如何为页面添加当前浏览进度？"></a>如何为页面添加当前浏览进度？</h3><p>修改 Next 主题下的 _config.yml 配置文件：</p><p>将 back2top 中的 enable 和 scrollpercent 值修改为 true 。</p><hr><h3 id="如何将页面的首页更改为归档？"><a href="#如何将页面的首页更改为归档？" class="headerlink" title="如何将页面的首页更改为归档？"></a>如何将页面的首页更改为归档？</h3><p>修改 Next 主题下的 _config.yml 配置文件：</p><p>将 menu 下的 home 路径修改为 archive 即可，同时注释掉 archive。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: <span class="regexp">/archives/</span> || fa fa-archive</span><br><span class="line">  <span class="attr">about</span>: <span class="regexp">/about/</span> || fa fa-user</span><br><span class="line">  <span class="attr">tags</span>: <span class="regexp">/tags/</span> || fa fa-tags</span><br><span class="line">  <span class="attr">categories</span>: <span class="regexp">/categories/</span> || fa fa-th</span><br><span class="line">  #archives: <span class="regexp">/archives/</span> || fa fa-archive</span><br><span class="line">  #schedule: <span class="regexp">/schedule/</span> || fa fa-calendar</span><br><span class="line">  #sitemap: /sitemap.xml || fa fa-sitemap</span><br><span class="line">  #commonweal: <span class="regexp">/404/</span> || fa fa-heartbeat</span><br></pre></td></tr></table></figure><p><em>（提醒：如果担心更改错误，备份原文件）</em></p><hr><h3 id="如何为页面添加加载特效？"><a href="#如何为页面添加加载特效？" class="headerlink" title="如何为页面添加加载特效？"></a>如何为页面添加加载特效？</h3><p>参考文章：<a><a href="https://juejin.cn/post/6844903789946896398">Hexo博客NexT主题美化之顶部加载进度条 - 掘金 (juejin.cn)</a></a></p><hr><h3 id="如何修改主题的段距？"><a href="#如何修改主题的段距？" class="headerlink" title="如何修改主题的段距？"></a>如何修改主题的段距？</h3><p>回答在官方仓库的 Issue，链接：<a href="https://github.com/theme-next/hexo-theme-next/issues/1703">https://github.com/theme-next/hexo-theme-next/issues/1703</a></p><hr><h3 id="如何美化分类页面？"><a href="#如何美化分类页面？" class="headerlink" title="如何美化分类页面？"></a>如何美化分类页面？</h3><p>参考这两篇博客：</p><p><a href="https://jrbcode.gitee.io/posts/be9758cd.html">Hexo+NexT博客归档/标签/分类页美化 | CodeHeap (gitee.io)</a></p><p><a href="https://www.cnblogs.com/cscshi/p/15196122.html">Hexo-NexT 分类多层级描述 - 锦瑟，无端 - 博客园 (cnblogs.com)</a></p><p>前者是添加一些 CSS 样式以及美化，而后者是增强分类的观感。</p><hr><h3 id="如何把文章间的距离缩小？"><a href="#如何把文章间的距离缩小？" class="headerlink" title="如何把文章间的距离缩小？"></a>如何把文章间的距离缩小？</h3><p>参考 Issue：<a href="https://github.com/iissnan/hexo-theme-next/issues/591">https://github.com/iissnan/hexo-theme-next/issues/591</a></p><hr><h3 id="如何修改文章链接样式？"><a href="#如何修改文章链接样式？" class="headerlink" title="如何修改文章链接样式？"></a>如何修改文章链接样式？</h3><p>修改 <code>themes\next\source\css\_common\components\post.styl</code> 文件，添加如下 CSS 样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 文章内链接文本样式</span><br><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#8CC7B5</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#8CC7B5</span>;</span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fc6423</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: none;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#fc6423</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>color</code> 部分可以根据个人喜好更改。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本概念</title>
      <link href="/2021/11/29/Java%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2021/11/29/Java%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><span id="more"></span><h3 id="Java语言有哪些优点？"><a href="#Java语言有哪些优点？" class="headerlink" title="Java语言有哪些优点？"></a>Java语言有哪些优点？</h3><ol><li><p>Java为纯面向对象的语言</p></li><li><p>平台无关性</p></li><li><p>Java提供了很多内置的类库</p></li><li><p>提供了对Web应用开发的支持</p></li><li><p>具有较好的安全性和健壮性</p></li><li><p>去除了C++语言中难以理解、容易混淆的特性</p><p><strong>说明：Java语言是由C++语言改进并重新设计而来的</strong></p></li></ol><hr><h3 id="Java与C、C-有什么异同"><a href="#Java与C、C-有什么异同" class="headerlink" title="Java与C、C++有什么异同"></a>Java与C、C++有什么异同</h3><ol><li><p><strong>Java为半编译半解释型语言，而C / C++为编译型语言</strong></p><ul><li>Java程序源代码先经过Java编译器编译成字节码，然后由JVM解释执行</li><li>C / C++程序源代码经过编译和链接后生成可执行的二进制代码</li></ul><p>因此C / C++的执行速度比Java快，但是Java因为JVM可以跨平台执行。</p></li><li><p><strong>Java为纯面向对象的语言，而C++兼具面向过程和面向对象的特点</strong></p><ul><li>Java中除了基本数据类型，所有类型都是类</li><li>Java语言中不存在全局变量或者全局函数</li></ul></li><li><p><strong>Java没有多重继承，但是可以实现多个接口</strong></p></li><li><p><strong>Java语言提供了垃圾回收器来实现垃圾的自动回收</strong></p><ul><li>C++语言中，需要开发人员去管理对内存的分配（申请与释放）</li><li>Java的GC机制，不需要开发人员去关心内存空间</li></ul></li><li><p><strong>Java具有平台无关性</strong></p><ul><li>Java中每种基本类型数据都分配固定长度</li><li>C / C++中在不同的平台会分配不同的字节数</li></ul></li><li><p><strong>其他不同的地方</strong></p><ol><li>Java不支持运算符重载</li><li>Java没有预处理器，但是提供 import 机制</li><li>Java不支持默认函数参数</li><li>Java不提供 goto 语句，但是做为保留关键字</li><li>Java不提供自动强制类型转化，需要显示转换</li><li>Java不包含结构和联合，所有内容封装在类里面</li><li>Java没有指针的概念，避免指针引起的系统问题</li><li>Java提供了一些标准库，用于完成特定的任务，比如 JDBC</li></ol></li></ol><p><strong>常见的一个错误说法：Java语言中的方法属于类的成员</strong></p><p>静态方法：类成员</p><p>非静态方法：实例成员</p><hr><h3 id="为什么需要-main-方法"><a href="#为什么需要-main-方法" class="headerlink" title="为什么需要 main 方法"></a>为什么需要 main 方法</h3><p><code>public static void main(String args[]) &#123;&#125;</code></p><ol><li><p>该方法为Java程序的入口方法，JVM在运行程序时，会首先查找 main() 方法</p></li><li><p>字符串数组 args 为开发人员在命令行状态下与程序交互提供了一种手段</p></li><li><p>因为 main() 方法是程序的入口，要执行一个类的方法，就必须实例化一个对象，</p><p>此时还没有实例化对象，所以该方法需要被定义成 public 和 static </p></li><li><p>main() 方法其他可用的定义格式：</p><p><em><strong>说明：public 和 static 的位置可以互换，没有先后关系</strong></em></p><ol><li><code>static public void main(String args[]) &#123;&#125;</code></li><li><code>public static final void main(String args[]) &#123;&#125;</code></li><li><code>public static synchronized void main(String args[]) &#123;&#125;</code></li></ol><p><strong>但是不可以用 abstract 关键字修饰，因为该函数为程序的入口方法</strong></p></li></ol><hr><h3 id="一个Java文件中是否可以定义多个类"><a href="#一个Java文件中是否可以定义多个类" class="headerlink" title="一个Java文件中是否可以定义多个类"></a>一个Java文件中是否可以定义多个类</h3><ol><li>可以定义多个类，但是<strong>最多只能有一个被 public 修饰的类</strong>，并且该类与文件名相同</li><li>如果没有 public 类，那么文件名随便一个类的名字即可</li><li>当编译此文件时，每一个类都会生成一个对应的字节码文件 .class</li><li><strong>普通方法可以与构造函数有相同的方法名</strong></li></ol><hr><h3 id="Java程序初始化的顺序"><a href="#Java程序初始化的顺序" class="headerlink" title="Java程序初始化的顺序"></a>Java程序初始化的顺序</h3><p>在Java语言中，当实例化对象时，对象所在类的所有成员变量首先要进行初始化，</p><p>只有当所有类成员完成初始化后，才会调用对象所在类的构造函数创建对象。</p><p><strong>程序初始化一般遵循三个原则（优先级依次递减）：</strong></p><ol><li>静态对象（变量）优先于非静态</li><li>父类优先于子类</li><li>按照成员变量的定义顺序进行初始化</li></ol><p><strong>具体的执行顺序如下：</strong></p><p>父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、</p><p>父类非静态变量、父类非静态代码块、父类构造函数、</p><p>子类非静态变量、子类非静态代码块、子类构造函数。</p><p><strong>示例代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Load B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Create B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Load B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Load A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Create A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>程序运行结果是：</strong>Load B    Load B    Load A    Create B    Create A</p><hr><h3 id="Java中的作用域"><a href="#Java中的作用域" class="headerlink" title="Java中的作用域"></a>Java中的作用域</h3><table><thead><tr><th align="center">作用域与可见性</th><th align="center">当前类</th><th align="center">同一package</th><th align="center">子类</th><th align="center">其他package</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">protected</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">default</td><td align="center">√</td><td align="center">√</td><td align="center">×</td><td align="center">×</td></tr><tr><td align="center">private</td><td align="center">√</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><p>注意：private 和 protected 不能用来修饰类</p><hr><h3 id="Java中的标识接口"><a href="#Java中的标识接口" class="headerlink" title="Java中的标识接口"></a>Java中的标识接口</h3><p>标识接口：没有任何方法声明的接口</p><p>作用：仅仅充当一个标识作用，用来表明实现它的类属于一个特定的类型</p><hr><h3 id="Java中的clone方法"><a href="#Java中的clone方法" class="headerlink" title="Java中的clone方法"></a>Java中的clone方法</h3><p>实际编程中，需要从某个已有的对象 A 创建处另外一个与 A 具有相同状态的对象 B，</p><p>并且对 B 的修改不会影响到 A 的自身状态，因此提供了 clone 方法返回一个新的对象。</p><p><strong>使用clone方法的步骤：</strong></p><ol><li>实现clone的类首先需要继承 Cloneable 接口</li><li>在类中重写 Object 类中的 clone() 方法</li><li>在 clone() 方法章调用 super.clone() <strong>（浅复制）</strong></li><li>对对象中的非基本类型的属性也调用 clone() 方法 <strong>（深复制）</strong></li><li>把复制的引用指向原型对象新的克隆体</li></ol><p><strong>示例代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date birth = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getBirth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birth.setMonth(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Obj o = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 实现浅复制</span></span><br><span class="line">            o = (Obj) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现深复制</span></span><br><span class="line">        o.birth = (Date) <span class="keyword">this</span>.getBirth().clone();</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Obj a = <span class="keyword">new</span> Obj();</span><br><span class="line">        Obj b = (Obj)a.clone();</span><br><span class="line">        b.changeDate();</span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span> + a.getBirth());</span><br><span class="line">        System.out.println(<span class="string">&quot;b = &quot;</span> + b.getBirth());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>程序运行结果是：</strong></p><p>a = Mon Nov 29 19:05:03 CST 2021<br>b = Sat May 29 19:05:03 CST 2021</p><hr><h3 id="Java创建对象的四种方式"><a href="#Java创建对象的四种方式" class="headerlink" title="Java创建对象的四种方式"></a>Java创建对象的四种方式</h3><ol><li>通过 new 语句实例化一个对象</li><li>通过反射机制创建对象</li><li>通过 clone() 方法创建一个对象</li><li>通过反序列化的方式船舰一个对象</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Next的基础搭建</title>
      <link href="/2021/11/27/Hexo%E7%9A%84%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/"/>
      <url>/2021/11/27/Hexo%E7%9A%84%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="Hexo-Next的基础搭建"><a href="#Hexo-Next的基础搭建" class="headerlink" title="Hexo Next的基础搭建"></a>Hexo Next的基础搭建</h3><span id="more"></span><h3 id="如何通过GitHub搭建Hexo博客？"><a href="#如何通过GitHub搭建Hexo博客？" class="headerlink" title="如何通过GitHub搭建Hexo博客？"></a>如何通过GitHub搭建Hexo博客？</h3><p>推荐UP主 CodeSheep 的这期视频：<a><a href="https://www.bilibili.com/video/BV1Yb411a7ty?from=search&seid=12143109252670934815&spm_id_from=333.337.0.0">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo_哔哩哔哩_bilibili</a></a></p><p><em>（讲的很详细，并且其他视频对于初学者都很有帮助）</em></p><p><strong>补充：这里如果windows下的cmd操作不适配，推荐下载使用Git，仿照视频操作。</strong></p><hr><h3 id="如何添加-分类-标签-模块？"><a href="#如何添加-分类-标签-模块？" class="headerlink" title="如何添加 分类 | 标签 模块？"></a>如何添加 分类 | 标签 模块？</h3><p>推荐文章：<a><a href="https://juejin.cn/post/6921750181297782798">Hexo添加分类及标签（在Next主题下） - 掘金 (juejin.cn)</a></a></p><p><strong>补充：文章只能属于一个分类，但是可以属于多个标签。</strong></p><hr><h3 id="如何在文章内部署图片？"><a href="#如何在文章内部署图片？" class="headerlink" title="如何在文章内部署图片？"></a>如何在文章内部署图片？</h3><p>推荐文章：<a><a href="https://www.jianshu.com/p/f72aaad7b852">HEXO插入图片（详细版） - 简书 (jianshu.com)</a></a></p><p><strong>补充：</strong></p><ol><li><p>此方法插入图片时，typora或者其他markdown软件中，不可见图片，但是网页部署会出现，</p><p>这里推荐文章：<a>hexo博客如何插入图片 - 知乎 (zhihu.com)](<a href="https://zhuanlan.zhihu.com/p/265077468">https://zhuanlan.zhihu.com/p/265077468</a>)</a>的第三点说明。</p></li><li><p>在执行npm的时候可能会报错，参考下面文章依据情况解决：</p><p><a><a href="https://blog.csdn.net/zzq00zzj/article/details/120826520?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link">(13条消息) npm install报错 npm ERR! 的四种解决办法_zzq00zzj的博客-CSDN博客</a></a></p></li></ol><hr><h3 id="如何添加访客统计和文章阅读次数？"><a href="#如何添加访客统计和文章阅读次数？" class="headerlink" title="如何添加访客统计和文章阅读次数？"></a>如何添加访客统计和文章阅读次数？</h3><p>推荐文章：<a><a href="https://blog.csdn.net/baidu_34310405/article/details/102665373">(13条消息) Hexo Next主题添加访客统计、访问次数统计、文章阅读次数统计_AcLings的博客-CSDN博客</a></a></p><hr><h3 id="如何美化代码块以-Mac-Pane的风格？"><a href="#如何美化代码块以-Mac-Pane的风格？" class="headerlink" title="如何美化代码块以 Mac Pane的风格？"></a>如何美化代码块以 Mac Pane的风格？</h3><p>推荐文章：<a><a href="https://miaosakurai.com/2020/04/20/Hexo-NexT%E7%BE%8E%E5%8C%96%F0%9F%8D%95Mac-Panel%E9%A3%8E%E6%A0%BC%E4%BB%A3%E7%A0%81%E5%9D%97%E9%85%8D%E7%BD%AE/">Hexo+NexT美化🍕Mac Panel风格代码块配置 | 樱井喵 (miaosakurai.com)</a></a></p><hr><h3 id="如何添加-标签云模块-博客背景-搜索功能-模块？"><a href="#如何添加-标签云模块-博客背景-搜索功能-模块？" class="headerlink" title="如何添加 标签云模块 |博客背景 |搜索功能 模块？"></a>如何添加 标签云模块 |博客背景 |搜索功能 模块？</h3><p>推荐博主：<a><a href="https://vic.kim/">归档 | Vicの博客</a></a></p><p><strong>补充：标签云至少存在两个标签才会生效显示</strong></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>祖玛游戏</title>
      <link href="/2021/11/25/%E7%A5%96%E7%8E%9B%E6%B8%B8%E6%88%8F/"/>
      <url>/2021/11/25/%E7%A5%96%E7%8E%9B%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="祖玛游戏（-搜索剪枝-记忆化搜索）"><a href="#祖玛游戏（-搜索剪枝-记忆化搜索）" class="headerlink" title="祖玛游戏（ 搜索剪枝 | 记忆化搜索）"></a>祖玛游戏（ 搜索剪枝 | 记忆化搜索）</h3><span id="more"></span><blockquote><blockquote><p>祖玛游戏的最小步数求解</p><p>题目详情参见：<a><a href="https://leetcode-cn.com/problems/zuma-game/">488. 祖玛游戏 - 力扣（LeetCode） (leetcode-cn.com)</a></a></p></blockquote></blockquote><h3 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h3><ol><li><p>因为插入球的选择和颜色情况太多，并且所带来的影响可能是在多次操作后才能体现出来，</p><p>因此倘若使用贪心算法，很难建立起全局最优的决策，故而不采用贪心；</p></li><li><p>因此需要对状态空间进行枚举，通过穷尽所有的可能来找到最优解，</p><p>并使用剪枝的方法来优化搜索过程；</p></li><li><p>如果使用深度优先搜索，则需要使用记忆化搜索，以避免重复计算相同的状态；</p></li><li><p>该题目只需要得到回合数最少的方案，因此广度优先搜索即可;</p></li><li><p>设当前桌面上有 n 个球，手中持有 m 个球，<br>  $$<br>  则此时一共有C^m_{m+n} * m! = A^m_{m+n}种插入方法<br>  $$</p></li></ol><h3 id="解法一：BFS-剪枝"><a href="#解法一：BFS-剪枝" class="headerlink" title="解法一：BFS + 剪枝"></a>解法一：BFS + 剪枝</h3><p>思路：不妨规定，每一种不同的桌面上球的情况和手中球的情况的组合都是一种不同的状态，</p><p>​            然后对状态空间进行枚举，即可得解答；</p><p><strong>在搜索过程中，需要剪枝来简化算法的复杂性:</strong></p><ul><li>手中颜色相同的球每次选择时只需要考虑其中一个即可；</li><li>只在连续相同颜色的球的开头位置或者结尾位置插入新的颜色相同的球；</li><li>只考虑放置新球后有可能得到更优解的位置，以下三种情况：<ol><li>插入新球与插入位置右侧的球颜色相同</li><li>插入新球与插入位置两侧的球颜色均不相同，且插入位置两侧的球的颜色不同</li><li>插入新球与插入位置两侧的球颜色均不相同，且插入位置两侧的球的颜色相同</li><li>对于如果手中的球全部插入也无法满足新的消除，则直接进行中止</li></ol></li></ul><p><strong>当然还可以有更多的剪枝技巧。</strong></p><p>具体实现的细节处理：</p><ol><li><p>消除操作后，如果导致出现了新的连续三个以上颜色相同的球，</p><p>则继续消除这些球，直到不再满足消除条件；</p></li><li><p>消除时利用栈的特性，每次遇到连续可以消除的球时，将其从栈中弹出；</p></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinStep</span><span class="params">(String board, String hand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] arr = hand.toCharArray();</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        hand = <span class="keyword">new</span> String(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化用队列维护的状态队列：其中的三个元素分别为桌面球状态、手中球状态和回合数</span></span><br><span class="line">        Queue&lt;State&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;State&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> State(board, hand, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化用哈希集合维护的已访问过的状态</span></span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        visited.add(board + <span class="string">&quot; &quot;</span> + hand);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            State state = queue.poll();</span><br><span class="line">            String curBoard = state.board;</span><br><span class="line">            String curHand = state.hand;</span><br><span class="line">            <span class="keyword">int</span> step = state.step;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= curBoard.length(); ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; curHand.length(); ++j) &#123;</span><br><span class="line">                    <span class="comment">// 第 1 个剪枝条件: 当前球的颜色和上一个球的颜色相同</span></span><br><span class="line">                    <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; curHand.charAt(j) == curHand.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 第 2 个剪枝条件: 只在连续相同颜色的球的开头位置插入新球</span></span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; curBoard.charAt(i - <span class="number">1</span>) == curHand.charAt(j)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 第 3 个剪枝条件: 只在以下两种情况放置新球</span></span><br><span class="line">                    <span class="keyword">boolean</span> choose = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">//  - 第 1 种情况 : 当前球颜色与后面的球的颜色相同</span></span><br><span class="line">                    <span class="keyword">if</span> (i &lt; curBoard.length() &amp;&amp; curBoard.charAt(i) == curHand.charAt(j)) &#123;</span><br><span class="line">                        choose = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//  - 第 2 种情况 : 当前后颜色相同且与当前颜色不同时候放置球</span></span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; i &lt; curBoard.length() &amp;&amp; </span><br><span class="line">                        curBoard.charAt(i - <span class="number">1</span>) == curBoard.charAt(i) &amp;&amp; </span><br><span class="line">                        curBoard.charAt(i - <span class="number">1</span>) != curHand.charAt(j)) &#123;</span><br><span class="line">                        choose = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (choose) &#123;</span><br><span class="line">                        String newBoard = clean(curBoard.substring(<span class="number">0</span>, i) + </span><br><span class="line">                                                curHand.charAt(j) + curBoard.substring(i));</span><br><span class="line">                        String newHand = curHand.substring(<span class="number">0</span>, j) + curHand.substring(j + <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">if</span> (newBoard.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        String str = newBoard + <span class="string">&quot; &quot;</span> + newHand;</span><br><span class="line">                        <span class="keyword">if</span> (visited.add(str)) &#123;</span><br><span class="line">                            queue.offer(<span class="keyword">new</span> State(newBoard, newHand, step + <span class="number">1</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">clean</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        Deque&lt;Character&gt; letterStack = <span class="keyword">new</span> ArrayDeque&lt;Character&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; countStack = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">while</span> (!letterStack.isEmpty() &amp;&amp; c != letterStack.peek() &amp;&amp; countStack.peek() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                letterStack.pop();</span><br><span class="line">                countStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (letterStack.isEmpty() || c != letterStack.peek()) &#123;</span><br><span class="line">                letterStack.push(c);</span><br><span class="line">                countStack.push(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                countStack.push(countStack.pop() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!countStack.isEmpty() &amp;&amp; countStack.peek() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">            letterStack.pop();</span><br><span class="line">            countStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!letterStack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">char</span> letter = letterStack.pop();</span><br><span class="line">            <span class="keyword">int</span> count = countStack.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">                sb.append(letter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.reverse();</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    String board;</span><br><span class="line">    String hand;</span><br><span class="line">    <span class="keyword">int</span> step;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">State</span><span class="params">(String board, String hand, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.board = board;</span><br><span class="line">        <span class="keyword">this</span>.hand = hand;</span><br><span class="line">        <span class="keyword">this</span>.step = step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(m×n×A^n_{m+n})\<br>&amp;空间复杂度:O((m+n)×A^m_{m+n})<br>\end{align}<br>$$</p><hr><h3 id="解法二：记忆化搜索（AStar算法）"><a href="#解法二：记忆化搜索（AStar算法）" class="headerlink" title="解法二：记忆化搜索（AStar算法）"></a>解法二：记忆化搜索（AStar算法）</h3><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Integer&gt; dp = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinStep</span><span class="params">(String board, String hand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] arr = hand.toCharArray();</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        hand = <span class="keyword">new</span> String(arr);</span><br><span class="line">        <span class="keyword">int</span> ans = dfs(board, hand);</span><br><span class="line">        <span class="keyword">return</span> ans &lt;= <span class="number">5</span> ? ans : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(String board, String hand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String key = board + <span class="string">&quot; &quot;</span> + hand;</span><br><span class="line">        <span class="keyword">if</span> (!dp.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">6</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; hand.length(); ++j) &#123;</span><br><span class="line">                <span class="comment">// 第 1 个剪枝条件: 当前球的颜色和上一个球的颜色相同</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; hand.charAt(j) == hand.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= board.length(); ++i) &#123;</span><br><span class="line">                    <span class="comment">// 第 2 个剪枝条件: 只在连续相同颜色的球的开头位置插入新球</span></span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; board.charAt(i - <span class="number">1</span>) == hand.charAt(j)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 第 3 个剪枝条件: 只在以下两种情况放置新球</span></span><br><span class="line">                    <span class="keyword">boolean</span> choose = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">//  - 第 1 种情况 : 当前球颜色与后面的球的颜色相同</span></span><br><span class="line">                    <span class="keyword">if</span> (i &lt; board.length() &amp;&amp; board.charAt(i) == hand.charAt(j)) &#123;</span><br><span class="line">                        choose = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//  - 第 2 种情况 : 当前后颜色相同且与当前颜色不同时候放置球</span></span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; i &lt; board.length() &amp;&amp; </span><br><span class="line">                        board.charAt(i - <span class="number">1</span>) == board.charAt(i) &amp;&amp; </span><br><span class="line">                        board.charAt(i - <span class="number">1</span>) != hand.charAt(j)) &#123;</span><br><span class="line">                        choose = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (choose) &#123;</span><br><span class="line">                        String newBoard = clean(board.substring(<span class="number">0</span>, i) + </span><br><span class="line">                                                hand.charAt(j) + board.substring(i));</span><br><span class="line">                        String newHand = hand.substring(<span class="number">0</span>, j) + hand.substring(j + <span class="number">1</span>);</span><br><span class="line">                        res = Math.min(res, dfs(newBoard, newHand) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp.put(key, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">clean</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        Deque&lt;Character&gt; letterStack = <span class="keyword">new</span> ArrayDeque&lt;Character&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; countStack = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">while</span> (!letterStack.isEmpty() &amp;&amp; c != letterStack.peek() &amp;&amp; countStack.peek() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                letterStack.pop();</span><br><span class="line">                countStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (letterStack.isEmpty() || c != letterStack.peek()) &#123;</span><br><span class="line">                letterStack.push(c);</span><br><span class="line">                countStack.push(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                countStack.push(countStack.pop() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!countStack.isEmpty() &amp;&amp; countStack.peek() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">            letterStack.pop();</span><br><span class="line">            countStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!letterStack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">char</span> letter = letterStack.pop();</span><br><span class="line">            <span class="keyword">int</span> count = countStack.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">                sb.append(letter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.reverse();</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    String board;</span><br><span class="line">    String hand;</span><br><span class="line">    <span class="keyword">int</span> step;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">State</span><span class="params">(String board, String hand, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.board = board;</span><br><span class="line">        <span class="keyword">this</span>.hand = hand;</span><br><span class="line">        <span class="keyword">this</span>.step = step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(m×n×A^n_{m+n})\<br>&amp;空间复杂度:O((m+n)×A^m_{m+n})<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 广度优先搜索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维 接雨水</title>
      <link href="/2021/11/25/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E2%85%A1/"/>
      <url>/2021/11/25/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E2%85%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="二维-接雨水（-最小堆-广度优先搜索-）"><a href="#二维-接雨水（-最小堆-广度优先搜索-）" class="headerlink" title="二维 接雨水（ 最小堆 | 广度优先搜索 ）"></a>二维 接雨水（ 最小堆 | 广度优先搜索 ）</h3><span id="more"></span><blockquote><blockquote><p>给你一个 <code>m x n</code> 的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: heightMap = <span class="string">[[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]</span></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure><p>题目详情参见: <a><a href="https://leetcode-cn.com/problems/trapping-rain-water-ii/">407. 接雨水 II - 力扣（LeetCode） (leetcode-cn.com)</a></a></p></blockquote></blockquote><h3 id="解法一：模拟遍历（参照接雨水Ⅰ）"><a href="#解法一：模拟遍历（参照接雨水Ⅰ）" class="headerlink" title="解法一：模拟遍历（参照接雨水Ⅰ）"></a>解法一：模拟遍历（参照接雨水Ⅰ）</h3><p>思路：一维转化为二维，那么是否可以同样的思路去解答？</p><ol><li>对于每个点，寻找所在行左右最大值的最小值，寻找所在列上下最大值的最小值；</li><li>然后取这两个值的最小值，减去当前位置的高度，即为此位置接雨水量。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trapRainWater</span><span class="params">(<span class="keyword">int</span>[][] heightMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = heightMap.length;</span><br><span class="line">        <span class="keyword">int</span> col = heightMap[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> curr = heightMap[i][j];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> minRow = getMinRow(heightMap,i,j,col);</span><br><span class="line">                <span class="keyword">int</span> minCol = getMinCol(heightMap,i,j,row);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果均大于当前位置，那么可以接雨水</span></span><br><span class="line">                <span class="keyword">if</span>(minCol &gt; curr &amp;&amp; minRow &gt; curr) &#123;</span><br><span class="line">                    ans += Math.min(minRow,minCol);</span><br><span class="line">                    ans -= heightMap[i][j];</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找所在行的左右最大值的最小值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMinRow</span><span class="params">(<span class="keyword">int</span>[][] heightMap,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftMax = heightMap[x][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> rightMax = heightMap[x][col - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; y; k++) &#123;</span><br><span class="line">            leftMax = Math.max(leftMax,heightMap[x][k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = y; k &lt; col; k++) &#123;</span><br><span class="line">            rightMax = Math.max(rightMax,heightMap[x][k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(leftMax,rightMax);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找所在列的上下最大值的最小值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMinCol</span><span class="params">(<span class="keyword">int</span>[][] heightMap,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> upMax = heightMap[<span class="number">0</span>][y];</span><br><span class="line">        <span class="keyword">int</span> downMax = heightMap[row - <span class="number">1</span>][y];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; x; k++) &#123;</span><br><span class="line">            upMax = Math.max(upMax,heightMap[k][y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = x; k &lt; row; k++) &#123;</span><br><span class="line">             downMax = Math.max(downMax,heightMap[k][y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(upMax,downMax);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个思路解答是错误的，因为当前位置可能会溢出流向其他区域！</p><p>比如：<code>[[12,13,1,12],[13,4,13,12],[13,8,10,12],[12,13,12,12],[13,13,13,13]]</code></p><p>按照上述做法的答案<code>15</code>，正确答案<code>14</code>。</p><p><strong>因此该方块自身的高度比其上下左右四个相邻的方块接水后的高度都要低。</strong></p><hr><h3 id="解法二：最小堆"><a href="#解法二：最小堆" class="headerlink" title="解法二：最小堆"></a>解法二：最小堆</h3><p>思路：反思解法一的过程，思考总结什么样的方块能接水?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 该方块不为最外层的方块；</span><br><span class="line">- 该方块自身的高度比其上下左右四个相邻的方块接水后的高度都要低；</span><br></pre></td></tr></table></figure><ol><li><p>假设方块的索引为 <em>(i,j)</em>，方块的高度为 <em>heightMap[i][j]</em>，方块接水后的高度为 <em>water[i][j]</em>；</p></li><li><p>并且 <em>water[i][j] = max(heightMap[i][j], min(water[i−1][j], water[i+1][j], water[i][j−1], water[i][j+1]))</em>；</p></li><li><p>因此方块 <em>(i,j)</em> 实际接水的容量计算公式为 <em>water[i][j] − heightMap[i][j]</em>;</p></li><li><p>因为最外层的方块无法接水，因此最外层的方块 <em>water[i][j] = heightMap[i][j]</em>;</p></li><li><p>根据木桶原理，接到的雨水的高度由这个容器周围最短的木板来确定的,</p><p>因此容器内水的高度取决于最外层高度最低的方块；</p></li><li><p>确定最小高度方块的相邻方块的接水高度，我们同时更新最外层的方块标记，</p><p>在新的最外层的方块再次找到接水后的高度的最小值，同时确定与其相邻的方块的接水高度；</p></li><li><p>依次迭代求出所有方块的接水，即可得解。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trapRainWater</span><span class="params">(<span class="keyword">int</span>[][] heightMap)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方块数小于4，无法接水</span></span><br><span class="line">        <span class="keyword">if</span> (heightMap.length &lt;= <span class="number">2</span> || heightMap[<span class="number">0</span>].length &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = heightMap.length;</span><br><span class="line">        <span class="keyword">int</span> n = heightMap[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 访问过的结点</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] visit = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o1[<span class="number">1</span>] - o2[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || i == m - <span class="number">1</span> || j == <span class="number">0</span> || j == n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// i * n + j代表第几个</span></span><br><span class="line">                    pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i * n + j, heightMap[i][j]&#125;);</span><br><span class="line">                    visit[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dirs = &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] curr = pq.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                <span class="comment">// 第几个取位置，/n是行数，%n是列数</span></span><br><span class="line">                <span class="keyword">int</span> nx = curr[<span class="number">0</span>] / n + dirs[k];</span><br><span class="line">                <span class="keyword">int</span> ny = curr[<span class="number">0</span>] % n + dirs[k + <span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 不越界并且没有被访问过</span></span><br><span class="line">                <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; n &amp;&amp; !visit[nx][ny]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (curr[<span class="number">1</span>] &gt; heightMap[nx][ny]) &#123;</span><br><span class="line">                        res += curr[<span class="number">1</span>] - heightMap[nx][ny];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 更新边界</span></span><br><span class="line">                    pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nx * n + ny, Math.max(heightMap[nx][ny], curr[<span class="number">1</span>])&#125;);</span><br><span class="line">                    <span class="comment">// 将访问过的位置设置为true</span></span><br><span class="line">                    visit[nx][ny] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(MNlog(M+N))\<br>&amp;空间复杂度:O(MN)<br>\end{align}<br>$$</p><hr><h3 id="解法三：广度优先搜索"><a href="#解法三：广度优先搜索" class="headerlink" title="解法三：广度优先搜索"></a>解法三：广度优先搜索</h3><p>思路:    让区域都接满水，因此此时每一块的高度都是 <code>maxHeight</code>，为区域中最高值，</p><p>​             然后让其顺着低处自然流出，因此需要广度优先搜索；</p><ol><li><p>假设初始时矩阵的每个格子都接满了水，且高度均为 <em>maxHeight</em>，区域中的最高值；</p></li><li><p>同解法二：<em>water[i][j] = max(heightMap[i][j], min(water[i−1][j], water[i+1][j], water[i][j−1], water[i][j+1]))</em>；</p></li><li><p>方块 <em>(i,j)</em> 实际接水的容量计算公式为 <em>water[i][j] − heightMap[i][j]</em>;</p></li><li><p>每次发现当前方块 <em>(i,j)</em> 的接水高度 <em>water[i][j]</em> 小于与它相邻的 4 个模块的接水高度时，</p><p>则我们将进行调整接水高度，将其相邻的四个方块的接水高度调整与 (<em>i</em>,<em>j</em>) 的高度保持一致；</p></li><li><p>不断重复的进行调整，直到所有的方块的接水高度不再有调整时即为满足要求。</p></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trapRainWater</span><span class="params">(<span class="keyword">int</span>[][] heightMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = heightMap.length;</span><br><span class="line">        <span class="keyword">int</span> n = heightMap[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] dirs = &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> maxHeight = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                maxHeight = Math.max(maxHeight, heightMap[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] water = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                water[i][j] = maxHeight;      </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; qu = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || i == m - <span class="number">1</span> || j == <span class="number">0</span> || j == n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (water[i][j] &gt; heightMap[i][j]) &#123;</span><br><span class="line">                        water[i][j] = heightMap[i][j];</span><br><span class="line">                        qu.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">while</span> (!qu.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] curr = qu.poll();</span><br><span class="line">            <span class="keyword">int</span> x = curr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = curr[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = x + dirs[i], ny = y + dirs[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= m || ny &lt; <span class="number">0</span> || ny &gt;= n) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (water[x][y] &lt; water[nx][ny] &amp;&amp; water[nx][ny] &gt; heightMap[nx][ny]) &#123;</span><br><span class="line">                    water[nx][ny] = Math.max(water[x][y], heightMap[nx][ny]);</span><br><span class="line">                    qu.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nx, ny&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                res += water[i][j] - heightMap[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度:O(M^2N^2)\<br>&amp;空间复杂度:O(MN)<br>\end{align}<br>$$</p><hr><h3 id="广度优先搜索模板"><a href="#广度优先搜索模板" class="headerlink" title="广度优先搜索模板"></a>广度优先搜索模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 搜索过程中的累计最大值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 搜索过程中的标记值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果满足 则入队 同时改值</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == value) &#123;</span><br><span class="line">                matrix[i][j] = -<span class="number">1</span>;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">                bfs(queue, matrix);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.maxValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Queue&lt;<span class="keyword">int</span>[]&gt; queue, <span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 方向数组</span></span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] index = queue.poll();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = index[<span class="number">0</span>] + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = index[<span class="number">1</span>] + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 不超出边界</span></span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; matrix.length &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; matrix[<span class="number">0</span>].length) &#123;</span><br><span class="line">                <span class="comment">// 如果符合要求</span></span><br><span class="line">                <span class="keyword">if</span> (matrix[x][y] == value) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    matrix[x][y] = -<span class="number">1</span>;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x, y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.maxValue = Math.max(count, <span class="keyword">this</span>.maxValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 优先队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一维 接雨水</title>
      <link href="/2021/11/24/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E2%85%A0/"/>
      <url>/2021/11/24/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E2%85%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="一维-接雨水（-模拟-动态规划-双指针-单调栈-）"><a href="#一维-接雨水（-模拟-动态规划-双指针-单调栈-）" class="headerlink" title="一维 接雨水（ 模拟 | 动态规划 | 双指针 | 单调栈 ）"></a>一维 接雨水（ 模拟 | 动态规划 | 双指针 | 单调栈 ）</h3><span id="more"></span><blockquote><blockquote><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p>示例：输入 <code>height = [0,1,0,2,1,0,1,3,2,1,2,1]</code> ，输出 <code>6</code></p><p>题目详情参见 <a><a href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水 - 力扣（LeetCode） (leetcode-cn.com)</a></a></p></blockquote></blockquote><h3 id="解法一：模拟遍历"><a href="#解法一：模拟遍历" class="headerlink" title="解法一：模拟遍历"></a>解法一：模拟遍历</h3><p>思路：</p><ol><li>不妨设数组的长度为 <code>n</code> ，那么从下标 <code>1</code> 到 <code>n - 1</code> 进行遍历；</li><li>对于每个下标 <code>i</code> ，分别向左向右搜索最大值，然后取二者的最小值；</li><li>将此最小值减去 <code>height[i]</code>，即为此下标所能接的雨水数；</li><li>遍历求和，即可得到正确的解答。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> size = height.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> max_left = <span class="number">0</span>, max_right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123; <span class="comment">// 寻找左部最大值</span></span><br><span class="line">            max_left = Math.max(max_left, height[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; size; j++) &#123; <span class="comment">// 寻找右部最大值</span></span><br><span class="line">            max_right = Math.max(max_right, height[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans += Math.min(max_left, max_right) - height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度: O(n^2)\<br>&amp;空间复杂度: O(1)<br>\end{align}<br>$$</p><hr><h3 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h3><p>思路：在解法一（模拟遍历）的时候，每次都需要向左向右进行搜寻，不妨简化这个搜寻过程，从而降低时间复杂度。</p><ol><li>开辟两个数组 <em>leftMax、rightMax</em>，分别记录左边的最大值和右边的最大值；</li><li>因为两个数组记录的值意义不同，所以进行不同的遍历，得到两个数组的值；</li><li><strong>正向遍历得到 <em>leftMax</em>, 反向遍历得到 <em>rightMax</em> ;</strong></li><li>然后从下标 <code>1</code> 到 <code>n - 1</code> 进行遍历求解。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = height.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正向遍历得到左边最大值</span></span><br><span class="line">        <span class="keyword">int</span>[] leftMax = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        leftMax[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            leftMax[i] = Math.max(leftMax[i - <span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反向遍历得到右边最大值</span></span><br><span class="line">        <span class="keyword">int</span>[] rightMax = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        rightMax[n - <span class="number">1</span>] = height[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            rightMax[i] = Math.max(rightMax[i + <span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求和得解</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans += Math.min(leftMax[i], rightMax[i]) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度: O(n)\<br>&amp;空间复杂度: O(n)<br>\end{align}<br>$$</p><hr><h3 id="解法三：双指针"><a href="#解法三：双指针" class="headerlink" title="解法三：双指针"></a>解法三：双指针</h3><p>思路：解法二（动态规划）优化了模拟遍历，但是额外了开辟了空间，那么如何减少空间开辟？</p><ol><li><p><strong>使用双指针和两个变量代替正反遍历得到的两个数组；</strong></p></li><li><p>双指针 <em>left、right</em>, 两个变量 <em>leftMax，rightMax</em>;</p></li><li><p>当两个指针在移动的过程中，进行以下操作：</p><ol><li><p>使用 <em>height[left]，height[right]</em> 更新 <em>leftMax，rightMax</em> 的值；</p></li><li><p>如果 <em>height[left] &lt; height[right]</em>, 那么一定有 <em>leftMax &lt; rightMax</em>，</p><p>下标 <em>left</em> 处的接水量就等于 <em>leftMax - height[left]</em>，然后 <em>left</em> 右移一位；</p><p><a href="#1">（原因解释）</a></p></li><li><p>如果 <em>height[left] ≥ height[right]</em>, 那么一定有 <em>leftMax ≥ rightMax</em>，</p><p>下标 <em>right</em> 处的接水量就等于 <em>rightMax - height[right]</em>，然后 <em>right</em> 左移一位；</p></li></ol></li><li><p>当两个指针相遇时，即可得到接雨水的总量。</p></li></ol><p><strong><a id="1">为什么”一定有”的解释说明：</a></strong></p><blockquote><p>左指针右移的终止条件是找到比 <em>rightMax</em> 大的 <em>leftMax</em>，</p><p>也就是说一旦左指针终止左移，此时的<em>height[left]</em> 一定是 <em>leftMax</em>，且大于 <em>rightMax</em>。</p><p>同理，右指针左移的终止条件是找到比 <em>leftMax</em> 大的 <em>rightMax</em>，</p><p>而此时的 <em>height[right]</em> 就是 <em>rightMax</em>。</p><p>所以这里 <em>height[left] &lt; height[right]</em> 中的 <em>height[right]</em> 就是当前的 <em>rightMax</em>，</p><p>而 <em>height[left] &lt; height[right]</em> 意味着还没找到大于 <em>rightMax 的 leftMax</em>，</p><p>所以 <em>leftMax &lt; rightMax</em></p></blockquote><p>如果 <em>height[left] < height[right]</em>, 那么一定有 <em>leftMax < rightMax</em>，是一个充要条件,</p><p><strong>因此将此判断条件改为：如果 <em>leftMax &lt; rightMax</em>, 依然正确，</strong>可看代码部分注释。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> leftMax = <span class="number">0</span>, rightMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            leftMax = Math.max(leftMax, height[left]);</span><br><span class="line">            rightMax = Math.max(rightMax, height[right]);</span><br><span class="line">            <span class="comment">// if(leftMax &lt; rightMax) 依然正确</span></span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">                ans += leftMax - height[left];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += rightMax - height[right];</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度: O(n)\<br>&amp;空间复杂度: O(1)<br>\end{align}<br>$$</p><hr><h3 id="解法四：单调栈"><a href="#解法四：单调栈" class="headerlink" title="解法四：单调栈"></a>解法四：单调栈</h3><p>思路：上面几种做法都可以理解成<strong>垂直处理</strong>，单调栈的方式为<strong>水平处理</strong>。</p><ol><li>维护一个单调栈存储数组下标，满足从栈底到栈顶的下标对应的数组 <em>height</em> 中的元素<strong>非严格递减</strong>；</li><li>从左到右遍历数组，遍历到下标 <em>i</em> 时，如果栈内至少有两个元素，记栈顶元素为 <em>top</em>，<em>top</em> 的下面一个元素是 <em>left</em>；</li><li>则一定有 <em>height[left] ≥ height[top]</em>，如果 <em>height[i] &gt; height[top]</em>，则得到一个接雨水的区域；</li><li>该区域的宽度是 <em>i−left−1</em>，高度是 <em>min( height[left] , height[i] ) − height[top]</em>，根据宽度和高度即可计算得到该区域能接的雨水量；</li><li>为了得到  <em>left</em>，需要将 <em>top</em> 出栈。在对 <em>top</em> 计算能接的雨水量之后，<em>left</em> 变成新的 <em>top</em>；</li><li>重复上述操作，直到栈变为空，或者栈顶下标对应的 <em>height</em> 中的元素大于或等于 <em>height[i]</em>；</li><li>遍历结束之后即可得到能接的雨水总量。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = height.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> top = stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> left = stack.peek();</span><br><span class="line">                <span class="keyword">int</span> currWidth = i - left - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> currHeight = Math.min(height[left], height[i]) - height[top];</span><br><span class="line">                ans += currWidth * currHeight;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度: O(n)\<br>&amp;空间复杂度: O(n)<br>\end{align}<br>$$</p><hr><h3 id="补充说明：为什么使用-Deque-而不是-Stack-？"><a href="#补充说明：为什么使用-Deque-而不是-Stack-？" class="headerlink" title="补充说明：为什么使用 Deque 而不是 Stack ？"></a><strong>补充说明：为什么使用 Deque 而不是 Stack ？</strong></h3><ol><li><p><code>Deque</code> 是 <code>double ended queue</code> 的简称，习惯上称之为<strong>双端队列</strong></p></li><li><p>由于<code>Vector</code>因效率问题已经被弃用，因此继承<code>Vector</code>的<code>Stack</code>也存在效率问题，故不推荐。</p></li></ol><p>详情可参考文章：</p><p><a>深入理解Java集合之—Deque - 简书 (jianshu.com)](<a href="https://www.jianshu.com/p/d78a7c982edb">https://www.jianshu.com/p/d78a7c982edb</a>)</a></p><p><a><a href="https://www.cnblogs.com/code-duck/p/13569388.html">为什么使用Deque而不使用Stack构造栈 - codeduck - 博客园 (cnblogs.com)</a></a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洗牌算法</title>
      <link href="/2021/11/23/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"/>
      <url>/2021/11/23/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="洗牌算法-模拟洗牌-Fisher-Yates算法"><a href="#洗牌算法-模拟洗牌-Fisher-Yates算法" class="headerlink" title="洗牌算法( 模拟洗牌 | Fisher-Yates算法 )"></a>洗牌算法( 模拟洗牌 | Fisher-Yates算法 )</h3><span id="more"></span><blockquote><blockquote><p>设计算法打乱一个没有重复元素的给定整数数组 nums</p></blockquote></blockquote><h3 id="解法一：模拟洗牌"><a href="#解法一：模拟洗牌" class="headerlink" title="解法一：模拟洗牌"></a>解法一：模拟洗牌</h3><p>思路：首先不妨设数组 <em>nums</em> 的长度为 <em>n</em>，</p><ol><li>不妨用数据结构 <em>waiting</em> 来存放 <em>nums</em> 中的所有元素，并初始化打乱后的数组 <em>shuffled</em></li><li>从数组 <em>shuttle</em> 的 <em>0</em> 下标开始，每次从 <em>waiting</em> 中随机选取一个数据放置到 <em>shuffled</em>，并且从 <em>waiting</em> 中移除该数据</li></ol><p><em>（整体来说：模拟洗牌，每次的选择概率均相等，可以理解成抽签模拟）</em></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] shuffle() &#123;</span><br><span class="line"><span class="keyword">int</span>[] shuffled = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        list.add(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = random.nextInt(list.size());</span><br><span class="line">        shuffled[i] = list.remove(j);</span><br><span class="line">    &#125;</span><br><span class="line">    System.arraycopy(shuffled, <span class="number">0</span>, nums, <span class="number">0</span>, nums.length);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度：O(n^2)<br>&amp;空间复杂度：O(n)<br>\end{align}<br>$$</p><hr><h3 id="解法二：Fisher-Yates洗牌算法"><a href="#解法二：Fisher-Yates洗牌算法" class="headerlink" title="解法二：Fisher-Yates洗牌算法"></a>解法二：Fisher-Yates洗牌算法</h3><p>首先需要理解为什么上面介绍的模拟洗牌算法的时间复杂度为 O(n<sup>2</sup>)，</p><p><code>list.remove(int index)的时间复杂度是O(n - index)</code>, 因此改进算法：</p><ol><li>如果每次的 <em>index</em> 是最后一位，那么时间复杂度就降为 O(1)；</li><li>那么在放入 <em>shuffled</em> 之前, 先将 当前的 index 和 最后一位进行交换；</li><li>将最后一位移除的同时放入 <em>shuffled</em> 的指定位置即可。</li></ol><p>那么在此基础上，我们可以再进行改进，实现<strong>数组的原地乱序</strong></p><ol><li>不再使用数据结构 <em>waiting</em>，仅在原数组上操作；</li><li><strong>不再从数组中移除元素，每次将第 <em>k</em> 个元素与第 <em>1</em> 个元素交换</strong> </li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] shuffle() &#123;</span><br><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i + random.nextInt(nums.length - i);</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度：O(n)<br>&amp;空间复杂度：O(n)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>范围内查询质数</title>
      <link href="/2021/11/23/%E8%8C%83%E5%9B%B4%E5%86%85%E6%9F%A5%E8%AF%A2%E8%B4%A8%E6%95%B0/"/>
      <url>/2021/11/23/%E8%8C%83%E5%9B%B4%E5%86%85%E6%9F%A5%E8%AF%A2%E8%B4%A8%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="查询质数-枚举-埃氏筛-线性筛"><a href="#查询质数-枚举-埃氏筛-线性筛" class="headerlink" title="查询质数( 枚举 | 埃氏筛 | 线性筛 )"></a>查询质数( 枚举 | 埃氏筛 | 线性筛 )</h3><span id="more"></span><blockquote><blockquote><p>统计所有小于非负整数 <em><code>n</code></em> 的质数的数量。</p></blockquote></blockquote><h4 id="解法一：枚举求解"><a href="#解法一：枚举求解" class="headerlink" title="解法一：枚举求解"></a><strong>解法一：枚举求解</strong></h4><p>思路：从 1 ~ n 遍历，统计其中为质数的个数即可。</p><p><em><strong>一些常用的技巧：</strong></em></p><ol><li>在判断循环终止条件时，采用 <code>i * i &lt;= n</code>而不要采用 <code>i &lt;= Math.sqrt(n)</code>,可以降低程序运行时间；</li><li>在循环进行时，循环的变化条件增值，可以改成 <code>i = i + 2</code>而不是 <code>i = i + 1</code>，可以降低程序运行时间；</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans += isPrime(i) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i * i &lt;= x; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度：O(n\sqrt(n))\<br>&amp;空间复杂度：O(1)<br>\end{align}<br>$$</p><hr><h4 id="解法二：厄拉多塞筛法（埃氏筛）"><a href="#解法二：厄拉多塞筛法（埃氏筛）" class="headerlink" title="解法二：厄拉多塞筛法（埃氏筛）"></a><strong>解法二：厄拉多塞筛法（埃氏筛）</strong></h4><blockquote><blockquote><p>枚举没有考虑到数与数的关联性，因此难以再继续优化时间复杂度。</p><p>介绍一个常见的算法，该算法由希腊数学家厄拉多塞（Eratosthenes）提出，称为厄拉多塞筛法，简称埃氏筛。</p></blockquote></blockquote><p><strong>首先确定一个基准：如果 x 是一个质数，那么 2x、3x , ... 一定不是质数。</strong></p><p>那么依然从 2 开始遍历，如果 <code>x</code>是质数，那么标记它的整数倍为合数，最后统计多少质数即可：</p><ol><li>如果<code>x</code>是合数：说明必定存在一个小于<code>x</code>的<code>y</code>，使得其为合数，推断正确；</li><li>如果<code>x</code>是质数：说明不存在比<code>x</code>小的数，是其因子，推断正确。</li></ol><p><em><strong>对于基准的优化：不必从<code>2x</code>、<code>3x</code>这样开始标记，直接从<code>x * x</code>开始标记即可。</strong></em></p><p>不妨声明数组 <code>isPrime[]</code>来记录上述过程，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] isPrime = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(isPrime, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                ans += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">long</span>) i * i &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; n; j += i) &#123;</span><br><span class="line">                        isPrime[j] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度：O(nloglogn)\<br>&amp;空间复杂度：O(n)<br>\end{align}<br>$$</p><hr><h4 id="解法三：线性筛"><a href="#解法三：线性筛" class="headerlink" title="解法三：线性筛"></a>解法三：线性筛</h4><blockquote><blockquote><p>埃氏筛其实存在冗余的标记操作，比如对于<code>45</code>这个数，它会同时被 <code>3</code>,<code>5</code>两个数标记为合数，</p><p>因此我们优化的目标是让每个合数只被标记一次，这样时间复杂度即能保证为 O(n)</p></blockquote></blockquote><p><strong>优化方法：</strong></p><ol><li><p>额外维护一个 primes 数组表示当前得到的质数集合；</p></li><li><p>从小到大遍历，如果当前的数 x 是质数，就将其加入 primes 数组；</p></li><li><p>「标记过程」不再仅当 x 为质数时才进行，而是对每个整数 x 都进行,</p><p>​    对于整数 x，我们不再标记其所有的倍数 <code>x·x</code>,<code>x·(x+1)</code>, … ,</p><p>​    而是只标记质数集合中的数与 x 相乘的数，即 x · primes<sub>0</sub> , x · primes<sub>1</sub> , x⋅primes <sub>2</sub> , … ，</p><p>​    且在发现 x mod primes<sub>i</sub> = 0 时结束当前标记过程 (<strong>这一步确保了不会重复标记</strong>)。</p></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; primes = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] isPrime = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(isPrime, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                primes.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; primes.size() &amp;&amp; i * primes.get(j) &lt; n; ++j) &#123;</span><br><span class="line">                isPrime[i * primes.get(j)] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i % primes.get(j) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> primes.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>&amp;时间复杂度：O(n)\<br>&amp;空间复杂度：O(n)<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java课设总结</title>
      <link href="/2021/11/18/JavaFX/"/>
      <url>/2021/11/18/JavaFX/</url>
      
        <content type="html"><![CDATA[<h3 id="简易PPT实现"><a href="#简易PPT实现" class="headerlink" title="简易PPT实现"></a>简易PPT实现</h3><span id="more"></span><h3 id="内容要求"><a href="#内容要求" class="headerlink" title="内容要求"></a>内容要求</h3><ol><li><strong>内容：开发一个简易的幻灯片制作与播放软件</strong></li><li><strong>基本功能：</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">新建幻灯片，幻灯片由不少于一个页面组成</span><br><span class="line">新建一个空白的幻灯片页面</span><br><span class="line">打开或保存整个幻灯片</span><br><span class="line">在幻灯片页面上绘制基本图形</span><br><span class="line">在幻灯片页面上绘制任意直线</span><br><span class="line">添加文字</span><br><span class="line">设定颜色与文字风格</span><br><span class="line">对幻灯片页面上已有的基本图形、线形、文字进行选取和移动</span><br><span class="line">通过鼠标拖动完成上述绘制和添加文字等操作</span><br></pre></td></tr></table></figure><ol><li><strong>选作功能：</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">幻灯片的全屏播放、翻页</span><br><span class="line">设定画笔、插入图像、修改图像（使用橡皮擦）</span><br><span class="line">图形填充、线型设置</span><br><span class="line">对幻灯片页面上已有的基本图形、线性、文字进行修改</span><br><span class="line">操作的撤销与重组</span><br><span class="line">菜单</span><br><span class="line">简易的JDBC连接MySQL数据库实现用户登录</span><br></pre></td></tr></table></figure><hr><h3 id="帮助文档"><a href="#帮助文档" class="headerlink" title="帮助文档"></a>帮助文档</h3><ol><li><p><strong>开发环境和插件选择</strong>：</p><p><code>Gradle + JavaFx + JPoneiX + JDK 1.8 + Spire.Presentation + IDEA </code></p><p>说明：</p><ol><li>按照 <code>non-modular + idea</code> 使用 JavaFx，会带来配置修改问题</li><li>使用 <code>JPoneiX</code> 开源项目优化 UI 界面，更加美观和方便</li><li>使用<code>Gradle</code>管理项目更加方便，兼容性更好</li></ol></li><li><p><strong>本人项目地址：</strong></p><p>GitHub：<a><a href="https://github.com/Eminem-x/JFoenix">https://github.com/Eminem-x/JFoenix</a></a></p></li></ol><ol start="2"><li><p><strong>JavaFX的基本操作指南：</strong></p><ol><li>官方文档: <a><a href="https://openjfx.io/">https://openjfx.io/</a></a><ul><li>基本内容以及示例说明</li><li>JavaFX的doc文档说明 </li></ul></li><li>WiKi教程: <a><a href="https://iowiki.com/javafx/javafx_images.html">https://iowiki.com/javafx/javafx_images.html</a></a></li><li>JavaFX和FXML的关系阐述： <a><a href="https://blog.csdn.net/theonegis/article/details/50181339">https://blog.csdn.net/theonegis/article/details/50181339</a></a></li></ol></li><li><p><strong>Java操作PPT的免费非开源组件:</strong></p><ol><li><p>官方网址：<a>冰蓝科技 PowerPoint 组件<a href="https://www.e-iceblue.cn/">https://www.e-iceblue.cn/</a></a></p></li><li><p>说明：</p><ol><li><p>此组件目前没有免费开源，会带有水印，不过不影响整体的实现，</p><p>可以通过适当操作，去掉水印的显示；</p></li><li><p>另外官方没有Gradle方式添加到工程，附上Gradle如何添加本地外包的方法：<br> <a href="https://blog.csdn.net/m1213642578/article/details/52763130?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link">Gradle添加本地外包</a></p></li></ol></li></ol></li><li><p><strong>JavaFX实现绘图功能的项目：</strong></p><ol><li>GitHub链接：<a><a href="https://github.com/FlyuZ/FYDrawing-JAVAFX">https://github.com/FlyuZ/FYDrawing-JAVAFX</a></a></li><li>可以参考实现方法，按照需求更改</li></ol></li><li><p><strong>JPoneiX开源项目：</strong></p><ol><li>GitHub链接：<a href="https://github.com/sshahine/JFoenix">https://github.com/sshahine/JFoenix</a></li><li>官方doc文档：<a><a href="https://javadoc.io/doc/com.jfoenix/jfoenix/latest/overview-summary.html">https://javadoc.io/doc/com.jfoenix/jfoenix/latest/overview-summary.html</a></a></li><li>此开源项目美化了JavaFx的组件UI，并且提供了许多便于使用和操作的组件</li></ol></li><li><p><strong>可用 Icon 的选取：</strong></p><ol><li>样式链接：<a><a href="https://fontawesome.com/v5.15/icons?d=gallery&amp;p=4&amp;s=solid&amp;m=free">https://fontawesome.com/v5.15/icons?d=gallery&amp;p=4&amp;s=solid&amp;m=free</a></a></li><li>使用时在 <code>Extern Libraries</code>下寻找此插件的 <code>solid</code>样式，然后相应位置替换即可</li><li>其他图片可能会失效，尝试即可，推荐使用 <code>solid</code></li></ol></li></ol><hr><h3 id="项目演示"><a href="#项目演示" class="headerlink" title="项目演示"></a>项目演示</h3><ol><li><p>文件结构：</p><p><img src="/2021/11/18/JavaFX/java%E8%AF%BE%E8%AE%BE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="文件结构"></p></li><li><p>项目运行效果：</p><p><img src="/2021/11/18/JavaFX/java%E8%AF%BE%E8%AE%BE%E6%95%88%E6%9E%9C%E5%9B%BE1.png" alt="主界面"></p><p><img src="/2021/11/18/JavaFX/java%E8%AF%BE%E8%AE%BE%E6%95%88%E6%9E%9C%E5%9B%BE2.png" alt="画图"></p><p><img src="/2021/11/18/JavaFX/java%E8%AF%BE%E8%AE%BE%E6%95%88%E6%9E%9C%E5%9B%BE3.png" alt="放映"></p></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 课程设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
